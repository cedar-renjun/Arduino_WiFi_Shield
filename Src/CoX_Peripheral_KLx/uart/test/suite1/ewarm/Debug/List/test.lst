###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.1.53790/W32 for ARM     24/Feb/2013  09:52:13 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\renjun\Desktop\Cox\CoX_Peripheral\CoX_Periphera #
#                    l_KLx\testframe\test.c                                   #
#    Command line =  C:\Users\renjun\Desktop\Cox\CoX_Peripheral\CoX_Periphera #
#                    l_KLx\testframe\test.c -D ewarm -lCN                     #
#                    C:\Users\renjun\Desktop\Cox\CoX_Peripheral\CoX_Periphera #
#                    l_KLx\uart\test\suite1\ewarm\Debug\List\ -lB             #
#                    C:\Users\renjun\Desktop\Cox\CoX_Peripheral\CoX_Periphera #
#                    l_KLx\uart\test\suite1\ewarm\Debug\List\ -o              #
#                    C:\Users\renjun\Desktop\Cox\CoX_Peripheral\CoX_Periphera #
#                    l_KLx\uart\test\suite1\ewarm\Debug\Obj\ --no_cse         #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M0+ -e --fpu=None --dlib_config             #
#                    "C:\Program Files\IAR Systems\Embedded Workbench         #
#                    6.4\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\Users\renjun\Desktop\Cox\CoX_Peripheral\CoX_Periphera #
#                    l_KLx\uart\test\suite1\ewarm\..\..\..\..\libcox\ -I      #
#                    C:\Users\renjun\Desktop\Cox\CoX_Peripheral\CoX_Periphera #
#                    l_KLx\uart\test\suite1\ewarm\..\..\..\..\testframe\ -I   #
#                    C:\Users\renjun\Desktop\Cox\CoX_Peripheral\CoX_Periphera #
#                    l_KLx\uart\test\suite1\ewarm\..\..\..\..\uart\test\suite #
#                    1\src\ -On                                               #
#    List file    =  C:\Users\renjun\Desktop\Cox\CoX_Peripheral\CoX_Periphera #
#                    l_KLx\uart\test\suite1\ewarm\Debug\List\test.lst         #
#    Object file  =  C:\Users\renjun\Desktop\Cox\CoX_Peripheral\CoX_Periphera #
#                    l_KLx\uart\test\suite1\ewarm\Debug\Obj\test.o            #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\renjun\Desktop\Cox\CoX_Peripheral\CoX_Peripheral_KLx\testframe\test.c
      1          //*****************************************************************************
      2          //
      3          //! \file test.c
      4          //! \brief Tests support code.
      5          //! \version 1.0
      6          //! \date 5/19/2011
      7          //! \author CooCox
      8          //! \copy
      9          //!
     10          //! Copyright (c) 2009-2011 CooCox.  All rights reserved.
     11          //
     12          //*****************************************************************************
     13          
     14          #include "test.h"

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp void *memset(void *, int, size_t)
   \                     memset:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x002A             MOVS     R2,R5
   \   0000000A   0x0031             MOVS     R1,R6
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       __aeabi_memset
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xBD70             POP      {R4-R6,PC}       ;; return
     15          #include "testcase.h"
     16          
     17          
     18          
     19          #ifdef ENHANCE_MODE
     20          
     21          //
     22          // the following const value only used in TestAssert function
     23          //
     24          #define FSM_BEGIN       0
     25          #define FSM_END         1
     26          #define FSM_CHAR        2
     27          #define FSM_DISPATCH    3
     28          #define NEW_LINE                                                               \
     29          "------------------------------------------------------------------------------"
     30          
     31          typedef void (* VirtualIoPort)(char);
     32          
     33          
     34          //
     35          // private function
     36          //
     37          
     38          static uint32 NumToStr (uint32 Num,
     39                                  uint32 Base,
     40                                  uint8  *Buffer,
     41                                  uint32 BufferSize);
     42          
     43          static uint32 PrintDec (VirtualIoPort pIOPutChar,
     44                                  void * pParam);
     45          
     46          static uint32 PrintHex (VirtualIoPort pIOPutChar,
     47                                  void * pParam);
     48          
     49          static uint32 PrintStr (VirtualIoPort pIOPutChar,
     50                                  void * pParam);
     51          
     52          static uint32 Print    (VirtualIoPort pIoPutchar,
     53                                  const char * pcMsg,
     54                                  va_list VarPara);
     55          static void   BufWrite (char ch);
     56          
     57          //
     58          // Public function
     59          //
     60          uint32 FILE_Print  (const char * pcMsg, ...);
     61          uint32 UART_Print  (const char * pcMsg, ...);
     62          void   _TestAssert (const char * pcMsg, ...);
     63          
     64          #else
     65          
     66          static void PrintN(unsigned long n);
     67          static void Print(char* pcMsg);
     68          static void PrintLine(char* pcMsg);
     69          static void PrintNewLine(void);
     70          static void PrintTokens(void);
     71          #endif
     72          
     73          static void ClearTokens(void);
     74          static void ExecuteTest(const tTestCase *psTest);
     75          static xtBoolean _TestFail(void);
     76          
     77          

   \                                 In section .bss, align 1
     78          static xtBoolean g_bLocalFail, g_bGlobalFail;
   \                     g_bLocalFail:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     g_bGlobalFail:
   \   00000000                      DS8 1
     79          
     80          //
     81          // tokens buffer
     82          //

   \                                 In section .bss, align 4
     83          static char g_pcTokensBuffer[TEST_TOKENS_MAX_NUM];
   \                     g_pcTokensBuffer:
   \   00000000                      DS8 12
     84          
     85          //
     86          // error string buffer
     87          //

   \                                 In section .bss, align 4
     88          static char g_pcErrorInfoBuffer[TEST_ERROR_BUF_SIZE];
   \                     g_pcErrorInfoBuffer:
   \   00000000                      DS8 512
     89          
     90          //
     91          // Error Info Buffer Index
     92          //

   \                                 In section .bss, align 4
     93          static unsigned long ErrorBufIndex;
   \                     ErrorBufIndex:
   \   00000000                      DS8 4
     94          
     95          //
     96          // current point of the token buffer
     97          //

   \                                 In section .bss, align 4
     98          static char *g_pcTok;
   \                     g_pcTok:
   \   00000000                      DS8 4
     99          
    100          #ifndef ENHANCE_MODE
    101          //*****************************************************************************
    102          //
    103          //! \brief Prints a decimal unsigned number.
    104          //!
    105          //! \param n is the number to be printed
    106          //!
    107          //! \details Prints a decimal unsigned number.
    108          //!
    109          //! \return None.
    110          //
    111          //*****************************************************************************
    112          static
    113          void PrintN(unsigned long n)
    114          {
    115              char buf[16], *p;
    116          
    117              if (n == 0)
    118              {
    119                  TestIOPut('0');
    120              }
    121              else
    122              {
    123                  p = buf;
    124                  while (n != 0)
    125                  {
    126                      *p++ = (n % 10) + '0';
    127                      n /= 10;
    128                  }
    129          
    130                  while (p > buf)
    131                      TestIOPut(*--p);
    132              }
    133          }
    134          
    135          //*****************************************************************************
    136          //
    137          //! \brief Prints a line without final end-of-line.
    138          //!
    139          //! \param pcMsg is the message to print
    140          //!
    141          //! \details Prints a line without final end-of-line.
    142          //!
    143          //! \return None.
    144          //
    145          //*****************************************************************************
    146          static void
    147          Print(char *pcMsg)
    148          {
    149              while (*pcMsg != '\0')
    150              {
    151                  TestIOPut(*pcMsg++);
    152              }
    153          }
    154          
    155          //*****************************************************************************
    156          //
    157          //! \brief Prints a line.
    158          //!
    159          //! \param pcMsg is the message to print
    160          //!
    161          //! \details Prints a line.
    162          //!
    163          //! \return None.
    164          //
    165          //*****************************************************************************
    166          static void
    167          PrintLine(char *pcMsg)
    168          {
    169              Print(pcMsg);
    170              TestIOPut('\r');
    171              TestIOPut('\n');
    172          }
    173          
    174          //*****************************************************************************
    175          //
    176          //! \brief Prints a line of "---".
    177          //!
    178          //! \param None
    179          //!
    180          //! \return None.
    181          //
    182          //*****************************************************************************
    183          static void
    184          PrintNewLine(void)
    185          {
    186              unsigned int i;
    187              for (i = 0; i < 76; i++)
    188              {
    189                  TestIOPut('-');
    190              }
    191              TestIOPut('\r');
    192              TestIOPut('\n');
    193          }
    194          #endif
    195          
    196          //*****************************************************************************
    197          //
    198          //! \brief clear the token buffer
    199          //!
    200          //! \param None
    201          //!
    202          //! \return None.
    203          //
    204          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
    205          static void
    206          ClearTokens(void)
    207          {
    208              g_pcTok = g_pcTokensBuffer;
   \                     ClearTokens:
   \   00000000   0x....             LDR      R0,??DataTable6
   \   00000002   0x....             LDR      R1,??DataTable6_1
   \   00000004   0x6001             STR      R1,[R0, #+0]
    209          }
   \   00000006   0x4770             BX       LR               ;; return
    210          
    211          #ifndef ENHANCE_MODE
    212          //*****************************************************************************
    213          //
    214          //! \brief Print the tokens.
    215          //!
    216          //! \param None
    217          //!
    218          //!
    219          //! \return None.
    220          //
    221          //*****************************************************************************
    222          static void
    223          PrintTokens(void)
    224          {
    225              char *pcToken = g_pcTokensBuffer;
    226          
    227              while (pcToken < g_pcTok)
    228              {
    229                  TestIOPut(*pcToken++);
    230              }
    231          }
    232          #endif
    233          
    234          //*****************************************************************************
    235          //
    236          //! \brief Emits a token into the tokens buffer.
    237          //!
    238          //! \param token is a char to be emit into the buffer
    239          //!
    240          //! \return None.
    241          //
    242          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
    243          void TestEmitToken(char cToken)
    244          {
   \                     TestEmitToken:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    245              TestDisableIRQ();
   \   00000004   0x.... 0x....      BL       TestDisableIRQ
    246              if(g_pcTok < (g_pcTokensBuffer + TEST_TOKENS_MAX_NUM) )
   \   00000008   0x....             LDR      R0,??DataTable6
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x....             LDR      R1,??DataTable6_1
   \   0000000E   0x310A             ADDS     R1,R1,#+10
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xD207             BCS      ??TestEmitToken_0
    247              {
    248                  *g_pcTok++ = cToken;
   \   00000014   0x....             LDR      R0,??DataTable6
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x7004             STRB     R4,[R0, #+0]
   \   0000001A   0x....             LDR      R0,??DataTable6
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
   \   00000020   0x....             LDR      R1,??DataTable6
   \   00000022   0x6008             STR      R0,[R1, #+0]
    249              }
    250              TestEnableIRQ();
   \                     ??TestEmitToken_0:
   \   00000024   0x.... 0x....      BL       TestEnableIRQ
    251          }
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    252          
    253          #ifndef ENHANCE_MODE
    254          //*****************************************************************************
    255          //
    256          //! \brief Clear Error info buffer.
    257          //!
    258          //! \param None.
    259          //!
    260          //! \return None.
    261          //
    262          //*****************************************************************************
    263          static void
    264          TestErrorInfoClear(void)
    265          {
    266              int i = 0;
    267          
    268              while(i < TEST_ERROR_BUF_SIZE)
    269              {
    270                  g_pcErrorInfoBuffer[i++] = '\0';
    271              }
    272          
    273          }
    274          
    275          //*****************************************************************************
    276          //
    277          //! \brief store the error message.
    278          //!
    279          //! \param pcMessage is the point of the error message.
    280          //!
    281          //! \return None.
    282          //
    283          //*****************************************************************************
    284          static void
    285          TestErrorInfoStore(char *pcMessage)
    286          {
    287              int i = 0;
    288          
    289              while((i < TEST_ERROR_BUF_SIZE-1) && g_pcErrorInfoBuffer[i] != '\0')
    290              {
    291                  i++;
    292              }
    293          
    294              while ((*pcMessage != '\0') && (i < TEST_ERROR_BUF_SIZE-1))
    295              {
    296                  g_pcErrorInfoBuffer[i++] = *pcMessage++;
    297              }
    298          
    299              g_pcErrorInfoBuffer[i] = '\0';
    300          }
    301          
    302          //*****************************************************************************
    303          //
    304          //! \brief store the error message.
    305          //!
    306          //! \param n is a number.
    307          //!
    308          //! \return None.
    309          //
    310          //*****************************************************************************
    311          static void
    312          TestErrorInfoStoreNumber(unsigned long n)
    313          {
    314              char buf[16], *p;
    315          
    316              int i = 0;
    317          
    318              while((i < TEST_ERROR_BUF_SIZE-1) && g_pcErrorInfoBuffer[i] != '\0')
    319              {
    320                  i++;
    321              }
    322          
    323          
    324              if (n == 0 && (i < TEST_ERROR_BUF_SIZE-1))
    325              {
    326                  g_pcErrorInfoBuffer[i++] = '0';
    327              }
    328              else
    329              {
    330                  p = buf;
    331                  while (n != 0)
    332                  {
    333                      *p++ = (n % 10) + '0';
    334                      n /= 10;
    335                  }
    336          
    337          
    338                  while (p > buf)
    339                  {
    340                      g_pcErrorInfoBuffer[i++] = *--p;
    341                  }
    342              }
    343          
    344              g_pcErrorInfoBuffer[i] = '\0';
    345          
    346          }
    347          #endif
    348          
    349          //*****************************************************************************
    350          //
    351          //! \brief set the global value of error flag.
    352          //!
    353          //! \return None.
    354          //
    355          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
    356          static xtBoolean
    357          _TestFail(void)
    358          {
    359              g_bLocalFail = xtrue;
   \                     _TestFail:
   \   00000000   0x....             LDR      R0,??DataTable6_2
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x7001             STRB     R1,[R0, #+0]
    360              g_bGlobalFail = xtrue;
   \   00000006   0x....             LDR      R0,??DataTable6_3
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x7001             STRB     R1,[R0, #+0]
    361              return xtrue;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x4770             BX       LR               ;; return
    362          }
    363          
    364          #ifndef ENHANCE_MODE
    365          //*****************************************************************************
    366          //
    367          //! \brief Test assertion.
    368          //!
    369          //! \param pcFile is the current file name. usually is \b __FILE__
    370          //! \param ulLine is the current line number. usually is \b __LINE__
    371          //! \param bCondition is the checking expr. \b xtrue, \bxfalse
    372          //! \param pcMsg failure message
    373          //!
    374          //! \details The TestAssert macro, which does the actual assertion checking.
    375          //!
    376          //! \return None.
    377          //
    378          //*****************************************************************************
    379          xtBoolean
    380          _TestAssert(char* pcFile, unsigned long ulLine,
    381                        xtBoolean bCondition,
    382                        char * pcMsg)
    383          {
    384              if (bCondition == xfalse)
    385              {
    386                  TestErrorInfoClear();
    387                  TestErrorInfoStore("\r\nFile:\t");
    388                  TestErrorInfoStore(pcFile);
    389                  TestErrorInfoStore("\r\nLine:\t");
    390                  TestErrorInfoStoreNumber(ulLine);
    391                  TestErrorInfoStore("\r\nError:\t");
    392                  TestErrorInfoStore(pcMsg);
    393                  return _TestFail();
    394              }
    395          
    396              return xfalse;
    397          }
    398          #endif
    399          
    400          //*****************************************************************************
    401          //
    402          //! \brief Test sequence assertion.
    403          //!
    404          //! \param pcExpected is the expect token seq.
    405          //! \param ulDelay wait delay time
    406          
    407          //!
    408          //! \details Test sequence assertion.
    409          //! \note If ulDelay is -1,then this will not break until sequence token is
    410          //! finished! if ulDelay is not -1,then it will be wait delay time.ulDelay
    411          //! is 0,show that there will be no delay!
    412          //!
    413          //! \return None.
    414          //
    415          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
    416          xtBoolean
    417          _TestAssertSequenceBreak(char *pcExpected, unsigned long ulDelay)
    418          {
   \                     _TestAssertSequenceBreak:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000F             MOVS     R7,R1
    419              char *cp = g_pcTokensBuffer;
   \   00000006   0x....             LDR      R5,??DataTable6_1
    420              unsigned long ulTemp = ulDelay;
   \   00000008   0x003E             MOVS     R6,R7
    421              do
    422              {
    423                  while (cp < g_pcTok)
   \                     ??_TestAssertSequenceBreak_0:
   \   0000000A   0x....             LDR      R0,??DataTable6
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x4285             CMP      R5,R0
   \   00000010   0xD20C             BCS      ??_TestAssertSequenceBreak_1
    424                  {
    425                      if (*cp++ != *pcExpected++)
   \   00000012   0x0028             MOVS     R0,R5
   \   00000014   0x0005             MOVS     R5,R0
   \   00000016   0x1C6D             ADDS     R5,R5,#+1
   \   00000018   0x0021             MOVS     R1,R4
   \   0000001A   0x000C             MOVS     R4,R1
   \   0000001C   0x1C64             ADDS     R4,R4,#+1
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x7809             LDRB     R1,[R1, #+0]
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xD0F1             BEQ      ??_TestAssertSequenceBreak_0
    426                      {
    427                          return _TestFail();
   \   00000026   0x.... 0x....      BL       _TestFail
   \   0000002A   0xE017             B        ??_TestAssertSequenceBreak_2
    428                      }
    429                  }
    430                  SysCtlDelay(1);
   \                     ??_TestAssertSequenceBreak_1:
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x.... 0x....      BL       SysCtlDelay
    431                  if (*pcExpected == '\0')
   \   00000032   0x7820             LDRB     R0,[R4, #+0]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD103             BNE      ??_TestAssertSequenceBreak_3
    432                  {
    433                      ClearTokens();
   \   00000038   0x.... 0x....      BL       ClearTokens
    434                      return xfalse;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xE00D             B        ??_TestAssertSequenceBreak_2
    435                  }
    436                  if (ulDelay == 0xFFFFFFFF)
   \                     ??_TestAssertSequenceBreak_3:
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000044   0x4287             CMP      R7,R0
   \   00000046   0xD102             BNE      ??_TestAssertSequenceBreak_4
    437                  {
    438                      ulTemp = 1;
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0x0006             MOVS     R6,R0
   \   0000004C   0xE002             B        ??_TestAssertSequenceBreak_5
    439                  }
    440                  else if(ulDelay != 0)
   \                     ??_TestAssertSequenceBreak_4:
   \   0000004E   0x2F00             CMP      R7,#+0
   \   00000050   0xD000             BEQ      ??_TestAssertSequenceBreak_5
    441                  {
    442                      ulTemp--;
   \   00000052   0x1E76             SUBS     R6,R6,#+1
    443                  }
    444              } while(ulTemp);
   \                     ??_TestAssertSequenceBreak_5:
   \   00000054   0x2E00             CMP      R6,#+0
   \   00000056   0xD1D8             BNE      ??_TestAssertSequenceBreak_0
    445              return _TestFail();
   \   00000058   0x.... 0x....      BL       _TestFail
   \                     ??_TestAssertSequenceBreak_2:
   \   0000005C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    446          }
    447          
    448          //*****************************************************************************
    449          //
    450          //! \brief Execute the test.
    451          //!
    452          //! \param psTest is the point of the test case.
    453          //!
    454          //! \details Test suite execution.
    455          //!
    456          //! \return None.
    457          //
    458          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
    459          static void
    460          ExecuteTest(const tTestCase *psTest)
    461          {
   \                     ExecuteTest:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    462              //
    463              // Initialization
    464              //
    465              ClearTokens();
   \   00000004   0x.... 0x....      BL       ClearTokens
    466              g_bLocalFail = xfalse;
   \   00000008   0x....             LDR      R0,??DataTable6_2
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x7001             STRB     R1,[R0, #+0]
    467          
    468              if (psTest->Setup != 0)
   \   0000000E   0x6860             LDR      R0,[R4, #+4]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD001             BEQ      ??ExecuteTest_0
    469              {
    470                  psTest->Setup();
   \   00000014   0x6860             LDR      R0,[R4, #+4]
   \   00000016   0x4780             BLX      R0
    471              }
    472          
    473              psTest->Execute();
   \                     ??ExecuteTest_0:
   \   00000018   0x68E0             LDR      R0,[R4, #+12]
   \   0000001A   0x4780             BLX      R0
    474          
    475              if (psTest->TearDown != 0)
   \   0000001C   0x68A0             LDR      R0,[R4, #+8]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD001             BEQ      ??ExecuteTest_1
    476              {
    477                  psTest->TearDown();
   \   00000022   0x68A0             LDR      R0,[R4, #+8]
   \   00000024   0x4780             BLX      R0
    478              }
    479          }
   \                     ??ExecuteTest_1:
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    480          
    481          
    482          #ifndef ENHANCE_MODE
    483          //*****************************************************************************
    484          //
    485          //! \brief Test execution thread function.
    486          //!
    487          //! \param None
    488          //!
    489          //! \details Test execution thread function.
    490          //!
    491          //! \return The test result xtrue or xfalse.
    492          //
    493          //*****************************************************************************
    494          xtBoolean
    495          TestMain(void)
    496          {
    497              int i, j;
    498          
    499              TestIOInit();
    500          
    501              PrintLine("");
    502              PrintLine("*** CooCox CoIDE components test suites");
    503              PrintLine("***");
    504          #ifdef TEST_COMPONENTS_NAME
    505              Print("*** Components: ");
    506              PrintLine(TEST_COMPONENTS_NAME);
    507          #endif
    508          #ifdef TEST_COMPONENTS_VERSION
    509              Print("*** Version:       ");
    510              PrintLine(TEST_COMPONENTS_VERSION);
    511          #endif
    512          #ifdef TEST_BOARD_NAME
    513              Print("*** Test Board:   ");
    514              PrintLine(TEST_BOARD_NAME);
    515          #endif
    516              PrintLine("");
    517          
    518              g_bGlobalFail = xfalse;
    519              i = 0;
    520              while (g_psPatterns[i])
    521              {
    522                  j = 0;
    523                  while (g_psPatterns[i][j])
    524                  {
    525                      PrintNewLine();
    526                      Print("--- Test Case ");
    527                      PrintN(i + 1);
    528                      Print(".");
    529                      PrintN(j + 1);
    530                      Print(" (");
    531                      Print(g_psPatterns[i][j]->GetTest());
    532                      PrintLine(")");
    533          
    534                      ExecuteTest(g_psPatterns[i][j]);
    535                      if (g_bLocalFail == xtrue)
    536                      {
    537                          Print("--- Result: FAILURE ");
    538                          PrintLine("");
    539                          //
    540                          //printf error information
    541                          //
    542                          Print(g_pcErrorInfoBuffer);
    543                          PrintLine("");
    544                          if (g_pcTokensBuffer < g_pcTok)
    545                          {
    546                              Print(" The tokens in buffer is: ");
    547                              PrintTokens();
    548                              PrintLine("");
    549                          }
    550                      }
    551                      else
    552                      {
    553                          PrintLine("--- Result: SUCCESS ");
    554                      }
    555                      j++;
    556                  }
    557                  i++;
    558              }
    559          
    560              PrintNewLine();
    561              PrintLine("");
    562              Print("Final result: ");
    563          
    564              if (g_bGlobalFail == xtrue)
    565              PrintLine("FAILURE");
    566              else
    567              PrintLine("SUCCESS");
    568          
    569              return g_bGlobalFail;
    570          }
    571          #endif
    572          
    573          //
    574          // Enhance Mode
    575          //
    576          #ifdef ENHANCE_MODE

   \                                 In section .text, align 2, keep-with-next
    577          static uint32 NumToStr(uint32 Num,
    578                                 uint32  Base,
    579                                 uint8  *Buffer,
    580                                 uint32 BufferSize)
    581          {
   \                     NumToStr:
   \   00000000   0xB5FB             PUSH     {R0,R1,R3-R7,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x0014             MOVS     R4,R2
    582              uint32        tmpNum = Num;
   \   00000006   0x9D01             LDR      R5,[SP, #+4]
    583              uint32        index  = 0;
   \   00000008   0x2600             MOVS     R6,#+0
    584              uint32        Strlen = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
    585              const uint8 * NumStr = (uint8 *)"0123456789ABCDEF";
   \   0000000C   0x....             LDR      R0,??DataTable10
   \   0000000E   0x9000             STR      R0,[SP, #+0]
    586          
    587              if((Buffer == NULL) || (BufferSize == 0))
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD002             BEQ      ??NumToStr_0
   \   00000014   0x9803             LDR      R0,[SP, #+12]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD103             BNE      ??NumToStr_1
    588              {
    589                  Strlen = 0;
   \                     ??NumToStr_0:
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x0007             MOVS     R7,R0
    590                  return (Strlen);
   \   0000001E   0x0038             MOVS     R0,R7
   \   00000020   0xE030             B        ??NumToStr_2
    591              }
    592          
    593              if(tmpNum == 0)
   \                     ??NumToStr_1:
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD107             BNE      ??NumToStr_3
    594              {
    595                  *Buffer = '0';
   \   00000026   0x2030             MOVS     R0,#+48
   \   00000028   0x7020             STRB     R0,[R4, #+0]
    596                  *(Buffer+1) = '\0';
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x7060             STRB     R0,[R4, #+1]
    597          
    598                  Strlen = 1;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x0007             MOVS     R7,R0
    599                  return (Strlen);
   \   00000032   0x0038             MOVS     R0,R7
   \   00000034   0xE026             B        ??NumToStr_2
    600              }
    601          
    602              while(tmpNum)
   \                     ??NumToStr_3:
   \   00000036   0x2D00             CMP      R5,#+0
   \   00000038   0xD006             BEQ      ??NumToStr_4
    603              {
    604                  tmpNum /= Base;
   \   0000003A   0x0028             MOVS     R0,R5
   \   0000003C   0x9902             LDR      R1,[SP, #+8]
   \   0000003E   0x.... 0x....      BL       __aeabi_uidiv
   \   00000042   0x0005             MOVS     R5,R0
    605                  index++;
   \   00000044   0x1C76             ADDS     R6,R6,#+1
   \   00000046   0xE7F6             B        ??NumToStr_3
    606              }
    607          
    608              Strlen = index;
   \                     ??NumToStr_4:
   \   00000048   0x0037             MOVS     R7,R6
    609              if(Strlen > (BufferSize-1))
   \   0000004A   0x9803             LDR      R0,[SP, #+12]
   \   0000004C   0x1E40             SUBS     R0,R0,#+1
   \   0000004E   0x42B8             CMP      R0,R7
   \   00000050   0xD203             BCS      ??NumToStr_5
    610              {
    611                  Strlen = 0;
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x0007             MOVS     R7,R0
    612                  return (Strlen);
   \   00000056   0x0038             MOVS     R0,R7
   \   00000058   0xE014             B        ??NumToStr_2
    613              }
    614          
    615              *(Buffer + index) = '\0';
   \                     ??NumToStr_5:
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x55A0             STRB     R0,[R4, R6]
    616              tmpNum = Num;
   \   0000005E   0x9801             LDR      R0,[SP, #+4]
   \   00000060   0x0005             MOVS     R5,R0
    617          
    618              while(tmpNum)
   \                     ??NumToStr_6:
   \   00000062   0x2D00             CMP      R5,#+0
   \   00000064   0xD00D             BEQ      ??NumToStr_7
    619              {
    620                  --index;
   \   00000066   0x1E76             SUBS     R6,R6,#+1
    621                  *(Buffer + index) = (uint8)*(tmpNum%Base + NumStr);
   \   00000068   0x0028             MOVS     R0,R5
   \   0000006A   0x9902             LDR      R1,[SP, #+8]
   \   0000006C   0x.... 0x....      BL       __aeabi_uidivmod
   \   00000070   0x9800             LDR      R0,[SP, #+0]
   \   00000072   0x5C40             LDRB     R0,[R0, R1]
   \   00000074   0x55A0             STRB     R0,[R4, R6]
    622                  tmpNum /= Base;
   \   00000076   0x0028             MOVS     R0,R5
   \   00000078   0x9902             LDR      R1,[SP, #+8]
   \   0000007A   0x.... 0x....      BL       __aeabi_uidiv
   \   0000007E   0x0005             MOVS     R5,R0
   \   00000080   0xE7EF             B        ??NumToStr_6
    623              }
    624          
    625              return (Strlen);
   \                     ??NumToStr_7:
   \   00000082   0x0038             MOVS     R0,R7
   \                     ??NumToStr_2:
   \   00000084   0xB004             ADD      SP,SP,#+16
   \   00000086   0xBDF0             POP      {R4-R7,PC}       ;; return
    626          }
    627          
    628          

   \                                 In section .text, align 2, keep-with-next
    629          static uint32 PrintDec(VirtualIoPort pIOPutChar, void * pParam)
    630          {
   \                     PrintDec:
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x0006             MOVS     R6,R0
    631          #define BUF_SIZE 16
    632              uint32 i             = 0;
   \   00000006   0x2400             MOVS     R4,#+0
    633              uint32 NumOfChar     = 0;
   \   00000008   0x2500             MOVS     R5,#+0
    634              uint32 DecValue      = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
    635              uint8  Buf[BUF_SIZE] = {0};
   \   0000000C   0x4668             MOV      R0,SP
   \   0000000E   0x2110             MOVS     R1,#+16
   \   00000010   0x.... 0x....      BL       __aeabi_memclr4
    636          
    637              //
    638              // check the argument
    639              //
    640              if(NULL == pParam)
   \   00000014   0x9804             LDR      R0,[SP, #+16]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD101             BNE      ??PrintDec_0
    641              {
    642                  return NumOfChar;
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0xE01F             B        ??PrintDec_1
    643              }
    644          
    645              DecValue = (uint32)pParam;
   \                     ??PrintDec_0:
   \   0000001E   0x9804             LDR      R0,[SP, #+16]
   \   00000020   0x0007             MOVS     R7,R0
    646          
    647              //
    648              // Clear the memory
    649              //
    650              for(i = 0; i < BUF_SIZE; i++)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x0004             MOVS     R4,R0
   \                     ??PrintDec_2:
   \   00000026   0x2C10             CMP      R4,#+16
   \   00000028   0xD204             BCS      ??PrintDec_3
    651              {
    652                  Buf[i] = '\0';
   \   0000002A   0x4668             MOV      R0,SP
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x5501             STRB     R1,[R0, R4]
    653              }
   \   00000030   0x1C64             ADDS     R4,R4,#+1
   \   00000032   0xE7F8             B        ??PrintDec_2
    654          
    655              //
    656              // Convert num to dec format
    657              //
    658              NumToStr(DecValue, 10, &Buf[0], BUF_SIZE);
   \                     ??PrintDec_3:
   \   00000034   0x2310             MOVS     R3,#+16
   \   00000036   0x466A             MOV      R2,SP
   \   00000038   0x210A             MOVS     R1,#+10
   \   0000003A   0x0038             MOVS     R0,R7
   \   0000003C   0x.... 0x....      BL       NumToStr
    659          
    660              //
    661              // Output String to IO port,and count the num of chars
    662              //
    663              for(i = 0; (i < BUF_SIZE) && ('\0' != Buf[i]); i++)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x0004             MOVS     R4,R0
   \                     ??PrintDec_4:
   \   00000044   0x2C10             CMP      R4,#+16
   \   00000046   0xD209             BCS      ??PrintDec_5
   \   00000048   0x4668             MOV      R0,SP
   \   0000004A   0x5D00             LDRB     R0,[R0, R4]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD005             BEQ      ??PrintDec_5
    664              {
    665                  (*pIOPutChar)(Buf[i]);
   \   00000050   0x4668             MOV      R0,SP
   \   00000052   0x5D00             LDRB     R0,[R0, R4]
   \   00000054   0x47B0             BLX      R6
    666                  NumOfChar++;
   \   00000056   0x1C6D             ADDS     R5,R5,#+1
    667              }
   \   00000058   0x1C64             ADDS     R4,R4,#+1
   \   0000005A   0xE7F3             B        ??PrintDec_4
    668          
    669              return NumOfChar;
   \                     ??PrintDec_5:
   \   0000005C   0x0028             MOVS     R0,R5
   \                     ??PrintDec_1:
   \   0000005E   0xB005             ADD      SP,SP,#+20
   \   00000060   0xBDF0             POP      {R4-R7,PC}       ;; return
    670          #undef BUF_SIZE
    671          }
    672          

   \                                 In section .text, align 2, keep-with-next
    673          static uint32 PrintStr(VirtualIoPort pIOPutChar, void * pParam)
    674          {
   \                     PrintStr:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000F             MOVS     R7,R1
    675              uint32 NumOfChar = 0;
   \   00000006   0x2500             MOVS     R5,#+0
    676              uint8  *pStr     = 0;
   \   00000008   0x2600             MOVS     R6,#+0
    677          
    678              //
    679              // Check the argument
    680              //
    681              if(NULL == pParam)
   \   0000000A   0x2F00             CMP      R7,#+0
   \   0000000C   0xD101             BNE      ??PrintStr_0
    682              {
    683                  return NumOfChar;
   \   0000000E   0x0028             MOVS     R0,R5
   \   00000010   0xE009             B        ??PrintStr_1
    684              }
    685          
    686              pStr = (uint8 *) pParam;
   \                     ??PrintStr_0:
   \   00000012   0x003E             MOVS     R6,R7
    687          
    688              //
    689              // Output the string and count the number of char
    690              //
    691              while(*pStr)
   \                     ??PrintStr_2:
   \   00000014   0x7830             LDRB     R0,[R6, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD004             BEQ      ??PrintStr_3
    692              {
    693                  NumOfChar++;
   \   0000001A   0x1C6D             ADDS     R5,R5,#+1
    694                  (*pIOPutChar)(*pStr++);
   \   0000001C   0x7830             LDRB     R0,[R6, #+0]
   \   0000001E   0x47A0             BLX      R4
   \   00000020   0x1C76             ADDS     R6,R6,#+1
   \   00000022   0xE7F7             B        ??PrintStr_2
    695              }
    696          
    697              return NumOfChar;
   \                     ??PrintStr_3:
   \   00000024   0x0028             MOVS     R0,R5
   \                     ??PrintStr_1:
   \   00000026   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    698          }
    699          
    700          

   \                                 In section .text, align 2, keep-with-next
    701          static uint32 PrintHex(VirtualIoPort pIOPutChar, void * pParam)
    702          {
   \                     PrintHex:
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x0006             MOVS     R6,R0
    703          #define BUF_SIZE 16
    704              uint32 i             = 0;
   \   00000006   0x2400             MOVS     R4,#+0
    705              uint32 NumOfChar     = 0;
   \   00000008   0x2500             MOVS     R5,#+0
    706              uint32 HexValue      = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
    707              uint8  Buf[BUF_SIZE] = {'0','X'};
   \   0000000C   0x4668             MOV      R0,SP
   \   0000000E   0x....             LDR      R1,??DataTable11
   \   00000010   0x2210             MOVS     R2,#+16
   \   00000012   0x.... 0x....      BL       __aeabi_memcpy4
    708          
    709              //
    710              // check the argument
    711              //
    712              if(NULL == pParam)
   \   00000016   0x9804             LDR      R0,[SP, #+16]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD101             BNE      ??PrintHex_0
    713              {
    714                  return NumOfChar;
   \   0000001C   0x0028             MOVS     R0,R5
   \   0000001E   0xE020             B        ??PrintHex_1
    715              }
    716          
    717              HexValue = (uint32)pParam;
   \                     ??PrintHex_0:
   \   00000020   0x9804             LDR      R0,[SP, #+16]
   \   00000022   0x0007             MOVS     R7,R0
    718          
    719              //
    720              // Clear the memory, expect the first two value('0','X')
    721              //
    722              for(i = 2; i < BUF_SIZE; i++)
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0x0004             MOVS     R4,R0
   \                     ??PrintHex_2:
   \   00000028   0x2C10             CMP      R4,#+16
   \   0000002A   0xD204             BCS      ??PrintHex_3
    723              {
    724                  Buf[i] = '\0';
   \   0000002C   0x4668             MOV      R0,SP
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x5501             STRB     R1,[R0, R4]
    725              }
   \   00000032   0x1C64             ADDS     R4,R4,#+1
   \   00000034   0xE7F8             B        ??PrintHex_2
    726          
    727              //
    728              // Convert num to hex format
    729              //
    730              NumToStr(HexValue, 16, &Buf[2], (BUF_SIZE-2));
   \                     ??PrintHex_3:
   \   00000036   0x230E             MOVS     R3,#+14
   \   00000038   0x466A             MOV      R2,SP
   \   0000003A   0x1C92             ADDS     R2,R2,#+2
   \   0000003C   0x2110             MOVS     R1,#+16
   \   0000003E   0x0038             MOVS     R0,R7
   \   00000040   0x.... 0x....      BL       NumToStr
    731          
    732              //
    733              // Output String to IO port,and count the num of chars
    734              //
    735              for(i = 0; (i < BUF_SIZE) && ('\0' != Buf[i]); i++)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x0004             MOVS     R4,R0
   \                     ??PrintHex_4:
   \   00000048   0x2C10             CMP      R4,#+16
   \   0000004A   0xD209             BCS      ??PrintHex_5
   \   0000004C   0x4668             MOV      R0,SP
   \   0000004E   0x5D00             LDRB     R0,[R0, R4]
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD005             BEQ      ??PrintHex_5
    736              {
    737                  (*pIOPutChar)(Buf[i]);
   \   00000054   0x4668             MOV      R0,SP
   \   00000056   0x5D00             LDRB     R0,[R0, R4]
   \   00000058   0x47B0             BLX      R6
    738                  NumOfChar++;
   \   0000005A   0x1C6D             ADDS     R5,R5,#+1
    739              }
   \   0000005C   0x1C64             ADDS     R4,R4,#+1
   \   0000005E   0xE7F3             B        ??PrintHex_4
    740          
    741              return NumOfChar;
   \                     ??PrintHex_5:
   \   00000060   0x0028             MOVS     R0,R5
   \                     ??PrintHex_1:
   \   00000062   0xB005             ADD      SP,SP,#+20
   \   00000064   0xBDF0             POP      {R4-R7,PC}       ;; return
    742          #undef BUF_SIZE
    743          }
    744          

   \                                 In section .text, align 2, keep-with-next
    745          uint32 Print(VirtualIoPort pIoPutchar, const char * pcMsg, va_list VarPara)
    746          {
   \                     Print:
   \   00000000   0xB5F3             PUSH     {R0,R1,R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0016             MOVS     R6,R2
    747              uint8   Token     = 0;
   \   00000006   0x4668             MOV      R0,SP
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x7101             STRB     R1,[R0, #+4]
    748              uint32  NumOfChar = 0;
   \   0000000C   0x2400             MOVS     R4,#+0
    749              const char * pStr = pcMsg;
   \   0000000E   0x9D04             LDR      R5,[SP, #+16]
    750          
    751              uint32 FSM_Status = FSM_BEGIN;
   \   00000010   0x2700             MOVS     R7,#+0
    752          
    753              //
    754              //vaild pointer, return 0
    755              //
    756              if(NULL == pStr)
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD101             BNE      ??Print_0
    757              {
    758                  return 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE05F             B        ??Print_1
    759              }
    760          
    761              //
    762              // use FSM(Fimit state Machine) to deal string
    763              //
    764              while(1)
    765              {
    766                  switch(FSM_Status)
   \                     ??Print_0:
   \   0000001A   0x2F00             CMP      R7,#+0
   \   0000001C   0xD005             BEQ      ??Print_2
   \   0000001E   0x2F02             CMP      R7,#+2
   \   00000020   0xD018             BEQ      ??Print_3
   \   00000022   0xD359             BCC      ??Print_4
   \   00000024   0x2F03             CMP      R7,#+3
   \   00000026   0xD01D             BEQ      ??Print_5
   \   00000028   0xE7F7             B        ??Print_0
    767                  {
    768                      case FSM_BEGIN:
    769                          {
    770                              Token = *pStr;
   \                     ??Print_2:
   \   0000002A   0x4668             MOV      R0,SP
   \   0000002C   0x7829             LDRB     R1,[R5, #+0]
   \   0000002E   0x7101             STRB     R1,[R0, #+4]
    771          
    772                              if('\0' == Token)
   \   00000030   0x4668             MOV      R0,SP
   \   00000032   0x7900             LDRB     R0,[R0, #+4]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD102             BNE      ??Print_6
    773                              {
    774                                  FSM_Status = FSM_END;
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0x0007             MOVS     R7,R0
   \   0000003C   0xE009             B        ??Print_7
    775                              }
    776                              else if('%' == Token)
   \                     ??Print_6:
   \   0000003E   0x4668             MOV      R0,SP
   \   00000040   0x7900             LDRB     R0,[R0, #+4]
   \   00000042   0x2825             CMP      R0,#+37
   \   00000044   0xD103             BNE      ??Print_8
    777                              {
    778                                  pStr += 1;
   \   00000046   0x1C6D             ADDS     R5,R5,#+1
    779                                  FSM_Status = FSM_DISPATCH;
   \   00000048   0x2003             MOVS     R0,#+3
   \   0000004A   0x0007             MOVS     R7,R0
   \   0000004C   0xE001             B        ??Print_7
    780                              }
    781                              else
    782                              {
    783                                  FSM_Status = FSM_CHAR;
   \                     ??Print_8:
   \   0000004E   0x2002             MOVS     R0,#+2
   \   00000050   0x0007             MOVS     R7,R0
    784                              }
    785          
    786                              break;
   \                     ??Print_7:
   \   00000052   0xE7E2             B        ??Print_0
    787                          }
    788                      case FSM_CHAR:
    789                          {
    790                             (*pIoPutchar)(*pStr++);
   \                     ??Print_3:
   \   00000054   0x7828             LDRB     R0,[R5, #+0]
   \   00000056   0x9903             LDR      R1,[SP, #+12]
   \   00000058   0x4788             BLX      R1
   \   0000005A   0x1C6D             ADDS     R5,R5,#+1
    791                              NumOfChar++;
   \   0000005C   0x1C64             ADDS     R4,R4,#+1
    792                              FSM_Status = FSM_BEGIN;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x0007             MOVS     R7,R0
    793                              break;
   \   00000062   0xE7DA             B        ??Print_0
    794                          }
    795                      case FSM_DISPATCH:
    796                          {
    797                              Token = *pStr++;
   \                     ??Print_5:
   \   00000064   0x4668             MOV      R0,SP
   \   00000066   0x7829             LDRB     R1,[R5, #+0]
   \   00000068   0x7101             STRB     R1,[R0, #+4]
   \   0000006A   0x1C6D             ADDS     R5,R5,#+1
    798                              FSM_Status = FSM_BEGIN;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x0007             MOVS     R7,R0
    799                              switch(Token)
   \   00000070   0x4668             MOV      R0,SP
   \   00000072   0x7900             LDRB     R0,[R0, #+4]
   \   00000074   0x2858             CMP      R0,#+88
   \   00000076   0xD005             BEQ      ??Print_9
   \   00000078   0x2864             CMP      R0,#+100
   \   0000007A   0xD00F             BEQ      ??Print_10
   \   0000007C   0x2873             CMP      R0,#+115
   \   0000007E   0xD019             BEQ      ??Print_11
   \   00000080   0x2878             CMP      R0,#+120
   \   00000082   0xD123             BNE      ??Print_12
    800                              {
    801                                  case 'x':
    802                                  case 'X':
    803                                      {
    804                                          uint32 InputPara = 0;
   \                     ??Print_9:
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x9000             STR      R0,[SP, #+0]
    805                                          InputPara = va_arg(VarPara, uint32);
   \   00000088   0x6830             LDR      R0,[R6, #+0]
   \   0000008A   0x9000             STR      R0,[SP, #+0]
   \   0000008C   0x1D36             ADDS     R6,R6,#+4
    806                                          NumOfChar += PrintHex(pIoPutchar, (void *)InputPara);
   \   0000008E   0x9900             LDR      R1,[SP, #+0]
   \   00000090   0x9803             LDR      R0,[SP, #+12]
   \   00000092   0x.... 0x....      BL       PrintHex
   \   00000096   0x1820             ADDS     R0,R4,R0
   \   00000098   0x0004             MOVS     R4,R0
    807                                          break;
   \   0000009A   0xE01C             B        ??Print_13
    808                                      }
    809                                 case 'd':
    810                                      {
    811                                          uint32 InputPara = 0;
   \                     ??Print_10:
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0x9000             STR      R0,[SP, #+0]
    812                                          InputPara = va_arg(VarPara, uint32);
   \   000000A0   0x6830             LDR      R0,[R6, #+0]
   \   000000A2   0x9000             STR      R0,[SP, #+0]
   \   000000A4   0x1D36             ADDS     R6,R6,#+4
    813                                          NumOfChar += PrintDec(pIoPutchar, (void *)InputPara);
   \   000000A6   0x9900             LDR      R1,[SP, #+0]
   \   000000A8   0x9803             LDR      R0,[SP, #+12]
   \   000000AA   0x.... 0x....      BL       PrintDec
   \   000000AE   0x1820             ADDS     R0,R4,R0
   \   000000B0   0x0004             MOVS     R4,R0
    814                                          break;
   \   000000B2   0xE010             B        ??Print_13
    815                                      }
    816                                 case 's':
    817                                      {
    818                                          uint8  *InputPara = 0;
   \                     ??Print_11:
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0x9000             STR      R0,[SP, #+0]
    819                                          InputPara = va_arg(VarPara, uint8 *);
   \   000000B8   0x6830             LDR      R0,[R6, #+0]
   \   000000BA   0x9000             STR      R0,[SP, #+0]
   \   000000BC   0x1D36             ADDS     R6,R6,#+4
    820                                          NumOfChar += PrintStr(pIoPutchar, (void *)InputPara);
   \   000000BE   0x9900             LDR      R1,[SP, #+0]
   \   000000C0   0x9803             LDR      R0,[SP, #+12]
   \   000000C2   0x.... 0x....      BL       PrintStr
   \   000000C6   0x1820             ADDS     R0,R4,R0
   \   000000C8   0x0004             MOVS     R4,R0
    821                                          break;
   \   000000CA   0xE004             B        ??Print_13
    822                                      }
    823          
    824                                 //
    825                                 // If you want to add new function, add your code here
    826                                 // for example: you can add %p feature in ErrorPrint
    827                                 // for you can print the address of varilable
    828                                 //
    829                                 // case 'p':
    830                                 // {
    831                                 //     //your code is here
    832                                 //
    833                                 //     uint8  *InputPara = 0;
    834                                 //     InputPara = va_arg(pVar, uint8 *);
    835                                 //     NumOfChar += PrintPointer(pIoPutchar, (void *)InputPara);
    836                                 //     break;
    837                                 // }
    838                                 //
    839          
    840                                 default:
    841                                      {
    842                                          (*pIoPutchar)(Token);
   \                     ??Print_12:
   \   000000CC   0x4668             MOV      R0,SP
   \   000000CE   0x7900             LDRB     R0,[R0, #+4]
   \   000000D0   0x9903             LDR      R1,[SP, #+12]
   \   000000D2   0x4788             BLX      R1
    843                                          NumOfChar++;
   \   000000D4   0x1C64             ADDS     R4,R4,#+1
    844                                          break;
    845                                      }
    846                              }
    847                              break;
   \                     ??Print_13:
   \   000000D6   0xE7A0             B        ??Print_0
    848                          }
    849                      case FSM_END:
    850                          {
    851                              va_end(pVar);
    852                              return NumOfChar;
   \                     ??Print_4:
   \   000000D8   0x0020             MOVS     R0,R4
   \                     ??Print_1:
   \   000000DA   0xB005             ADD      SP,SP,#+20
   \   000000DC   0xBDF0             POP      {R4-R7,PC}       ;; return
    853                          }
    854                  }
    855          
    856              }
    857          }
    858          

   \                                 In section .text, align 2, keep-with-next
    859          static void BufWrite(char ch)
    860          {
   \                     BufWrite:
   \   00000000   0xB500             PUSH     {LR}
    861              if(ErrorBufIndex < TEST_ERROR_BUF_SIZE)
   \   00000002   0x....             LDR      R1,??DataTable11_1
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x2280             MOVS     R2,#+128
   \   00000008   0x0092             LSLS     R2,R2,#+2        ;; #+512
   \   0000000A   0x4291             CMP      R1,R2
   \   0000000C   0xD208             BCS      ??BufWrite_0
    862              {
    863                  g_pcErrorInfoBuffer[ErrorBufIndex++] = ch;
   \   0000000E   0x....             LDR      R1,??DataTable11_1
   \   00000010   0x6809             LDR      R1,[R1, #+0]
   \   00000012   0x....             LDR      R2,??DataTable11_2
   \   00000014   0x5450             STRB     R0,[R2, R1]
   \   00000016   0x....             LDR      R1,??DataTable11_1
   \   00000018   0x6809             LDR      R1,[R1, #+0]
   \   0000001A   0x1C49             ADDS     R1,R1,#+1
   \   0000001C   0x....             LDR      R2,??DataTable11_1
   \   0000001E   0x6011             STR      R1,[R2, #+0]
    864              }
    865          }
   \                     ??BufWrite_0:
   \   00000020   0xBD00             POP      {PC}             ;; return
    866          

   \                                 In section .text, align 2, keep-with-next
    867          uint32 FILE_Print(const char * pcMsg, ...)
    868          {
   \                     FILE_Print:
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xB578             PUSH     {R3-R6,LR}
   \   00000004   0x0005             MOVS     R5,R0
    869              uint32 count = 0;
   \   00000006   0x2400             MOVS     R4,#+0
    870              va_list InputVar;
    871              va_start(InputVar, pcMsg);
   \   00000008   0xA805             ADD      R0,SP,#+20
   \   0000000A   0x0006             MOVS     R6,R0
    872              count = Print(BufWrite, pcMsg, InputVar);
   \   0000000C   0x0032             MOVS     R2,R6
   \   0000000E   0x0029             MOVS     R1,R5
   \   00000010   0x....             LDR      R0,??DataTable11_3
   \   00000012   0x.... 0x....      BL       Print
   \   00000016   0x0004             MOVS     R4,R0
    873              va_end(InputVar);
    874              return count;
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0xB001             ADD      SP,SP,#+4
   \   0000001C   0x9903             LDR      R1,[SP, #+12]
   \   0000001E   0xBC70             POP      {R4-R6}
   \   00000020   0xB004             ADD      SP,SP,#+16
   \   00000022   0x4708             BX       R1               ;; return
    875          }
    876          

   \                                 In section .text, align 2, keep-with-next
    877          uint32 UART_Print(const char * pcMsg, ...)
    878          {
   \                     UART_Print:
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xB578             PUSH     {R3-R6,LR}
   \   00000004   0x0005             MOVS     R5,R0
    879              uint32 count = 0;
   \   00000006   0x2400             MOVS     R4,#+0
    880              va_list InputVar;
    881              va_start(InputVar, pcMsg);
   \   00000008   0xA805             ADD      R0,SP,#+20
   \   0000000A   0x0006             MOVS     R6,R0
    882              count = Print(TestIOPut, pcMsg, InputVar);
   \   0000000C   0x0032             MOVS     R2,R6
   \   0000000E   0x0029             MOVS     R1,R5
   \   00000010   0x....             LDR      R0,??DataTable11_4
   \   00000012   0x.... 0x....      BL       Print
   \   00000016   0x0004             MOVS     R4,R0
    883              va_end(InputVar);
    884              return count;
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0xB001             ADD      SP,SP,#+4
   \   0000001C   0x9903             LDR      R1,[SP, #+12]
   \   0000001E   0xBC70             POP      {R4-R6}
   \   00000020   0xB004             ADD      SP,SP,#+16
   \   00000022   0x4708             BX       R1               ;; return
    885          }
    886          

   \                                 In section .text, align 2, keep-with-next
    887          void _TestAssert(const char * pcMsg, ...)
    888          {
   \                     _TestAssert:
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xB530             PUSH     {R4,R5,LR}
   \   00000004   0x0004             MOVS     R4,R0
    889              va_list InputVar;
    890          
    891              ErrorBufIndex = 0;
   \   00000006   0x....             LDR      R0,??DataTable11_1
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    892              memset(g_pcErrorInfoBuffer, '\0', TEST_ERROR_BUF_SIZE);
   \   0000000C   0x2280             MOVS     R2,#+128
   \   0000000E   0x0092             LSLS     R2,R2,#+2        ;; #+512
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x....             LDR      R0,??DataTable11_2
   \   00000014   0x.... 0x....      BL       memset
    893              va_start(InputVar, pcMsg);
   \   00000018   0xA803             ADD      R0,SP,#+12
   \   0000001A   0x0005             MOVS     R5,R0
    894              Print(BufWrite, pcMsg, InputVar);
   \   0000001C   0x002A             MOVS     R2,R5
   \   0000001E   0x0021             MOVS     R1,R4
   \   00000020   0x....             LDR      R0,??DataTable11_3
   \   00000022   0x.... 0x....      BL       Print
    895              va_end(InputVar);
    896              _TestFail();
   \   00000026   0x.... 0x....      BL       _TestFail
    897          }
   \   0000002A   0x9802             LDR      R0,[SP, #+8]
   \   0000002C   0xBC30             POP      {R4,R5}
   \   0000002E   0xB004             ADD      SP,SP,#+16
   \   00000030   0x4700             BX       R0               ;; return
    898          
    899          //*****************************************************************************
    900          //
    901          //! \brief Test execution thread function.
    902          //!
    903          //! \param None
    904          //!
    905          //! \details Test execution thread function.
    906          //!
    907          //! \return The test result xtrue or xfalse.
    908          //
    909          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
    910          xtBoolean TestMain(void)
    911          {
   \                     TestMain:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    912              uint32 i = 0;
   \   00000002   0x2500             MOVS     R5,#+0
    913              uint32 j = 0;
   \   00000004   0x2400             MOVS     R4,#+0
    914          
    915              TestIOInit();
   \   00000006   0x.... 0x....      BL       TestIOInit
    916          
    917              UART_Print("\r\n*** CooCox CoIDE components test suites\r\n");
   \   0000000A   0x....             LDR      R0,??DataTable11_5
   \   0000000C   0x.... 0x....      BL       UART_Print
    918          #ifdef TEST_COMPONENTS_NAME
    919              UART_Print("*** Components: %s\r\n", TEST_COMPONENTS_NAME);
   \   00000010   0x....             LDR      R1,??DataTable11_6
   \   00000012   0x....             LDR      R0,??DataTable11_7
   \   00000014   0x.... 0x....      BL       UART_Print
    920          #endif
    921          #ifdef TEST_COMPONENTS_VERSION
    922              UART_Print("*** Version   : %s\r\n", TEST_COMPONENTS_VERSION);
   \   00000018   0x....             LDR      R1,??DataTable11_8
   \   0000001A   0x....             LDR      R0,??DataTable11_9
   \   0000001C   0x.... 0x....      BL       UART_Print
    923          #endif
    924          #ifdef TEST_BOARD_NAME
    925              UART_Print("*** Test Board: %s\r\n", TEST_BOARD_NAME);
   \   00000020   0x....             LDR      R1,??DataTable11_10
   \   00000022   0x....             LDR      R0,??DataTable11_11
   \   00000024   0x.... 0x....      BL       UART_Print
    926          #endif
    927              g_bGlobalFail = xfalse;
   \   00000028   0x....             LDR      R0,??DataTable11_12
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x7001             STRB     R1,[R0, #+0]
    928          
    929              i = 0;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x0005             MOVS     R5,R0
    930              while (g_psPatterns[i])
   \                     ??TestMain_0:
   \   00000032   0x2004             MOVS     R0,#+4
   \   00000034   0x4368             MULS     R0,R5,R0
   \   00000036   0x....             LDR      R1,??DataTable11_13
   \   00000038   0x5808             LDR      R0,[R1, R0]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD041             BEQ      ??TestMain_1
    931              {
    932                  j = 0;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x0004             MOVS     R4,R0
    933                  while (g_psPatterns[i][j])
   \                     ??TestMain_2:
   \   00000042   0x2004             MOVS     R0,#+4
   \   00000044   0x4360             MULS     R0,R4,R0
   \   00000046   0x2104             MOVS     R1,#+4
   \   00000048   0x4369             MULS     R1,R5,R1
   \   0000004A   0x....             LDR      R2,??DataTable11_13
   \   0000004C   0x5851             LDR      R1,[R2, R1]
   \   0000004E   0x5808             LDR      R0,[R1, R0]
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD034             BEQ      ??TestMain_3
    934                  {
    935                      UART_Print("%s\r\n--- Test Case %d.%d", NEW_LINE, i+1, j+1);
   \   00000054   0x0023             MOVS     R3,R4
   \   00000056   0x1C5B             ADDS     R3,R3,#+1
   \   00000058   0x002A             MOVS     R2,R5
   \   0000005A   0x1C52             ADDS     R2,R2,#+1
   \   0000005C   0x....             LDR      R1,??DataTable11_14
   \   0000005E   0x....             LDR      R0,??DataTable11_15
   \   00000060   0x.... 0x....      BL       UART_Print
    936                      UART_Print("(%s)\r\n", g_psPatterns[i][j]->GetTest());
   \   00000064   0x2004             MOVS     R0,#+4
   \   00000066   0x4360             MULS     R0,R4,R0
   \   00000068   0x2104             MOVS     R1,#+4
   \   0000006A   0x4369             MULS     R1,R5,R1
   \   0000006C   0x....             LDR      R2,??DataTable11_13
   \   0000006E   0x5851             LDR      R1,[R2, R1]
   \   00000070   0x5808             LDR      R0,[R1, R0]
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x4780             BLX      R0
   \   00000076   0x0001             MOVS     R1,R0
   \   00000078   0x....             LDR      R0,??DataTable11_16
   \   0000007A   0x.... 0x....      BL       UART_Print
    937          
    938                      ExecuteTest(g_psPatterns[i][j]);
   \   0000007E   0x2004             MOVS     R0,#+4
   \   00000080   0x4360             MULS     R0,R4,R0
   \   00000082   0x2104             MOVS     R1,#+4
   \   00000084   0x4369             MULS     R1,R5,R1
   \   00000086   0x....             LDR      R2,??DataTable11_13
   \   00000088   0x5851             LDR      R1,[R2, R1]
   \   0000008A   0x5808             LDR      R0,[R1, R0]
   \   0000008C   0x.... 0x....      BL       ExecuteTest
    939                      if (g_bLocalFail == xtrue)
   \   00000090   0x....             LDR      R0,??DataTable11_17
   \   00000092   0x7800             LDRB     R0,[R0, #+0]
   \   00000094   0x2801             CMP      R0,#+1
   \   00000096   0xD10D             BNE      ??TestMain_4
    940                      {
    941          
    942                          UART_Print("--- Result: FAILURE \r\n%s\r\n", g_pcErrorInfoBuffer);
   \   00000098   0x....             LDR      R1,??DataTable11_2
   \   0000009A   0x....             LDR      R0,??DataTable11_18
   \   0000009C   0x.... 0x....      BL       UART_Print
    943          
    944                          if (g_pcTokensBuffer < g_pcTok)
   \   000000A0   0x....             LDR      R0,??DataTable11_19
   \   000000A2   0x....             LDR      R1,??DataTable11_20
   \   000000A4   0x6809             LDR      R1,[R1, #+0]
   \   000000A6   0x4288             CMP      R0,R1
   \   000000A8   0xD207             BCS      ??TestMain_5
    945                          {
    946                              UART_Print(" The tokens in buffer is: %s\r\n", g_pcTokensBuffer);
   \   000000AA   0x....             LDR      R1,??DataTable11_19
   \   000000AC   0x....             LDR      R0,??DataTable11_21
   \   000000AE   0x.... 0x....      BL       UART_Print
   \   000000B2   0xE002             B        ??TestMain_5
    947                          }
    948                      }
    949                      else
    950                      {
    951                          UART_Print("--- Result: SUCCESS \r\n");
   \                     ??TestMain_4:
   \   000000B4   0x....             LDR      R0,??DataTable11_22
   \   000000B6   0x.... 0x....      BL       UART_Print
    952                      }
    953                      j++;
   \                     ??TestMain_5:
   \   000000BA   0x1C64             ADDS     R4,R4,#+1
   \   000000BC   0xE7C1             B        ??TestMain_2
    954                  }
    955                  i++;
   \                     ??TestMain_3:
   \   000000BE   0x1C6D             ADDS     R5,R5,#+1
   \   000000C0   0xE7B7             B        ??TestMain_0
    956              }
    957          
    958              if (g_bGlobalFail == xtrue)
   \                     ??TestMain_1:
   \   000000C2   0x....             LDR      R0,??DataTable11_12
   \   000000C4   0x7800             LDRB     R0,[R0, #+0]
   \   000000C6   0x2801             CMP      R0,#+1
   \   000000C8   0xD104             BNE      ??TestMain_6
    959              {
    960                  UART_Print("%s\r\nFinal result: FAILURE\r\n", NEW_LINE);
   \   000000CA   0x....             LDR      R1,??DataTable11_14
   \   000000CC   0x....             LDR      R0,??DataTable11_23
   \   000000CE   0x.... 0x....      BL       UART_Print
   \   000000D2   0xE003             B        ??TestMain_7
    961              }
    962              else
    963              {
    964                  UART_Print("%s\r\nFinal result: SUCCESS\r\n", NEW_LINE);
   \                     ??TestMain_6:
   \   000000D4   0x....             LDR      R1,??DataTable11_14
   \   000000D6   0x....             LDR      R0,??DataTable11_24
   \   000000D8   0x.... 0x....      BL       UART_Print
    965              }
    966          
    967              return g_bGlobalFail;
   \                     ??TestMain_7:
   \   000000DC   0x....             LDR      R0,??DataTable11_12
   \   000000DE   0x7800             LDRB     R0,[R0, #+0]
   \   000000E0   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    968          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     g_pcTok

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     g_pcTokensBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x........         DC32     g_bLocalFail

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x........         DC32     g_bGlobalFail

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     `?<Constant "0123456789ABCDEF">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x........         DC32     `?<Constant {48, 88}>`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x........         DC32     ErrorBufIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x........         DC32     g_pcErrorInfoBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x........         DC32     BufWrite

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   0x........         DC32     TestIOPut

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   0x........         DC32     `?<Constant "\\r\\n*** CooCox CoIDE co...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \   00000000   0x........         DC32     `?<Constant "KLxx COX Packet">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \   00000000   0x........         DC32     `?<Constant "*** Components: %s\\r\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \   00000000   0x........         DC32     `?<Constant "V1.0.0">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_9:
   \   00000000   0x........         DC32     `?<Constant "*** Version   : %s\\r\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_10:
   \   00000000   0x........         DC32     `?<Constant "KLxx board">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_11:
   \   00000000   0x........         DC32     `?<Constant "*** Test Board: %s\\r\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_12:
   \   00000000   0x........         DC32     g_bGlobalFail

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_13:
   \   00000000   0x........         DC32     g_psPatterns

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_14:
   \   00000000   0x........         DC32     `?<Constant "---------------------...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_15:
   \   00000000   0x........         DC32     `?<Constant "%s\\r\\n--- Test Case %d.%d">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_16:
   \   00000000   0x........         DC32     `?<Constant "(%s)\\r\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_17:
   \   00000000   0x........         DC32     g_bLocalFail

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_18:
   \   00000000   0x........         DC32     `?<Constant "--- Result: FAILURE \\r...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_19:
   \   00000000   0x........         DC32     g_pcTokensBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_20:
   \   00000000   0x........         DC32     g_pcTok

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_21:
   \   00000000   0x........         DC32     `?<Constant " The tokens in buffer...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_22:
   \   00000000   0x........         DC32     `?<Constant "--- Result: SUCCESS \\r\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_23:
   \   00000000   0x........         DC32     `?<Constant "%s\\r\\nFinal result: FAI...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_24:
   \   00000000   0x........         DC32     `?<Constant "%s\\r\\nFinal result: SUC...">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "0123456789ABCDEF">`:
   \   00000000   0x30 0x31          DC8 "0123456789ABCDEF"
   \              0x32 0x33    
   \              0x34 0x35    
   \              0x36 0x37    
   \              0x38 0x39    
   \              0x41 0x42    
   \              0x43 0x44    
   \              0x45 0x46    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant {48, 88}>`:
   \   00000000   0x30 0x58          DC8 48, 88, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\r\\n*** CooCox CoIDE co...">`:
   \   00000000   0x0D 0x0A          DC8 "\015\012*** CooCox CoIDE components test suites\015\012"
   \              0x2A 0x2A    
   \              0x2A 0x20    
   \              0x43 0x6F    
   \              0x6F 0x43    
   \              0x6F 0x78    
   \              0x20 0x43    
   \              0x6F 0x49    
   \              0x44 0x45    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x70 0x6F    
   \              0x6E 0x65    
   \              0x6E 0x74    
   \              0x73 0x20    
   \              0x74 0x65    
   \              0x73 0x74    
   \              0x20 0x73    
   \              0x75 0x69    
   \              0x74 0x65    
   \              0x73 0x0D    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "*** Components: %s\\r\\n">`:
   \   00000000   0x2A 0x2A          DC8 "*** Components: %s\015\012"
   \              0x2A 0x20    
   \              0x43 0x6F    
   \              0x6D 0x70    
   \              0x6F 0x6E    
   \              0x65 0x6E    
   \              0x74 0x73    
   \              0x3A 0x20    
   \              0x25 0x73    
   \              0x0D 0x0A    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "KLxx COX Packet">`:
   \   00000000   0x4B 0x4C          DC8 "KLxx COX Packet"
   \              0x78 0x78    
   \              0x20 0x43    
   \              0x4F 0x58    
   \              0x20 0x50    
   \              0x61 0x63    
   \              0x6B 0x65    
   \              0x74 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "*** Version   : %s\\r\\n">`:
   \   00000000   0x2A 0x2A          DC8 "*** Version   : %s\015\012"
   \              0x2A 0x20    
   \              0x56 0x65    
   \              0x72 0x73    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x20 0x20    
   \              0x3A 0x20    
   \              0x25 0x73    
   \              0x0D 0x0A    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "V1.0.0">`:
   \   00000000   0x56 0x31          DC8 "V1.0.0"
   \              0x2E 0x30    
   \              0x2E 0x30    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "*** Test Board: %s\\r\\n">`:
   \   00000000   0x2A 0x2A          DC8 "*** Test Board: %s\015\012"
   \              0x2A 0x20    
   \              0x54 0x65    
   \              0x73 0x74    
   \              0x20 0x42    
   \              0x6F 0x61    
   \              0x72 0x64    
   \              0x3A 0x20    
   \              0x25 0x73    
   \              0x0D 0x0A    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "KLxx board">`:
   \   00000000   0x4B 0x4C          DC8 "KLxx board"
   \              0x78 0x78    
   \              0x20 0x62    
   \              0x6F 0x61    
   \              0x72 0x64    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "%s\\r\\n--- Test Case %d.%d">`:
   \   00000000   0x25 0x73          DC8 "%s\015\012--- Test Case %d.%d"
   \              0x0D 0x0A    
   \              0x2D 0x2D    
   \              0x2D 0x20    
   \              0x54 0x65    
   \              0x73 0x74    
   \              0x20 0x43    
   \              0x61 0x73    
   \              0x65 0x20    
   \              0x25 0x64    
   \              0x2E 0x25    
   \              0x64 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "---------------------...">`:
   \   00000000   0x2D 0x2D          DC8 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \   00000008   0x2D 0x2D          DC8 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \   00000010   0x2D 0x2D          DC8 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \   00000018   0x2D 0x2D          DC8 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \   00000020   0x2D 0x2D          DC8 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \   00000028   0x2D 0x2D          DC8 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \   00000030   0x2D 0x2D          DC8 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \   00000038   0x2D 0x2D          DC8 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \   00000040   0x2D 0x2D          DC8 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 2DH
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \   00000048   0x2D 0x2D          DC8 2DH, 2DH, 2DH, 2DH, 2DH, 2DH, 0
   \              0x2D 0x2D    
   \              0x2D 0x2D    
   \              0x00         
   \   0000004F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "(%s)\\r\\n">`:
   \   00000000   0x28 0x25          DC8 "(%s)\015\012"
   \              0x73 0x29    
   \              0x0D 0x0A    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "--- Result: FAILURE \\r...">`:
   \   00000000   0x2D 0x2D          DC8 "--- Result: FAILURE \015\012%s\015\012"
   \              0x2D 0x20    
   \              0x52 0x65    
   \              0x73 0x75    
   \              0x6C 0x74    
   \              0x3A 0x20    
   \              0x46 0x41    
   \              0x49 0x4C    
   \              0x55 0x52    
   \              0x45 0x20    
   \              0x0D 0x0A    
   \              0x25 0x73    
   \              0x0D 0x0A    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant " The tokens in buffer...">`:
   \   00000000   0x20 0x54          DC8 " The tokens in buffer is: %s\015\012"
   \              0x68 0x65    
   \              0x20 0x74    
   \              0x6F 0x6B    
   \              0x65 0x6E    
   \              0x73 0x20    
   \              0x69 0x6E    
   \              0x20 0x62    
   \              0x75 0x66    
   \              0x66 0x65    
   \              0x72 0x20    
   \              0x69 0x73    
   \              0x3A 0x20    
   \              0x25 0x73    
   \              0x0D 0x0A    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "--- Result: SUCCESS \\r\\n">`:
   \   00000000   0x2D 0x2D          DC8 "--- Result: SUCCESS \015\012"
   \              0x2D 0x20    
   \              0x52 0x65    
   \              0x73 0x75    
   \              0x6C 0x74    
   \              0x3A 0x20    
   \              0x53 0x55    
   \              0x43 0x43    
   \              0x45 0x53    
   \              0x53 0x20    
   \              0x0D 0x0A    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "%s\\r\\nFinal result: FAI...">`:
   \   00000000   0x25 0x73          DC8 "%s\015\012Final result: FAILURE\015\012"
   \              0x0D 0x0A    
   \              0x46 0x69    
   \              0x6E 0x61    
   \              0x6C 0x20    
   \              0x72 0x65    
   \              0x73 0x75    
   \              0x6C 0x74    
   \              0x3A 0x20    
   \              0x46 0x41    
   \              0x49 0x4C    
   \              0x55 0x52    
   \              0x45 0x0D    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "%s\\r\\nFinal result: SUC...">`:
   \   00000000   0x25 0x73          DC8 "%s\015\012Final result: SUCCESS\015\012"
   \              0x0D 0x0A    
   \              0x46 0x69    
   \              0x6E 0x61    
   \              0x6C 0x20    
   \              0x72 0x65    
   \              0x73 0x75    
   \              0x6C 0x74    
   \              0x3A 0x20    
   \              0x53 0x55    
   \              0x43 0x43    
   \              0x45 0x53    
   \              0x53 0x0D    
   \              0x0A 0x00    
    969          
    970          #endif
    971          
    972          
    973          
    974          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        4  BufWrite
        0  ClearTokens
        8  ExecuteTest
              8 -- Indirect call
              8 -> ClearTokens
       32  FILE_Print
             32 -> Print
       36  NumToStr
             36 -> __aeabi_uidiv
             36 -> __aeabi_uidivmod
       40  Print
             40 -- Indirect call
             40 -> PrintDec
             40 -> PrintHex
             40 -> PrintStr
       40  PrintDec
             40 -- Indirect call
             40 -> NumToStr
             40 -> __aeabi_memclr4
       40  PrintHex
             40 -- Indirect call
             40 -> NumToStr
             40 -> __aeabi_memcpy4
       24  PrintStr
             24 -- Indirect call
        8  TestEmitToken
              8 -> TestDisableIRQ
              8 -> TestEnableIRQ
       16  TestMain
             16 -- Indirect call
             16 -> ExecuteTest
             16 -> TestIOInit
             16 -> UART_Print
       32  UART_Print
             32 -> Print
       24  _TestAssert
             24 -> Print
             24 -> _TestFail
             24 -> memset
       24  _TestAssertSequenceBreak
             24 -> ClearTokens
             24 -> SysCtlDelay
             24 -> _TestFail
        0  _TestFail
       16  memset
             16 -> __aeabi_memset


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      32  ?<Constant " The tokens in buffer...">
      24  ?<Constant "%s\r\n--- Test Case %d.%d">
      28  ?<Constant "%s\r\nFinal result: FAI...">
      28  ?<Constant "%s\r\nFinal result: SUC...">
       8  ?<Constant "(%s)\r\n">
      24  ?<Constant "*** Components: %s\r\n">
      24  ?<Constant "*** Test Board: %s\r\n">
      24  ?<Constant "*** Version   : %s\r\n">
      28  ?<Constant "--- Result: FAILURE \r...">
      24  ?<Constant "--- Result: SUCCESS \r\n">
      80  ?<Constant "---------------------...">
      20  ?<Constant "0123456789ABCDEF">
      16  ?<Constant "KLxx COX Packet">
      12  ?<Constant "KLxx board">
       8  ?<Constant "V1.0.0">
      44  ?<Constant "\r\n*** CooCox CoIDE co...">
      16  ?<Constant {0}>
      16  ?<Constant {48, 88}>
       4  ??DataTable10
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_11
       4  ??DataTable11_12
       4  ??DataTable11_13
       4  ??DataTable11_14
       4  ??DataTable11_15
       4  ??DataTable11_16
       4  ??DataTable11_17
       4  ??DataTable11_18
       4  ??DataTable11_19
       4  ??DataTable11_2
       4  ??DataTable11_20
       4  ??DataTable11_21
       4  ??DataTable11_22
       4  ??DataTable11_23
       4  ??DataTable11_24
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
      34  BufWrite
       8  ClearTokens
       4  ErrorBufIndex
      40  ExecuteTest
      36  FILE_Print
     136  NumToStr
     222  Print
      98  PrintDec
     102  PrintHex
      40  PrintStr
      42  TestEmitToken
     226  TestMain
      36  UART_Print
      50  _TestAssert
      94  _TestAssertSequenceBreak
      16  _TestFail
       1  g_bGlobalFail
       1  g_bLocalFail
     512  g_pcErrorInfoBuffer
       4  g_pcTok
      12  g_pcTokensBuffer
      22  memset

 
   534 bytes in section .bss
   456 bytes in section .rodata
 1 322 bytes in section .text
 
 1 300 bytes of CODE  memory (+ 22 bytes shared)
   456 bytes of CONST memory
   534 bytes of DATA  memory

Errors: none
Warnings: none
