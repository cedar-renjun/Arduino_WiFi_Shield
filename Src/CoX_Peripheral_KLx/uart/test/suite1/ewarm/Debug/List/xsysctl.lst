###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.1.53790/W32 for ARM     24/Feb/2013  09:52:15 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\renjun\Desktop\Cox\CoX_Peripheral\CoX_Periphera #
#                    l_KLx\libcox\xsysctl.c                                   #
#    Command line =  C:\Users\renjun\Desktop\Cox\CoX_Peripheral\CoX_Periphera #
#                    l_KLx\libcox\xsysctl.c -D ewarm -lCN                     #
#                    C:\Users\renjun\Desktop\Cox\CoX_Peripheral\CoX_Periphera #
#                    l_KLx\uart\test\suite1\ewarm\Debug\List\ -lB             #
#                    C:\Users\renjun\Desktop\Cox\CoX_Peripheral\CoX_Periphera #
#                    l_KLx\uart\test\suite1\ewarm\Debug\List\ -o              #
#                    C:\Users\renjun\Desktop\Cox\CoX_Peripheral\CoX_Periphera #
#                    l_KLx\uart\test\suite1\ewarm\Debug\Obj\ --no_cse         #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M0+ -e --fpu=None --dlib_config             #
#                    "C:\Program Files\IAR Systems\Embedded Workbench         #
#                    6.4\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\Users\renjun\Desktop\Cox\CoX_Peripheral\CoX_Periphera #
#                    l_KLx\uart\test\suite1\ewarm\..\..\..\..\libcox\ -I      #
#                    C:\Users\renjun\Desktop\Cox\CoX_Peripheral\CoX_Periphera #
#                    l_KLx\uart\test\suite1\ewarm\..\..\..\..\testframe\ -I   #
#                    C:\Users\renjun\Desktop\Cox\CoX_Peripheral\CoX_Periphera #
#                    l_KLx\uart\test\suite1\ewarm\..\..\..\..\uart\test\suite #
#                    1\src\ -On                                               #
#    List file    =  C:\Users\renjun\Desktop\Cox\CoX_Peripheral\CoX_Periphera #
#                    l_KLx\uart\test\suite1\ewarm\Debug\List\xsysctl.lst      #
#    Object file  =  C:\Users\renjun\Desktop\Cox\CoX_Peripheral\CoX_Periphera #
#                    l_KLx\uart\test\suite1\ewarm\Debug\Obj\xsysctl.o         #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\renjun\Desktop\Cox\CoX_Peripheral\CoX_Peripheral_KLx\libcox\xsysctl.c
      1          //*****************************************************************************
      2          //
      3          //! \file xsysctl.c
      4          //! \brief Driver for the system controller
      5          //! \version V2.2.1.0
      6          //! \date 8/7/2012
      7          //! \author CooCox
      8          //! \copy
      9          //!
     10          //! Copyright (c)  2011, CooCox 
     11          //! All rights reserved.
     12          //! 
     13          //! Redistribution and use in source and binary forms, with or without 
     14          //! modification, are permitted provided that the following conditions 
     15          //! are met: 
     16          //! 
     17          //!     * Redistributions of source code must retain the above copyright 
     18          //! notice, this list of conditions and the following disclaimer. 
     19          //!     * Redistributions in binary form must reproduce the above copyright
     20          //! notice, this list of conditions and the following disclaimer in the
     21          //! documentation and/or other materials provided with the distribution. 
     22          //!     * Neither the name of the <ORGANIZATION> nor the names of its 
     23          //! contributors may be used to endorse or promote products derived 
     24          //! from this software without specific prior written permission. 
     25          //! 
     26          //! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     27          //! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
     28          //! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     29          //! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
     30          //! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
     31          //! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
     32          //! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     33          //! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
     34          //! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
     35          //! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
     36          //! THE POSSIBILITY OF SUCH DAMAGE.
     37          //
     38          //*****************************************************************************
     39          #include "xhw_types.h"
     40          #include "xhw_ints.h"
     41          #include "xhw_memmap.h"
     42          #include "xhw_nvic.h"
     43          #include "xhw_sysctl.h"
     44          #include "xhw_gpio.h"
     45          #include "xhw_adc.h"
     46          #include "xdebug.h"
     47          #include "xsysctl.h"
     48          #include "xcore.h"
     49          
     50          
     51          

   \                                 In section .data, align 4
     52          static unsigned long s_ulExtClockMHz = 8;
   \                     s_ulExtClockMHz:
   \   00000000   0x00000008         DC32 8
     53          
     54          //*****************************************************************************
     55          //
     56          // This macro extracts the array index out of the peripheral number for enable.
     57          //
     58          //*****************************************************************************
     59          #define SYSCTL_PERIPH_INDEX_E(a)(((a) >> 14) & 0x3)
     60          
     61          //*****************************************************************************
     62          //
     63          // This macro constructs the peripheral bit mask from the peripheral number for 
     64          // enable.
     65          //
     66          //*****************************************************************************
     67          #define SYSCTL_PERIPH_MASK_E(a) (((a) & 0xff) << (((a) & 0x1f00) >> 8))
     68          
     69          //*****************************************************************************
     70          //
     71          // An array that maps the "peripheral set" number (which is stored in the upper
     72          // nibble of the SYSCTL_PERIPH_* defines) to the SYSCLK_AHBCLK register that
     73          // controls the run-mode enable for that peripheral.
     74          //
     75          //*****************************************************************************

   \                                 In section .rodata, align 4
     76          static const unsigned long g_pulAXBCLKRegs[] =
   \                     g_pulAXBCLKRegs:
   \   00000000   0x40048034         DC32 1074036788, 1074036792, 1074036796, 1074036800
   \              0x40048038   
   \              0x4004803C   
   \              0x40048040   
     77          {
     78              SIM_SCGC4,
     79              SIM_SCGC5,
     80              SIM_SCGC6,
     81              SIM_SCGC7
     82          };
     83          
     84          //*****************************************************************************
     85          //
     86          //! Peripheral Base and ID Table structure type
     87          //
     88          //*****************************************************************************
     89          typedef struct 
     90          {
     91              unsigned long ulPeripheralBase;
     92              unsigned long ulPeripheralID;
     93              unsigned long ulPeripheralIntNum;
     94          }
     95          tPeripheralTable;
     96          
     97          //*****************************************************************************
     98          //
     99          // An array that maps the peripheral base and peripheral ID and interrupt number
    100          // together to enablea peripheral or peripheral interrupt by a peripheral base.
    101          //
    102          //*****************************************************************************

   \                                 In section .rodata, align 4
    103          static const tPeripheralTable g_pPeripherals[] =
   \                     g_pPeripherals:
   \   00000000   0x400FF000         DC32 1074786304, 18434, 46, 1074786496, 18448, 47, 1074176000, 2561, 28
   \              0x00004802   
   \              0x0000002E   
   \              0x400FF0C0   
   \              0x00004810   
   \              0x0000002F   
   \              0x4006A000   
   \              0x00000A01   
   \              0x0000001C   
   \   00000024   0x4006B000         DC32 1074180096, 2562, 29, 1074184192, 2564, 30, 1073971200, 37248, 33
   \              0x00000A02   
   \              0x0000001D   
   \              0x4006C000   
   \              0x00000A04   
   \              0x0000001E   
   \              0x40038000   
   \              0x00009180   
   \              0x00000021   
   \   00000048   0x40039000         DC32 1073975296, 37504, 34, 1073979392, 37760, 35, 1074225152, 5633, 26
   \              0x00009280   
   \              0x00000022   
   \              0x4003A000   
   \              0x00009380   
   \              0x00000023   
   \              0x40076000   
   \              0x00001601   
   \              0x0000001A   
   \   0000006C   0x40077000         DC32 1074229248, 5634, 27, 1074159616, 64, 24, 1074163712, 128, 25
   \              0x00001602   
   \              0x0000001B   
   \              0x40066000   
   \              0x00000040   
   \              0x00000018   
   \              0x40067000   
   \              0x00000080   
   \              0x00000019   
   \   00000090   0x4003B000         DC32 1073983488, 38016, 31, 1074212864, 3856, 32, 1073971200, 37248, 33
   \              0x00009480   
   \              0x0000001F   
   \              0x40073000   
   \              0x00000F10   
   \              0x00000020   
   \              0x40038000   
   \              0x00009180   
   \              0x00000021   
   \   000000B4   0x40039000         DC32 1073975296, 37504, 34, 1073979392, 37760, 35, 0, 0, 0
   \              0x00009280   
   \              0x00000022   
   \              0x4003A000   
   \              0x00009380   
   \              0x00000023   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
    104          {
    105              {xGPIO_PORTA_BASE, xSYSCTL_PERIPH_GPIOA, INT_PORTA},
    106              {xGPIO_PORTD_BASE, xSYSCTL_PERIPH_GPIOD, INT_PORTD},
    107              {xUART0_BASE,      xSYSCTL_PERIPH_UART0, INT_UART0SE},
    108              {xUART1_BASE,      xSYSCTL_PERIPH_UART1, INT_UART1SE},
    109              {xUART2_BASE,      xSYSCTL_PERIPH_UART2, INT_UART2SE},
    110              {xTIMER0_BASE,     xSYSCTL_PERIPH_TIMER0, INT_FTM0},
    111              {xTIMER1_BASE,     xSYSCTL_PERIPH_TIMER1, INT_FTM1},
    112              {xTIMER2_BASE,     xSYSCTL_PERIPH_TIMER2, INT_FTM2},
    113              {xSPI0_BASE,       xSYSCTL_PERIPH_SPI0, INT_SPI0},
    114              {xSPI1_BASE,       xSYSCTL_PERIPH_SPI1, INT_SPI1},
    115              {xI2C0_BASE,       xSYSCTL_PERIPH_I2C0, INT_I2C0},
    116              {xI2C1_BASE,       xSYSCTL_PERIPH_I2C1, INT_I2C1},
    117              {xADC0_BASE,       xSYSCTL_PERIPH_ADC0, INT_ADC},
    118              {xACMP0_BASE,      xSYSCTL_PERIPH_ACMP0, INT_ACMP},
    119              {xPWMA_BASE,       xSYSCTL_PERIPH_PWMA, xINT_PWMA},
    120              {xPWMB_BASE,       xSYSCTL_PERIPH_PWMB, xINT_PWMB},
    121              {xPWMC_BASE,       xSYSCTL_PERIPH_PWMC, xINT_PWMC},
    122              {0,                0,                   0},
    123          };
    124              
    125                                          
    126          //*****************************************************************************
    127          //
    128          //! \brief Provides a small delay.
    129          //!
    130          //! \param ulCount is the number of delay loop iterations to perform.
    131          //!
    132          //! This function provides a means of generating a constant length delay.  It
    133          //! is written in assembly to keep the delay consistent across tool chains,
    134          //! avoiding the need to tune the delay based on the tool chain in use.
    135          //!
    136          //! The loop takes 3 cycles/loop.
    137          //!
    138          //! \return None.
    139          //
    140          //*****************************************************************************
    141          #if defined(gcc) || defined(__GNUC__)
    142          void __attribute__((naked))
    143          SysCtlDelay(unsigned long ulCount)
    144          {
    145              __asm("    sub     r0, #1\n"
    146                    "    bne     SysCtlDelay\n"
    147                    "    bx      lr");
    148          }
    149          #endif
    150          #if defined(ewarm) || defined(__ICCARM__)

   \                                 In section .text, align 4, keep-with-next
    151          void
    152          SysCtlDelay(unsigned long ulCount)
    153          {
    154              __asm("    subs    r0, #1\n"
    155                    "    bne.n   SysCtlDelay\n"
    156                    "    bx      lr");
   \                     SysCtlDelay:
   \   00000000   0x3801             subs    r0, #1
   \   00000002   0xD1FD             bne.n   SysCtlDelay
   \   00000004   0x4770             bx      lr
    157          }
   \   00000006   0x4770             BX       LR               ;; return
    158          #endif
    159          #if defined(rvmdk) || defined(__CC_ARM)
    160          __asm void
    161          SysCtlDelay(unsigned long ulCount)
    162          {
    163              subs    r0, #1;
    164              bne     SysCtlDelay;
    165              bx      lr;
    166          }
    167          #endif
    168          
    169          //*****************************************************************************
    170          //
    171          //! \internal
    172          //! \brief Checks a peripheral identifier.
    173          //!
    174          //! \param ulPeripheral is the peripheral identifier.
    175          //!
    176          //! This function determines if a peripheral identifier is valid.
    177          //!
    178          //! \return Returns \b true if the peripheral identifier is valid and \b false
    179          //! otherwise.
    180          //
    181          //*****************************************************************************
    182          #ifdef xDEBUG
    183          static xtBoolean
    184          SysCtlPeripheralValid(unsigned long ulPeripheral)
    185          {
    186              return((ulPeripheral == SYSCTL_PERIPH_DMA) ||
    187                     (ulPeripheral == SYSCTL_PERIPH_RTC) ||
    188                     (ulPeripheral == SYSCTL_PERIPH_TSI) ||
    189                     (ulPeripheral == SYSCTL_PERIPH_ADC) ||
    190                     (ulPeripheral == SYSCTL_PERIPH_PIT) ||
    191                     (ulPeripheral == SYSCTL_PERIPH_TMR0) ||
    192                     (ulPeripheral == SYSCTL_PERIPH_TMR1) ||
    193                     (ulPeripheral == SYSCTL_PERIPH_TMR2) ||
    194                     (ulPeripheral == SYSCTL_PERIPH_I2C0) ||
    195                     (ulPeripheral == SYSCTL_PERIPH_I2C1) ||
    196                     (ulPeripheral == SYSCTL_PERIPH_SPI0) ||
    197                     (ulPeripheral == SYSCTL_PERIPH_SPI1) ||
    198                     (ulPeripheral == SYSCTL_PERIPH_DAC)  ||
    199                     (ulPeripheral == SYSCTL_PERIPH_PWMA) ||
    200                     (ulPeripheral == SYSCTL_PERIPH_PWMB) ||
    201                     (ulPeripheral == SYSCTL_PERIPH_PWMC) ||
    202                     (ulPeripheral == SYSCTL_PERIPH_USB)  ||
    203                     (ulPeripheral == SYSCTL_PERIPH_ACMP) ||
    204                     (ulPeripheral == SYSCTL_PERIPH_UART0) ||
    205                     (ulPeripheral == SYSCTL_PERIPH_UART1) ||
    206                     (ulPeripheral == SYSCTL_PERIPH_UART2) ||
    207                     (ulPeripheral == SYSCTL_PERIPH_GPIOA) ||
    208                     (ulPeripheral == SYSCTL_PERIPH_GPIOB) ||
    209                     (ulPeripheral == SYSCTL_PERIPH_GPIOC) ||
    210                     (ulPeripheral == SYSCTL_PERIPH_GPIOD) ||
    211                     (ulPeripheral == SYSCTL_PERIPH_GPIOE) ||
    212                     (ulPeripheral == SYSCTL_PERIPH_LPTMR) ||
    213                     (ulPeripheral == SYSCTL_PERIPH_DMAMUX));
    214          }
    215          #endif
    216          
    217          //*****************************************************************************
    218          //
    219          //! \brief Sets the clock of the device.
    220          //!
    221          //! \param ulSysClk is the clock rate you will set.
    222          //! \param ulConfig is the required configuration of the device clock.
    223          //!
    224          //! This function configures the clock of the device.  The input crystal
    225          //! frequency, oscillator to be used, use of the PLL, and the system clock
    226          //! divider are all configured with this function.
    227          //!
    228          //! The \e ulConfig parameter is the logical OR of several different values,
    229          //! many of which are grouped into sets where only one can be chosen.
    230          //!
    231          //! The external crystal frequency is chosen with one of the following values:
    232          //! \ref xSYSCTL_XTAL_3MHZ, \ref xSYSCTL_XTAL_4MHZ, \ref xSYSCTL_XTAL_5MHZ,
    233          //! \ref xSYSCTL_XTAL_32MHZ.
    234          //!
    235          //! The oscillator source is chosen with one of the following values:
    236          //! \ref xSYSCTL_OSC_MAIN, \ref xSYSCTL_OSC_INTSL.
    237          //!
    238          //! The external oscillator must be enabled in order to use an external clock
    239          //! source.  Note that attempts to disable the oscillator used to clock the
    240          //! device will be prevented by the hardware.
    241          //! <br />
    242          //! Details please refer to \ref xSysCtl_Clock_Set_Config.
    243          //!
    244          //! \note The ulSysClk should be between 31250 and 39063 Hz
    245          //! if the ulConfig is xSYSCTL_OSC_INTSL.
    246          //!
    247          //! \return None.
    248          //
    249          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
    250          void
    251          xSysCtlClockSet(unsigned long ulSysClk, unsigned long ulConfig)
    252          {
   \                     xSysCtlClockSet:
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0007             MOVS     R7,R0
    253              unsigned long ulOscFreq, ulSysDiv, i, ulTemp;
    254              
    255              unsigned char ucTempReg = 0;
   \   00000006   0x2500             MOVS     R5,#+0
    256              xASSERT((ulSysClk > 0 && ulSysClk <= 48000000));
    257              //
    258              // Calc oscillator freq
    259              //
    260              s_ulExtClockMHz = ((ulConfig & SYSCTL_XTAL_MASK) >> 8);
   \   00000008   0x9802             LDR      R0,[SP, #+8]
   \   0000000A   0x0A00             LSRS     R0,R0,#+8
   \   0000000C   0xB2C0             UXTB     R0,R0
   \   0000000E   0x....             LDR      R1,??DataTable2
   \   00000010   0x6008             STR      R0,[R1, #+0]
    261              ulSysDiv = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x0006             MOVS     R6,R0
    262              ulOscFreq = s_ulExtClockMHz*1000000;
   \   00000016   0x....             LDR      R0,??DataTable2
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x....             LDR      R1,??DataTable3  ;; 0xf4240
   \   0000001C   0x4348             MULS     R0,R1,R0
   \   0000001E   0x9000             STR      R0,[SP, #+0]
    263          
    264              switch(ulConfig & SYSCTL_OSCSRC_M)
   \   00000020   0x9802             LDR      R0,[SP, #+8]
   \   00000022   0x21C0             MOVS     R1,#+192
   \   00000024   0x4001             ANDS     R1,R1,R0
   \   00000026   0x2940             CMP      R1,#+64
   \   00000028   0xD100             BNE      .+4
   \   0000002A   0xE0D5             B        ??xSysCtlClockSet_0
   \   0000002C   0x2980             CMP      R1,#+128
   \   0000002E   0xD000             BEQ      .+4
   \   00000030   0xE10B             B        ??xSysCtlClockSet_1
    265              {
    266                  case xSYSCTL_OSC_MAIN:
    267                  {
    268                      xHWREG(SIM_CLKDIV1) &= ~SIM_CLKDIV1_OUTDIV1_M;
   \                     ??xSysCtlClockSet_2:
   \   00000032   0x....             LDR      R0,??DataTable3_1  ;; 0x40048044
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x0100             LSLS     R0,R0,#+4        ;; ZeroExtS R0,R0,#+4,#+4
   \   00000038   0x0900             LSRS     R0,R0,#+4
   \   0000003A   0x....             LDR      R1,??DataTable3_1  ;; 0x40048044
   \   0000003C   0x6008             STR      R0,[R1, #+0]
    269                      xHWREG(SIM_CLKDIV1) &= ~SIM_CLKDIV1_OUTDIV4_M;
   \   0000003E   0x....             LDR      R0,??DataTable3_1  ;; 0x40048044
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x....             LDR      R1,??DataTable3_2  ;; 0xfff8ffff
   \   00000044   0x4001             ANDS     R1,R1,R0
   \   00000046   0x....             LDR      R0,??DataTable3_1  ;; 0x40048044
   \   00000048   0x6001             STR      R1,[R0, #+0]
    270                      xHWREG(SIM_CLKDIV1) |= SIM_CLKDIV1_OUTDIV4_2;
   \   0000004A   0x....             LDR      R0,??DataTable3_1  ;; 0x40048044
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x2180             MOVS     R1,#+128
   \   00000050   0x0249             LSLS     R1,R1,#+9        ;; #+65536
   \   00000052   0x4301             ORRS     R1,R1,R0
   \   00000054   0x....             LDR      R0,??DataTable3_1  ;; 0x40048044
   \   00000056   0x6001             STR      R1,[R0, #+0]
    271          
    272                      if(!((((xHWREGB(MCG_S) & MCG_S_CLKST_M) >> MCG_S_CLKST_S) == 0x0) &&
    273                        (xHWREGB(MCG_S) & MCG_S_IREFST) &&
    274                        (!(xHWREGB(MCG_S) & MCG_S_PLLST))))                                
   \   00000058   0x....             LDR      R0,??DataTable3_3  ;; 0x40064006
   \   0000005A   0x7800             LDRB     R0,[R0, #+0]
   \   0000005C   0xB2C0             UXTB     R0,R0
   \   0000005E   0x1080             ASRS     R0,R0,#+2
   \   00000060   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   00000062   0x0F80             LSRS     R0,R0,#+30
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD105             BNE      ??xSysCtlClockSet_3
   \   00000068   0x....             LDR      R0,??DataTable3_3  ;; 0x40064006
   \   0000006A   0x7800             LDRB     R0,[R0, #+0]
   \   0000006C   0x06C0             LSLS     R0,R0,#+27
   \   0000006E   0xD501             BPL      ??xSysCtlClockSet_3
   \   00000070   0x....             LDR      R0,??DataTable3_3  ;; 0x40064006
   \   00000072   0x7800             LDRB     R0,[R0, #+0]
    275                      {
    276                      }
    277                     
    278                      ucTempReg = xHWREGB(MCG_C2);
   \                     ??xSysCtlClockSet_3:
   \   00000074   0x....             LDR      R0,??DataTable3_4  ;; 0x40064001
   \   00000076   0x7800             LDRB     R0,[R0, #+0]
   \   00000078   0x0005             MOVS     R5,R0
    279                      ucTempReg &= ~(MCG_C2_RANGE0_M | MCG_C2_HGO0 | MCG_C2_EREFS0);
   \   0000007A   0x0028             MOVS     R0,R5
   \   0000007C   0x25C3             MOVS     R5,#+195
   \   0000007E   0x4005             ANDS     R5,R5,R0
    280                      ucTempReg |= (MCG_C2_RANGE0_HIGH | MCG_C2_EREFS0); 
   \   00000080   0x0028             MOVS     R0,R5
   \   00000082   0x2514             MOVS     R5,#+20
   \   00000084   0x4305             ORRS     R5,R5,R0
    281                      xHWREGB(MCG_C2) = ucTempReg;
   \   00000086   0x....             LDR      R0,??DataTable3_4  ;; 0x40064001
   \   00000088   0x7005             STRB     R5,[R0, #+0]
    282          
    283                      ucTempReg = xHWREGB(MCG_C1);
   \   0000008A   0x....             LDR      R0,??DataTable3_5  ;; 0x40064000
   \   0000008C   0x7800             LDRB     R0,[R0, #+0]
   \   0000008E   0x0005             MOVS     R5,R0
    284                      ucTempReg &= ~(MCG_C1_SRC_MCGOUTCLK_M | MCG_C1_FRDIV_M | MCG_C1_IREFS);
   \   00000090   0x07AD             LSLS     R5,R5,#+30       ;; ZeroExtS R5,R5,#+30,#+30
   \   00000092   0x0FAD             LSRS     R5,R5,#+30
    285                      ucTempReg |= (MCG_C1_SRC_MCGOUTCLK_EXTERAL | MCG_C1_FRDIV_256); 
   \   00000094   0x0028             MOVS     R0,R5
   \   00000096   0x2598             MOVS     R5,#+152
   \   00000098   0x4305             ORRS     R5,R5,R0
    286                      xHWREGB(MCG_C1) = ucTempReg;
   \   0000009A   0x....             LDR      R0,??DataTable3_5  ;; 0x40064000
   \   0000009C   0x7005             STRB     R5,[R0, #+0]
    287          
    288                      for (i = 0 ; i < 20000 ; i++)
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x0004             MOVS     R4,R0
   \                     ??xSysCtlClockSet_4:
   \   000000A2   0x....             LDR      R0,??DataTable3_6  ;; 0x4e20
   \   000000A4   0x4284             CMP      R4,R0
   \   000000A6   0xD205             BCS      ??xSysCtlClockSet_5
    289                      {
    290                          if(xHWREGB(MCG_S) & MCG_S_OSCINIT0)
   \   000000A8   0x....             LDR      R0,??DataTable3_3  ;; 0x40064006
   \   000000AA   0x7800             LDRB     R0,[R0, #+0]
   \   000000AC   0x0780             LSLS     R0,R0,#+30
   \   000000AE   0xD401             BMI      ??xSysCtlClockSet_5
    291                          {
    292                              //
    293                              // jump out early if OSCINIT sets before loop finishes
    294                              //
    295                              break;
    296                          }
    297                      }
   \                     ??xSysCtlClockSet_6:
   \   000000B0   0x1C64             ADDS     R4,R4,#+1
   \   000000B2   0xE7F6             B        ??xSysCtlClockSet_4
    298                      //
    299                      // wait for Reference clock Status bit to clear
    300                      //
    301                      for (i = 0 ; i < 20000 ; i++)
   \                     ??xSysCtlClockSet_5:
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0x0004             MOVS     R4,R0
   \                     ??xSysCtlClockSet_7:
   \   000000B8   0x....             LDR      R0,??DataTable3_6  ;; 0x4e20
   \   000000BA   0x4284             CMP      R4,R0
   \   000000BC   0xD205             BCS      ??xSysCtlClockSet_8
    302                      {
    303                          if(xHWREGB(MCG_S) & MCG_S_IREFST)
   \   000000BE   0x....             LDR      R0,??DataTable3_3  ;; 0x40064006
   \   000000C0   0x7800             LDRB     R0,[R0, #+0]
   \   000000C2   0x06C0             LSLS     R0,R0,#+27
   \   000000C4   0xD401             BMI      ??xSysCtlClockSet_8
    304                          {
    305                              //
    306                              // jump out early if OSCINIT sets before loop finishes
    307                              //
    308                              break; 
    309                          }
    310                      }
   \                     ??xSysCtlClockSet_9:
   \   000000C6   0x1C64             ADDS     R4,R4,#+1
   \   000000C8   0xE7F6             B        ??xSysCtlClockSet_7
    311          
    312                      //
    313                      // Wait for clock status bits to show clock source is ext ref clk
    314                      //
    315                      for (i = 0 ; i < 20000 ; i++)
   \                     ??xSysCtlClockSet_8:
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0x0004             MOVS     R4,R0
   \                     ??xSysCtlClockSet_10:
   \   000000CE   0x....             LDR      R0,??DataTable3_6  ;; 0x4e20
   \   000000D0   0x4284             CMP      R4,R0
   \   000000D2   0xD208             BCS      ??xSysCtlClockSet_11
    316                      {
    317                          if((xHWREGB(MCG_S) & MCG_S_CLKST_M)==MCG_S_CLKST_EXT)
   \   000000D4   0x....             LDR      R0,??DataTable3_3  ;; 0x40064006
   \   000000D6   0x7800             LDRB     R0,[R0, #+0]
   \   000000D8   0xB2C0             UXTB     R0,R0
   \   000000DA   0x210C             MOVS     R1,#+12
   \   000000DC   0x4001             ANDS     R1,R1,R0
   \   000000DE   0x2908             CMP      R1,#+8
   \   000000E0   0xD001             BEQ      ??xSysCtlClockSet_11
    318                          {
    319                              //
    320                              // jump out early if CLKST shows EXT CLK slected before loop finishes
    321                              //
    322                              break;
    323                          }
    324                      }
   \                     ??xSysCtlClockSet_12:
   \   000000E2   0x1C64             ADDS     R4,R4,#+1
   \   000000E4   0xE7F3             B        ??xSysCtlClockSet_10
    325          
    326                      xHWREGB(MCG_C6) |= MCG_C6_CME0;
   \                     ??xSysCtlClockSet_11:
   \   000000E6   0x....             LDR      R0,??DataTable3_7  ;; 0x40064005
   \   000000E8   0x7800             LDRB     R0,[R0, #+0]
   \   000000EA   0x2120             MOVS     R1,#+32
   \   000000EC   0x4301             ORRS     R1,R1,R0
   \   000000EE   0x....             LDR      R0,??DataTable3_7  ;; 0x40064005
   \   000000F0   0x7001             STRB     R1,[R0, #+0]
    327          
    328                      ucTempReg = xHWREGB(MCG_C5);
   \   000000F2   0x....             LDR      R0,??DataTable3_8  ;; 0x40064004
   \   000000F4   0x7800             LDRB     R0,[R0, #+0]
   \   000000F6   0x0005             MOVS     R5,R0
    329                      ucTempReg &= ~(MCG_C5_PRDIV0_M);
   \   000000F8   0x0028             MOVS     R0,R5
   \   000000FA   0x25E0             MOVS     R5,#+224
   \   000000FC   0x4005             ANDS     R5,R5,R0
    330                      ulTemp = ulSysClk/1000000;
   \   000000FE   0x0038             MOVS     R0,R7
   \   00000100   0x....             LDR      R1,??DataTable3  ;; 0xf4240
   \   00000102   0x.... 0x....      BL       __aeabi_uidiv
   \   00000106   0x9001             STR      R0,[SP, #+4]
    331                      ulSysDiv = 192/ulTemp;
   \   00000108   0x20C0             MOVS     R0,#+192
   \   0000010A   0x9901             LDR      R1,[SP, #+4]
   \   0000010C   0x.... 0x....      BL       __aeabi_uidiv
   \   00000110   0x0006             MOVS     R6,R0
    332                      if(ulSysDiv >= 24)
   \   00000112   0x2E18             CMP      R6,#+24
   \   00000114   0xD301             BCC      ??xSysCtlClockSet_13
    333                      {
    334                          ulSysDiv = 24;
   \   00000116   0x2018             MOVS     R0,#+24
   \   00000118   0x0006             MOVS     R6,R0
    335                      }
    336                      ucTempReg |= (ulSysDiv-1); 
   \                     ??xSysCtlClockSet_13:
   \   0000011A   0x0029             MOVS     R1,R5
   \   0000011C   0x0030             MOVS     R0,R6
   \   0000011E   0x1E45             SUBS     R5,R0,#+1
   \   00000120   0x430D             ORRS     R5,R5,R1
    337                      xHWREGB(MCG_C5) = ucTempReg;
   \   00000122   0x....             LDR      R0,??DataTable3_8  ;; 0x40064004
   \   00000124   0x7005             STRB     R5,[R0, #+0]
    338          
    339                      ucTempReg = xHWREGB(MCG_C6);
   \   00000126   0x....             LDR      R0,??DataTable3_7  ;; 0x40064005
   \   00000128   0x7800             LDRB     R0,[R0, #+0]
   \   0000012A   0x0005             MOVS     R5,R0
    340                      ucTempReg &= ~(MCG_C6_VDIV0_M);
   \   0000012C   0x0028             MOVS     R0,R5
   \   0000012E   0x25E0             MOVS     R5,#+224
   \   00000130   0x4005             ANDS     R5,R5,R0
    341                      ucTempReg |= (MCG_C6_PLLS | MCG_C6_VDIV0_24); 
   \   00000132   0x0028             MOVS     R0,R5
   \   00000134   0x2540             MOVS     R5,#+64
   \   00000136   0x4305             ORRS     R5,R5,R0
    342                      xHWREGB(MCG_C6) = ucTempReg;
   \   00000138   0x....             LDR      R0,??DataTable3_7  ;; 0x40064005
   \   0000013A   0x7005             STRB     R5,[R0, #+0]
    343                      
    344                      //
    345                      // wait for PLLST status bit to set
    346                      //
    347                      for(i = 0 ; i < 2000 ; i++)
   \   0000013C   0x2000             MOVS     R0,#+0
   \   0000013E   0x0004             MOVS     R4,R0
   \                     ??xSysCtlClockSet_14:
   \   00000140   0x20FA             MOVS     R0,#+250
   \   00000142   0x00C0             LSLS     R0,R0,#+3        ;; #+2000
   \   00000144   0x4284             CMP      R4,R0
   \   00000146   0xD205             BCS      ??xSysCtlClockSet_15
    348                      {
    349                          if(xHWREGB(MCG_S) & MCG_S_PLLST)
   \   00000148   0x....             LDR      R0,??DataTable3_3  ;; 0x40064006
   \   0000014A   0x7800             LDRB     R0,[R0, #+0]
   \   0000014C   0x0680             LSLS     R0,R0,#+26
   \   0000014E   0xD401             BMI      ??xSysCtlClockSet_15
    350                          {
    351                              //
    352                              // jump out early if PLLST sets before loop finishes
    353                              //
    354                              break; 
    355                          }
    356                      }
   \                     ??xSysCtlClockSet_16:
   \   00000150   0x1C64             ADDS     R4,R4,#+1
   \   00000152   0xE7F5             B        ??xSysCtlClockSet_14
    357                      //
    358                      // Wait for LOCK bit to set
    359                      //
    360                      for (i = 0 ; i < 4000 ; i++)
   \                     ??xSysCtlClockSet_15:
   \   00000154   0x2000             MOVS     R0,#+0
   \   00000156   0x0004             MOVS     R4,R0
   \                     ??xSysCtlClockSet_17:
   \   00000158   0x20FA             MOVS     R0,#+250
   \   0000015A   0x0100             LSLS     R0,R0,#+4        ;; #+4000
   \   0000015C   0x4284             CMP      R4,R0
   \   0000015E   0xD205             BCS      ??xSysCtlClockSet_18
    361                      {
    362                          if(xHWREGB(MCG_S)&MCG_S_LOCK0)
   \   00000160   0x....             LDR      R0,??DataTable3_3  ;; 0x40064006
   \   00000162   0x7800             LDRB     R0,[R0, #+0]
   \   00000164   0x0640             LSLS     R0,R0,#+25
   \   00000166   0xD401             BMI      ??xSysCtlClockSet_18
    363                          {
    364                              //
    365                              // jump out early if LOCK sets before loop finishes
    366                              //
    367                              break;
    368                          }
    369                      }
   \                     ??xSysCtlClockSet_19:
   \   00000168   0x1C64             ADDS     R4,R4,#+1
   \   0000016A   0xE7F5             B        ??xSysCtlClockSet_17
    370          
    371                      SysCtlHClockSourceSet(SYSCTL_HLCK_S_PLL);
   \                     ??xSysCtlClockSet_18:
   \   0000016C   0x2000             MOVS     R0,#+0
   \   0000016E   0x.... 0x....      BL       SysCtlHClockSourceSet
    372          
    373                      //
    374                      // Wait for clock status bits to update
    375                      //
    376                      for (i = 0 ; i < 2000 ; i++)
   \   00000172   0x2000             MOVS     R0,#+0
   \   00000174   0x0004             MOVS     R4,R0
   \                     ??xSysCtlClockSet_20:
   \   00000176   0x20FA             MOVS     R0,#+250
   \   00000178   0x00C0             LSLS     R0,R0,#+3        ;; #+2000
   \   0000017A   0x4284             CMP      R4,R0
   \   0000017C   0xD208             BCS      ??xSysCtlClockSet_21
    377                      {
    378                          if((xHWREGB(MCG_S) & MCG_S_CLKST_PLL) == MCG_S_CLKST_PLL)
   \   0000017E   0x....             LDR      R0,??DataTable3_3  ;; 0x40064006
   \   00000180   0x7800             LDRB     R0,[R0, #+0]
   \   00000182   0xB2C0             UXTB     R0,R0
   \   00000184   0x210C             MOVS     R1,#+12
   \   00000186   0x4001             ANDS     R1,R1,R0
   \   00000188   0x290C             CMP      R1,#+12
   \   0000018A   0xD001             BEQ      ??xSysCtlClockSet_21
    379                          {
    380                              break; // jump out early if CLKST = 3 before loop finishes            
    381                          }
    382          
    383                      }
   \                     ??xSysCtlClockSet_22:
   \   0000018C   0x1C64             ADDS     R4,R4,#+1
   \   0000018E   0xE7F2             B        ??xSysCtlClockSet_20
    384                      //
    385                      // set PLLFLLSEL to select the PLL for this clock source
    386                      //
    387                      xHWREG(SIM_SOPT2) |= SIM_SOPT2_PLLFLLSEL;
   \                     ??xSysCtlClockSet_21:
   \   00000190   0x....             LDR      R0,??DataTable3_9  ;; 0x40048004
   \   00000192   0x6800             LDR      R0,[R0, #+0]
   \   00000194   0x2180             MOVS     R1,#+128
   \   00000196   0x0249             LSLS     R1,R1,#+9        ;; #+65536
   \   00000198   0x4301             ORRS     R1,R1,R0
   \   0000019A   0x....             LDR      R0,??DataTable3_9  ;; 0x40048004
   \   0000019C   0x6001             STR      R1,[R0, #+0]
    388          
    389                      if (ulSysClk < ulOscFreq)
   \   0000019E   0x9800             LDR      R0,[SP, #+0]
   \   000001A0   0x4287             CMP      R7,R0
   \   000001A2   0xD218             BCS      ??xSysCtlClockSet_23
    390                      {
    391                          //
    392                          // Calc the SysDiv
    393                          //    
    394                          xASSERT(ulSysClk <= ulOscFreq);
    395                      
    396                          for(ulSysDiv = 1; ulSysDiv < 16; ulSysDiv++)
   \   000001A4   0x2001             MOVS     R0,#+1
   \   000001A6   0x0006             MOVS     R6,R0
   \                     ??xSysCtlClockSet_24:
   \   000001A8   0x2E10             CMP      R6,#+16
   \   000001AA   0xD208             BCS      ??xSysCtlClockSet_25
    397                          {
    398                              if((ulOscFreq / (ulSysDiv + 1)) <= ulSysClk)
   \   000001AC   0x9800             LDR      R0,[SP, #+0]
   \   000001AE   0x0031             MOVS     R1,R6
   \   000001B0   0x1C49             ADDS     R1,R1,#+1
   \   000001B2   0x.... 0x....      BL       __aeabi_uidiv
   \   000001B6   0x4287             CMP      R7,R0
   \   000001B8   0xD201             BCS      ??xSysCtlClockSet_25
    399                              {
    400                                  break;
    401                              }
    402                          }
   \                     ??xSysCtlClockSet_26:
   \   000001BA   0x1C76             ADDS     R6,R6,#+1
   \   000001BC   0xE7F4             B        ??xSysCtlClockSet_24
    403                          xHWREG(SIM_CLKDIV1) &= ~SIM_CLKDIV1_OUTDIV1_M;
   \                     ??xSysCtlClockSet_25:
   \   000001BE   0x....             LDR      R0,??DataTable3_1  ;; 0x40048044
   \   000001C0   0x6800             LDR      R0,[R0, #+0]
   \   000001C2   0x0100             LSLS     R0,R0,#+4        ;; ZeroExtS R0,R0,#+4,#+4
   \   000001C4   0x0900             LSRS     R0,R0,#+4
   \   000001C6   0x....             LDR      R1,??DataTable3_1  ;; 0x40048044
   \   000001C8   0x6008             STR      R0,[R1, #+0]
    404                          xHWREG(SIM_CLKDIV1) |= (ulSysDiv << SIM_CLKDIV1_OUTDIV1_S);
   \   000001CA   0x....             LDR      R0,??DataTable3_1  ;; 0x40048044
   \   000001CC   0x6800             LDR      R0,[R0, #+0]
   \   000001CE   0x0731             LSLS     R1,R6,#+28
   \   000001D0   0x4301             ORRS     R1,R1,R0
   \   000001D2   0x....             LDR      R0,??DataTable3_1  ;; 0x40048044
   \   000001D4   0x6001             STR      R1,[R0, #+0]
    405                      }
    406                      break;
   \                     ??xSysCtlClockSet_23:
   \   000001D6   0xE038             B        ??xSysCtlClockSet_27
    407                  }
    408                  case xSYSCTL_OSC_INTSL:
    409                  {
    410                      if(!((((xHWREGB(MCG_S) & MCG_S_CLKST_M) >> MCG_S_CLKST_S) == 0x0) &&
    411                        (xHWREGB(MCG_S) & MCG_S_IREFST) &&
    412                        (!(xHWREGB(MCG_S) & MCG_S_PLLST))))                                
   \                     ??xSysCtlClockSet_0:
   \   000001D8   0x....             LDR      R0,??DataTable3_3  ;; 0x40064006
   \   000001DA   0x7800             LDRB     R0,[R0, #+0]
   \   000001DC   0xB2C0             UXTB     R0,R0
   \   000001DE   0x1080             ASRS     R0,R0,#+2
   \   000001E0   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   000001E2   0x0F80             LSRS     R0,R0,#+30
   \   000001E4   0x2800             CMP      R0,#+0
   \   000001E6   0xD105             BNE      ??xSysCtlClockSet_28
   \   000001E8   0x....             LDR      R0,??DataTable3_3  ;; 0x40064006
   \   000001EA   0x7800             LDRB     R0,[R0, #+0]
   \   000001EC   0x06C0             LSLS     R0,R0,#+27
   \   000001EE   0xD501             BPL      ??xSysCtlClockSet_28
   \   000001F0   0x....             LDR      R0,??DataTable3_3  ;; 0x40064006
   \   000001F2   0x7800             LDRB     R0,[R0, #+0]
    413                      {
    414                      }
    415                      xHWREGB(MCG_C2) &= ~MCG_C2_IRCS;
   \                     ??xSysCtlClockSet_28:
   \   000001F4   0x....             LDR      R0,??DataTable3_4  ;; 0x40064001
   \   000001F6   0x7800             LDRB     R0,[R0, #+0]
   \   000001F8   0x21FE             MOVS     R1,#+254
   \   000001FA   0x4001             ANDS     R1,R1,R0
   \   000001FC   0x....             LDR      R0,??DataTable3_4  ;; 0x40064001
   \   000001FE   0x7001             STRB     R1,[R0, #+0]
    416                      //
    417                      // Change the CLKS mux to select the IRC as the MCGOUT
    418                      //
    419                      ucTempReg = xHWREGB(MCG_C1);
   \   00000200   0x....             LDR      R0,??DataTable3_5  ;; 0x40064000
   \   00000202   0x7800             LDRB     R0,[R0, #+0]
   \   00000204   0x0005             MOVS     R5,R0
    420                      ucTempReg &= ~MCG_C1_SRC_MCGOUTCLK_M;
   \   00000206   0x06AD             LSLS     R5,R5,#+26       ;; ZeroExtS R5,R5,#+26,#+26
   \   00000208   0x0EAD             LSRS     R5,R5,#+26
    421                      //
    422                      // select IRC as the MCG clock sourse
    423                      //
    424                      ucTempReg |= MCG_C1_SRC_MCGOUTCLK_INTERAL;
   \   0000020A   0x0028             MOVS     R0,R5
   \   0000020C   0x2540             MOVS     R5,#+64
   \   0000020E   0x4305             ORRS     R5,R5,R0
    425                      xHWREGB(MCG_C1) = ucTempReg;
   \   00000210   0x....             LDR      R0,??DataTable3_5  ;; 0x40064000
   \   00000212   0x7005             STRB     R5,[R0, #+0]
    426                      //
    427                      // wait until internal reference switches to requested irc.
    428                      //
    429                      for (i = 0 ; i < 2000 ; i++)
   \   00000214   0x2000             MOVS     R0,#+0
   \   00000216   0x0004             MOVS     R4,R0
   \                     ??xSysCtlClockSet_29:
   \   00000218   0x20FA             MOVS     R0,#+250
   \   0000021A   0x00C0             LSLS     R0,R0,#+3        ;; #+2000
   \   0000021C   0x4284             CMP      R4,R0
   \   0000021E   0xD206             BCS      ??xSysCtlClockSet_30
    430                      {
    431                          if((xHWREGB(MCG_S) & MCG_S_IRCST) != MCG_S_IRCST)
   \   00000220   0x....             LDR      R0,??DataTable3_3  ;; 0x40064006
   \   00000222   0x7800             LDRB     R0,[R0, #+0]
   \   00000224   0xB2C0             UXTB     R0,R0
   \   00000226   0x07C0             LSLS     R0,R0,#+31
   \   00000228   0xD501             BPL      ??xSysCtlClockSet_30
    432                          {
    433                              break;
    434                          }
    435          
    436                      }
   \                     ??xSysCtlClockSet_31:
   \   0000022A   0x1C64             ADDS     R4,R4,#+1
   \   0000022C   0xE7F4             B        ??xSysCtlClockSet_29
    437                      //
    438                      // Wait for clock status bits to update
    439                      //
    440                      for (i = 0 ; i < 2000 ; i++)
   \                     ??xSysCtlClockSet_30:
   \   0000022E   0x2000             MOVS     R0,#+0
   \   00000230   0x0004             MOVS     R4,R0
   \                     ??xSysCtlClockSet_32:
   \   00000232   0x20FA             MOVS     R0,#+250
   \   00000234   0x00C0             LSLS     R0,R0,#+3        ;; #+2000
   \   00000236   0x4284             CMP      R4,R0
   \   00000238   0xD206             BCS      ??xSysCtlClockSet_33
    441                      {
    442                          if((xHWREGB(MCG_S) & MCG_S_CLKST_INT) == MCG_S_CLKST_INT)
   \   0000023A   0x....             LDR      R0,??DataTable3_3  ;; 0x40064006
   \   0000023C   0x7800             LDRB     R0,[R0, #+0]
   \   0000023E   0xB2C0             UXTB     R0,R0
   \   00000240   0x0740             LSLS     R0,R0,#+29
   \   00000242   0xD401             BMI      ??xSysCtlClockSet_33
    443                          {
    444                              break;            
    445                          }
    446          
    447                      }
   \                     ??xSysCtlClockSet_34:
   \   00000244   0x1C64             ADDS     R4,R4,#+1
   \   00000246   0xE7F4             B        ??xSysCtlClockSet_32
    448                      break;
   \                     ??xSysCtlClockSet_33:
   \   00000248   0xE7FF             B        ??xSysCtlClockSet_27
    449                  }
    450                  default:
    451                  {
    452                      xASSERT(0);
    453                      break;
    454                  }       
    455              }
    456          }
   \                     ??xSysCtlClockSet_1:
   \                     ??xSysCtlClockSet_27:
   \   0000024A   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
    457                  
    458          //*****************************************************************************
    459          //
    460          //! \brief Enables a peripheral.
    461          //!
    462          //! \param ulPeripheralBase a Peripheral base indicate which peripheral to be 
    463          //! enabled.Details please refer to \ref xLowLayer_Peripheral_Memmap.
    464          //!
    465          //! Peripherals are enabled with this function.  At power-up, all peripherals
    466          //! are disabled; they must be enabled in order to operate or respond to
    467          //! register reads/writes.
    468          //!
    469          //! The \e ulPeripheral parameter must be only one of the following values:
    470          //! Details please refer to \ref xLowLayer_Peripheral_Memmap.
    471          //!
    472          //! \return None.
    473          //
    474          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
    475          void 
    476          xSysCtlPeripheralEnable2(unsigned long ulPeripheralBase)
    477          {
   \                     xSysCtlPeripheralEnable2:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    478              unsigned long i;
    479              for(i=0; g_pPeripherals[i].ulPeripheralBase != 0; i++)
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x0005             MOVS     R5,R0
   \                     ??xSysCtlPeripheralEnable2_0:
   \   00000008   0x200C             MOVS     R0,#+12
   \   0000000A   0x4368             MULS     R0,R5,R0
   \   0000000C   0x....             LDR      R1,??DataTable4
   \   0000000E   0x5808             LDR      R0,[R1, R0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD00F             BEQ      ??xSysCtlPeripheralEnable2_1
    480              {
    481                  if(ulPeripheralBase == g_pPeripherals[i].ulPeripheralBase)
   \   00000014   0x200C             MOVS     R0,#+12
   \   00000016   0x4368             MULS     R0,R5,R0
   \   00000018   0x....             LDR      R1,??DataTable4
   \   0000001A   0x5808             LDR      R0,[R1, R0]
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD107             BNE      ??xSysCtlPeripheralEnable2_2
    482                  {
    483                      SysCtlPeripheralEnable(g_pPeripherals[i].ulPeripheralID);
   \   00000020   0x200C             MOVS     R0,#+12
   \   00000022   0x4368             MULS     R0,R5,R0
   \   00000024   0x....             LDR      R1,??DataTable4
   \   00000026   0x1808             ADDS     R0,R1,R0
   \   00000028   0x6840             LDR      R0,[R0, #+4]
   \   0000002A   0x.... 0x....      BL       SysCtlPeripheralEnable
    484                      break;
   \   0000002E   0xE001             B        ??xSysCtlPeripheralEnable2_1
    485                  }
    486              }
   \                     ??xSysCtlPeripheralEnable2_2:
   \   00000030   0x1C6D             ADDS     R5,R5,#+1
   \   00000032   0xE7E9             B        ??xSysCtlPeripheralEnable2_0
    487          }
   \                     ??xSysCtlPeripheralEnable2_1:
   \   00000034   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    488                  
    489          //*****************************************************************************
    490          //
    491          //! \brief Disables a peripheral.
    492          //!
    493          //! \param ulPeripheralBase a Peripheral base indicate which peripheral to be 
    494          //! enabled.Details please refer to \ref xLowLayer_Peripheral_Memmap.
    495          //!
    496          //! Peripherals are disabled with this function.  At power-up, all peripherals
    497          //! are disabled; they must be enabled in order to operate or respond to
    498          //! register reads/writes.
    499          //!
    500          //! The \e ulPeripheral parameter must be only one of the following values:
    501          //! Details please refer to \ref xLowLayer_Peripheral_Memmap.
    502          //!
    503          //! \return None.
    504          //
    505          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
    506          void 
    507          xSysCtlPeripheralDisable2(unsigned long ulPeripheralBase)
    508          {
   \                     xSysCtlPeripheralDisable2:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    509              unsigned long i;
    510              for(i=0; g_pPeripherals[i].ulPeripheralBase != 0; i++)
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x0005             MOVS     R5,R0
   \                     ??xSysCtlPeripheralDisable2_0:
   \   00000008   0x200C             MOVS     R0,#+12
   \   0000000A   0x4368             MULS     R0,R5,R0
   \   0000000C   0x....             LDR      R1,??DataTable4
   \   0000000E   0x5808             LDR      R0,[R1, R0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD00F             BEQ      ??xSysCtlPeripheralDisable2_1
    511              {
    512                  if(ulPeripheralBase == g_pPeripherals[i].ulPeripheralBase)
   \   00000014   0x200C             MOVS     R0,#+12
   \   00000016   0x4368             MULS     R0,R5,R0
   \   00000018   0x....             LDR      R1,??DataTable4
   \   0000001A   0x5808             LDR      R0,[R1, R0]
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD107             BNE      ??xSysCtlPeripheralDisable2_2
    513                  {
    514                      SysCtlPeripheralDisable(g_pPeripherals[i].ulPeripheralID);
   \   00000020   0x200C             MOVS     R0,#+12
   \   00000022   0x4368             MULS     R0,R5,R0
   \   00000024   0x....             LDR      R1,??DataTable4
   \   00000026   0x1808             ADDS     R0,R1,R0
   \   00000028   0x6840             LDR      R0,[R0, #+4]
   \   0000002A   0x.... 0x....      BL       SysCtlPeripheralDisable
    515                      break;
   \   0000002E   0xE001             B        ??xSysCtlPeripheralDisable2_1
    516                  }
    517              }
   \                     ??xSysCtlPeripheralDisable2_2:
   \   00000030   0x1C6D             ADDS     R5,R5,#+1
   \   00000032   0xE7E9             B        ??xSysCtlPeripheralDisable2_0
    518          }
   \                     ??xSysCtlPeripheralDisable2_1:
   \   00000034   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    519           
    520          //*****************************************************************************
    521          //
    522          //! \brief Get the peripheral interrupt number through peripheral base.
    523          //!
    524          //! \param ulPeripheral The peripheral's base  
    525          //!
    526          //! \note It's especially useful to enable the short pin's corresponding 
    527          //! peripheral interrupt: Use the short pin to Get the GPIO base through 
    528          //! \ref xGPIOSPinToPort function, and then use this function to enable the GPIO
    529          //! interrupt.
    530          //!
    531          //! \return None.
    532          //
    533          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
    534          unsigned long 
    535          xSysCtlPeripheraIntNumGet(unsigned long ulPeripheralBase)
    536          {
   \                     xSysCtlPeripheraIntNumGet:
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0x0001             MOVS     R1,R0
    537              unsigned long i;
    538              
    539              //
    540              // Check the arguments.
    541              //
    542              xASSERT((ulPeripheralBase == xGPIO_PORTA_BASE)||
    543                      (ulPeripheralBase == xGPIO_PORTD_BASE)||
    544                      (ulPeripheralBase == xUART0_BASE)||   
    545                      (ulPeripheralBase == xUART1_BASE)||   
    546                      (ulPeripheralBase == xUART2_BASE)||   
    547                      (ulPeripheralBase == xTIMER0_BASE)||    
    548                      (ulPeripheralBase == xTIMER1_BASE)||          
    549                      (ulPeripheralBase == xTIMER2_BASE)||    
    550                      (ulPeripheralBase == xSPI0_BASE)||     
    551                      (ulPeripheralBase == xSPI1_BASE)||         
    552                      (ulPeripheralBase == xSPI2_BASE)||           
    553                      (ulPeripheralBase == xSPI3_BASE)||   
    554                      (ulPeripheralBase == xI2C0_BASE)||  
    555                      (ulPeripheralBase == xI2C1_BASE)||
    556                      (ulPeripheralBase == xADC0_BASE)||    
    557                      (ulPeripheralBase == xACMP0_BASE)||       
    558                      (ulPeripheralBase == xPWMA_BASE)||
    559                      (ulPeripheralBase == xPWMB_BASE)||       
    560                      (ulPeripheralBase == xPWMC_BASE)       
    561                      );
    562                      
    563              for(i=0; g_pPeripherals[i].ulPeripheralBase != 0; i++)
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x0010             MOVS     R0,R2
   \                     ??xSysCtlPeripheraIntNumGet_0:
   \   00000008   0x220C             MOVS     R2,#+12
   \   0000000A   0x4342             MULS     R2,R0,R2
   \   0000000C   0x....             LDR      R3,??DataTable4
   \   0000000E   0x589A             LDR      R2,[R3, R2]
   \   00000010   0x2A00             CMP      R2,#+0
   \   00000012   0xD007             BEQ      ??xSysCtlPeripheraIntNumGet_1
    564              {
    565                  if(ulPeripheralBase == g_pPeripherals[i].ulPeripheralBase)
   \   00000014   0x220C             MOVS     R2,#+12
   \   00000016   0x4342             MULS     R2,R0,R2
   \   00000018   0x....             LDR      R3,??DataTable4
   \   0000001A   0x589A             LDR      R2,[R3, R2]
   \   0000001C   0x4291             CMP      R1,R2
   \   0000001E   0xD001             BEQ      ??xSysCtlPeripheraIntNumGet_1
    566                  {
    567                      break;
    568                  }
    569              }
   \                     ??xSysCtlPeripheraIntNumGet_2:
   \   00000020   0x1C40             ADDS     R0,R0,#+1
   \   00000022   0xE7F1             B        ??xSysCtlPeripheraIntNumGet_0
    570              return g_pPeripherals[i].ulPeripheralIntNum;
   \                     ??xSysCtlPeripheraIntNumGet_1:
   \   00000024   0x220C             MOVS     R2,#+12
   \   00000026   0x4350             MULS     R0,R2,R0
   \   00000028   0x....             LDR      R2,??DataTable4
   \   0000002A   0x1810             ADDS     R0,R2,R0
   \   0000002C   0x6880             LDR      R0,[R0, #+8]
   \   0000002E   0xBD00             POP      {PC}             ;; return
    571          }
    572          
    573          //*****************************************************************************
    574          //
    575          //! \brief Set a peripheral clock source and peripheral divide.
    576          //!
    577          //! \param ulPeripheralSrc is the peripheral clock source to set.
    578          //! \param ulDivide is the peripheral clock divide to set.
    579          //!
    580          //! Peripherals clock source are seted with this function.  At power-up, all 
    581          //! Peripherals clock source are Peripherals clock source; they must be set in 
    582          //! order to operate or respond to register reads/writes.
    583          //!
    584          //! The \e ulPeripheralSrc parameter must be only one of the following values:
    585          //! \ref xSysCtl_Peripheral_Src_Clk.
    586          //!
    587          //! \return None.
    588          //
    589          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
    590          void
    591          xSysCtlPeripheralClockSourceSet(unsigned long ulPeripheralSrc,
    592                                          unsigned long ulDivide)
    593          {
   \                     xSysCtlPeripheralClockSourceSet:
   \   00000000   0xB500             PUSH     {LR}
    594              //
    595              // Check the arguments.
    596              //
    597              xASSERT((ulPeripheralSrc==xSYSCTL_WDT0_INTSL)||
    598                      (ulPeripheralSrc==xSYSCTL_ADC0_MAIN)||
    599                      (ulPeripheralSrc==xSYSCTL_WDT0_HCLK_2)||
    600                      (ulPeripheralSrc==xSYSCTL_TIMER0_MAIN)||
    601                      (ulPeripheralSrc==xSYSCTL_TIMER0_HCLK)||
    602                      (ulPeripheralSrc==xSYSCTL_TIMER0_INT)||
    603                      (ulPeripheralSrc==xSYSCTL_TIMER1_MAIN)||
    604                      (ulPeripheralSrc==xSYSCTL_TIMER1_HCLK)||
    605                      (ulPeripheralSrc==xSYSCTL_TIMER1_INT)||
    606                      (ulPeripheralSrc==xSYSCTL_TIMER2_MAIN)||
    607                      (ulPeripheralSrc==xSYSCTL_TIMER2_HCLK)||
    608                      (ulPeripheralSrc==xSYSCTL_TIMER2_INT)||
    609                      (ulPeripheralSrc==xSYSCTL_UART0_MAIN)||
    610                      (ulPeripheralSrc==xSYSCTL_UART0_PLL)||
    611                      (ulPeripheralSrc==xSYSCTL_UART0_INT)||
    612                      (ulPeripheralSrc==xSYSCTL_PWMA_MAIN)||
    613                      (ulPeripheralSrc==xSYSCTL_PWMA_HCLK)||
    614                      (ulPeripheralSrc==xSYSCTL_PWMA_INT)||
    615                      (ulPeripheralSrc==xSYSCTL_PWMB_MAIN)||
    616                      (ulPeripheralSrc==xSYSCTL_PWMB_HCLK)||
    617                      (ulPeripheralSrc==xSYSCTL_PWMB_INT)||
    618                      (ulPeripheralSrc==xSYSCTL_PWMC_MAIN)||
    619                      (ulPeripheralSrc==xSYSCTL_PWMC_HCLK)||
    620                      (ulPeripheralSrc==xSYSCTL_PWMC_INT));
    621              xASSERT((ulDivide <= 256) && (ulDivide >= 1));
    622          
    623              //
    624              // Set the peripheral clock source
    625              //
    626              ulDivide = 0;
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x0011             MOVS     R1,R2
    627              if(ulPeripheralSrc == SYSCTL_PERIPH_RTC_S_OSC32KCLK)
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD10A             BNE      ??xSysCtlPeripheralClockSourceSet_0
    628              {
    629                  xHWREG(SIM_SOPT1) &= ~SIM_SOPT1_OSC32KSEL_M;
   \   0000000A   0x....             LDR      R2,??DataTable6  ;; 0x40047000
   \   0000000C   0x6812             LDR      R2,[R2, #+0]
   \   0000000E   0x....             LDR      R3,??DataTable6_1  ;; 0xfff3ffff
   \   00000010   0x4013             ANDS     R3,R3,R2
   \   00000012   0x....             LDR      R2,??DataTable6  ;; 0x40047000
   \   00000014   0x6013             STR      R3,[R2, #+0]
    630                  xHWREG(SIM_SOPT1) |= SIM_SOPT1_OSC32KSEL_OSC32KCLK;
   \   00000016   0x....             LDR      R2,??DataTable6  ;; 0x40047000
   \   00000018   0x....             LDR      R3,??DataTable6  ;; 0x40047000
   \   0000001A   0x681B             LDR      R3,[R3, #+0]
   \   0000001C   0x6013             STR      R3,[R2, #+0]
   \   0000001E   0xE121             B        ??xSysCtlPeripheralClockSourceSet_1
    631              }
    632              else if(ulPeripheralSrc == SYSCTL_PERIPH_RTC_S_RTC_CLKIN)
   \                     ??xSysCtlPeripheralClockSourceSet_0:
   \   00000020   0x2280             MOVS     R2,#+128
   \   00000022   0x0252             LSLS     R2,R2,#+9        ;; #+65536
   \   00000024   0x4290             CMP      R0,R2
   \   00000026   0xD10D             BNE      ??xSysCtlPeripheralClockSourceSet_2
    633              {
    634                  xHWREG(SIM_SOPT1) &= ~SIM_SOPT1_OSC32KSEL_M;
   \   00000028   0x....             LDR      R2,??DataTable6  ;; 0x40047000
   \   0000002A   0x6812             LDR      R2,[R2, #+0]
   \   0000002C   0x....             LDR      R3,??DataTable6_1  ;; 0xfff3ffff
   \   0000002E   0x4013             ANDS     R3,R3,R2
   \   00000030   0x....             LDR      R2,??DataTable6  ;; 0x40047000
   \   00000032   0x6013             STR      R3,[R2, #+0]
    635                  xHWREG(SIM_SOPT1) |= SIM_SOPT1_OSC32KSEL_RTC_CLKIN;
   \   00000034   0x....             LDR      R2,??DataTable6  ;; 0x40047000
   \   00000036   0x6812             LDR      R2,[R2, #+0]
   \   00000038   0x2380             MOVS     R3,#+128
   \   0000003A   0x031B             LSLS     R3,R3,#+12       ;; #+524288
   \   0000003C   0x4313             ORRS     R3,R3,R2
   \   0000003E   0x....             LDR      R2,??DataTable6  ;; 0x40047000
   \   00000040   0x6013             STR      R3,[R2, #+0]
   \   00000042   0xE10F             B        ??xSysCtlPeripheralClockSourceSet_1
    636              }
    637              else if(ulPeripheralSrc == xSYSCTL_ADC0_MAIN)
   \                     ??xSysCtlPeripheralClockSourceSet_2:
   \   00000044   0x22CC             MOVS     R2,#+204
   \   00000046   0x0612             LSLS     R2,R2,#+24       ;; #-872415232
   \   00000048   0x4290             CMP      R0,R2
   \   0000004A   0xD111             BNE      ??xSysCtlPeripheralClockSourceSet_3
    638              {
    639                  xHWREG(ADC_BASE + ADC0_CFG1) &= ~ADC0_CFG1_ADICLK_M;
   \   0000004C   0x....             LDR      R2,??DataTable6_2  ;; 0x4003b008
   \   0000004E   0x6812             LDR      R2,[R2, #+0]
   \   00000050   0x2303             MOVS     R3,#+3
   \   00000052   0x439A             BICS     R2,R2,R3
   \   00000054   0x....             LDR      R3,??DataTable6_2  ;; 0x4003b008
   \   00000056   0x601A             STR      R2,[R3, #+0]
    640                  xHWREG(ADC_BASE + ADC0_CFG1) &= ~ADC0_CFG1_ADIV_M;
   \   00000058   0x....             LDR      R2,??DataTable6_2  ;; 0x4003b008
   \   0000005A   0x6812             LDR      R2,[R2, #+0]
   \   0000005C   0x2360             MOVS     R3,#+96
   \   0000005E   0x439A             BICS     R2,R2,R3
   \   00000060   0x....             LDR      R3,??DataTable6_2  ;; 0x4003b008
   \   00000062   0x601A             STR      R2,[R3, #+0]
    641                  xHWREG(ADC_BASE + ADC0_CFG1) |= ulDivide;
   \   00000064   0x....             LDR      R2,??DataTable6_2  ;; 0x4003b008
   \   00000066   0x6812             LDR      R2,[R2, #+0]
   \   00000068   0x430A             ORRS     R2,R2,R1
   \   0000006A   0x....             LDR      R3,??DataTable6_2  ;; 0x4003b008
   \   0000006C   0x601A             STR      R2,[R3, #+0]
   \   0000006E   0xE0F9             B        ??xSysCtlPeripheralClockSourceSet_1
    642              }
    643              else if(ulPeripheralSrc == SYSCTL_PERIPH_RTC_S_LPO)
   \                     ??xSysCtlPeripheralClockSourceSet_3:
   \   00000070   0x22C0             MOVS     R2,#+192
   \   00000072   0x0312             LSLS     R2,R2,#+12       ;; #+786432
   \   00000074   0x4290             CMP      R0,R2
   \   00000076   0xD10D             BNE      ??xSysCtlPeripheralClockSourceSet_4
    644              {
    645                  xHWREG(SIM_SOPT1) &= ~SIM_SOPT1_OSC32KSEL_M;
   \   00000078   0x....             LDR      R2,??DataTable6  ;; 0x40047000
   \   0000007A   0x6812             LDR      R2,[R2, #+0]
   \   0000007C   0x....             LDR      R3,??DataTable6_1  ;; 0xfff3ffff
   \   0000007E   0x4013             ANDS     R3,R3,R2
   \   00000080   0x....             LDR      R2,??DataTable6  ;; 0x40047000
   \   00000082   0x6013             STR      R3,[R2, #+0]
    646                  xHWREG(SIM_SOPT1) |= SIM_SOPT1_OSC32KSEL_LPO;
   \   00000084   0x....             LDR      R2,??DataTable6  ;; 0x40047000
   \   00000086   0x6812             LDR      R2,[R2, #+0]
   \   00000088   0x23C0             MOVS     R3,#+192
   \   0000008A   0x031B             LSLS     R3,R3,#+12       ;; #+786432
   \   0000008C   0x4313             ORRS     R3,R3,R2
   \   0000008E   0x....             LDR      R2,??DataTable6  ;; 0x40047000
   \   00000090   0x6013             STR      R3,[R2, #+0]
   \   00000092   0xE0E7             B        ??xSysCtlPeripheralClockSourceSet_1
    647              }
    648              else if(ulPeripheralSrc == SYSCTL_PERIPH_UART0_S_MCGFLLCLK)
   \                     ??xSysCtlPeripheralClockSourceSet_4:
   \   00000094   0x2280             MOVS     R2,#+128
   \   00000096   0x04D2             LSLS     R2,R2,#+19       ;; #+67108864
   \   00000098   0x4290             CMP      R0,R2
   \   0000009A   0xD113             BNE      ??xSysCtlPeripheralClockSourceSet_5
    649              {
    650                  xHWREG(SIM_SOPT2) &= ~SIM_SOPT2_PLLFLLSEL;
   \   0000009C   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   0000009E   0x6812             LDR      R2,[R2, #+0]
   \   000000A0   0x....             LDR      R3,??DataTable9_1  ;; 0xfffeffff
   \   000000A2   0x4013             ANDS     R3,R3,R2
   \   000000A4   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   000000A6   0x6013             STR      R3,[R2, #+0]
    651                  xHWREG(SIM_SOPT2) &= ~SIM_SOPT2_UART0SRC_M;
   \   000000A8   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   000000AA   0x6812             LDR      R2,[R2, #+0]
   \   000000AC   0x....             LDR      R3,??DataTable8  ;; 0xf3ffffff
   \   000000AE   0x4013             ANDS     R3,R3,R2
   \   000000B0   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   000000B2   0x6013             STR      R3,[R2, #+0]
    652                  xHWREG(SIM_SOPT2) |= SIM_SOPT2_UART0SRC_MCGXLL;
   \   000000B4   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   000000B6   0x6812             LDR      R2,[R2, #+0]
   \   000000B8   0x2380             MOVS     R3,#+128
   \   000000BA   0x04DB             LSLS     R3,R3,#+19       ;; #+67108864
   \   000000BC   0x4313             ORRS     R3,R3,R2
   \   000000BE   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   000000C0   0x6013             STR      R3,[R2, #+0]
   \   000000C2   0xE0CF             B        ??xSysCtlPeripheralClockSourceSet_1
    653              }
    654              else if(ulPeripheralSrc == SYSCTL_PERIPH_UART0_S_MCGPLLCLK_2)
   \                     ??xSysCtlPeripheralClockSourceSet_5:
   \   000000C4   0x22A4             MOVS     R2,#+164
   \   000000C6   0x0612             LSLS     R2,R2,#+24       ;; #-1543503872
   \   000000C8   0x4290             CMP      R0,R2
   \   000000CA   0xD114             BNE      ??xSysCtlPeripheralClockSourceSet_6
    655              {
    656                  xHWREG(SIM_SOPT2) |= SIM_SOPT2_PLLFLLSEL;
   \   000000CC   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   000000CE   0x6812             LDR      R2,[R2, #+0]
   \   000000D0   0x2380             MOVS     R3,#+128
   \   000000D2   0x025B             LSLS     R3,R3,#+9        ;; #+65536
   \   000000D4   0x4313             ORRS     R3,R3,R2
   \   000000D6   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   000000D8   0x6013             STR      R3,[R2, #+0]
    657                  xHWREG(SIM_SOPT2) &= ~SIM_SOPT2_UART0SRC_M;
   \   000000DA   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   000000DC   0x6812             LDR      R2,[R2, #+0]
   \   000000DE   0x....             LDR      R3,??DataTable8  ;; 0xf3ffffff
   \   000000E0   0x4013             ANDS     R3,R3,R2
   \   000000E2   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   000000E4   0x6013             STR      R3,[R2, #+0]
    658                  xHWREG(SIM_SOPT2) |= SIM_SOPT2_UART0SRC_MCGXLL;
   \   000000E6   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   000000E8   0x6812             LDR      R2,[R2, #+0]
   \   000000EA   0x2380             MOVS     R3,#+128
   \   000000EC   0x04DB             LSLS     R3,R3,#+19       ;; #+67108864
   \   000000EE   0x4313             ORRS     R3,R3,R2
   \   000000F0   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   000000F2   0x6013             STR      R3,[R2, #+0]
   \   000000F4   0xE0B6             B        ??xSysCtlPeripheralClockSourceSet_1
    659              }
    660              else if(ulPeripheralSrc == SYSCTL_PERIPH_UART0_S_OSCERCLK)
   \                     ??xSysCtlPeripheralClockSourceSet_6:
   \   000000F6   0x2280             MOVS     R2,#+128
   \   000000F8   0x0512             LSLS     R2,R2,#+20       ;; #+134217728
   \   000000FA   0x4290             CMP      R0,R2
   \   000000FC   0xD10D             BNE      ??xSysCtlPeripheralClockSourceSet_7
    661              {
    662                  xHWREG(SIM_SOPT2) &= ~SIM_SOPT2_UART0SRC_M;
   \   000000FE   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   00000100   0x6812             LDR      R2,[R2, #+0]
   \   00000102   0x....             LDR      R3,??DataTable8  ;; 0xf3ffffff
   \   00000104   0x4013             ANDS     R3,R3,R2
   \   00000106   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   00000108   0x6013             STR      R3,[R2, #+0]
    663                  xHWREG(SIM_SOPT2) |= SIM_SOPT2_UART0SRC_OSCERCLK;
   \   0000010A   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   0000010C   0x6812             LDR      R2,[R2, #+0]
   \   0000010E   0x2380             MOVS     R3,#+128
   \   00000110   0x051B             LSLS     R3,R3,#+20       ;; #+134217728
   \   00000112   0x4313             ORRS     R3,R3,R2
   \   00000114   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   00000116   0x6013             STR      R3,[R2, #+0]
   \   00000118   0xE0A4             B        ??xSysCtlPeripheralClockSourceSet_1
    664              }
    665              else if(ulPeripheralSrc == SYSCTL_PERIPH_UART0_S_MCGIRCLK)
   \                     ??xSysCtlPeripheralClockSourceSet_7:
   \   0000011A   0x22C0             MOVS     R2,#+192
   \   0000011C   0x0512             LSLS     R2,R2,#+20       ;; #+201326592
   \   0000011E   0x4290             CMP      R0,R2
   \   00000120   0xD10D             BNE      ??xSysCtlPeripheralClockSourceSet_8
    666              {
    667                  xHWREG(SIM_SOPT2) &= ~SIM_SOPT2_UART0SRC_M;
   \   00000122   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   00000124   0x6812             LDR      R2,[R2, #+0]
   \   00000126   0x....             LDR      R3,??DataTable8  ;; 0xf3ffffff
   \   00000128   0x4013             ANDS     R3,R3,R2
   \   0000012A   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   0000012C   0x6013             STR      R3,[R2, #+0]
    668                  xHWREG(SIM_SOPT2) |= SIM_SOPT2_UART0SRC_MCGIRCLK;
   \   0000012E   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   00000130   0x6812             LDR      R2,[R2, #+0]
   \   00000132   0x23C0             MOVS     R3,#+192
   \   00000134   0x051B             LSLS     R3,R3,#+20       ;; #+201326592
   \   00000136   0x4313             ORRS     R3,R3,R2
   \   00000138   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   0000013A   0x6013             STR      R3,[R2, #+0]
   \   0000013C   0xE092             B        ??xSysCtlPeripheralClockSourceSet_1
    669              }
    670              else if(ulPeripheralSrc == SYSCTL_PERIPH_TPM_S_MCGFLLCLK)
   \                     ??xSysCtlPeripheralClockSourceSet_8:
   \   0000013E   0x2280             MOVS     R2,#+128
   \   00000140   0x0452             LSLS     R2,R2,#+17       ;; #+16777216
   \   00000142   0x4290             CMP      R0,R2
   \   00000144   0xD113             BNE      ??xSysCtlPeripheralClockSourceSet_9
    671              {
    672                  xHWREG(SIM_SOPT2) &= ~SIM_SOPT2_PLLFLLSEL;    	
   \   00000146   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   00000148   0x6812             LDR      R2,[R2, #+0]
   \   0000014A   0x....             LDR      R3,??DataTable9_1  ;; 0xfffeffff
   \   0000014C   0x4013             ANDS     R3,R3,R2
   \   0000014E   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   00000150   0x6013             STR      R3,[R2, #+0]
    673                  xHWREG(SIM_SOPT2) &= ~SIM_SOPT2_TPMSRC_M;
   \   00000152   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   00000154   0x6812             LDR      R2,[R2, #+0]
   \   00000156   0x....             LDR      R3,??DataTable12  ;; 0xfcffffff
   \   00000158   0x4013             ANDS     R3,R3,R2
   \   0000015A   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   0000015C   0x6013             STR      R3,[R2, #+0]
    674                  xHWREG(SIM_SOPT2) |= SIM_SOPT2_TPMSRC_MCGXLL;
   \   0000015E   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   00000160   0x6812             LDR      R2,[R2, #+0]
   \   00000162   0x2380             MOVS     R3,#+128
   \   00000164   0x045B             LSLS     R3,R3,#+17       ;; #+16777216
   \   00000166   0x4313             ORRS     R3,R3,R2
   \   00000168   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   0000016A   0x6013             STR      R3,[R2, #+0]
   \   0000016C   0xE07A             B        ??xSysCtlPeripheralClockSourceSet_1
    675              }
    676              else if(ulPeripheralSrc == SYSCTL_PERIPH_TPM_S_MCGPLLCLK_2)
   \                     ??xSysCtlPeripheralClockSourceSet_9:
   \   0000016E   0x22A1             MOVS     R2,#+161
   \   00000170   0x0612             LSLS     R2,R2,#+24       ;; #-1593835520
   \   00000172   0x4290             CMP      R0,R2
   \   00000174   0xD114             BNE      ??xSysCtlPeripheralClockSourceSet_10
    677              {
    678                  xHWREG(SIM_SOPT2) |= SIM_SOPT2_PLLFLLSEL;
   \   00000176   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   00000178   0x6812             LDR      R2,[R2, #+0]
   \   0000017A   0x2380             MOVS     R3,#+128
   \   0000017C   0x025B             LSLS     R3,R3,#+9        ;; #+65536
   \   0000017E   0x4313             ORRS     R3,R3,R2
   \   00000180   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   00000182   0x6013             STR      R3,[R2, #+0]
    679                  xHWREG(SIM_SOPT2) &= ~SIM_SOPT2_TPMSRC_M;
   \   00000184   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   00000186   0x6812             LDR      R2,[R2, #+0]
   \   00000188   0x....             LDR      R3,??DataTable12  ;; 0xfcffffff
   \   0000018A   0x4013             ANDS     R3,R3,R2
   \   0000018C   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   0000018E   0x6013             STR      R3,[R2, #+0]
    680                  xHWREG(SIM_SOPT2) |= SIM_SOPT2_TPMSRC_MCGXLL;
   \   00000190   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   00000192   0x6812             LDR      R2,[R2, #+0]
   \   00000194   0x2380             MOVS     R3,#+128
   \   00000196   0x045B             LSLS     R3,R3,#+17       ;; #+16777216
   \   00000198   0x4313             ORRS     R3,R3,R2
   \   0000019A   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   0000019C   0x6013             STR      R3,[R2, #+0]
   \   0000019E   0xE061             B        ??xSysCtlPeripheralClockSourceSet_1
    681              }
    682              else if(ulPeripheralSrc == SYSCTL_PERIPH_TPM_S_OSCERCLK)
   \                     ??xSysCtlPeripheralClockSourceSet_10:
   \   000001A0   0x2280             MOVS     R2,#+128
   \   000001A2   0x0492             LSLS     R2,R2,#+18       ;; #+33554432
   \   000001A4   0x4290             CMP      R0,R2
   \   000001A6   0xD10D             BNE      ??xSysCtlPeripheralClockSourceSet_11
    683              {
    684                  xHWREG(SIM_SOPT2) &= ~SIM_SOPT2_TPMSRC_M;
   \   000001A8   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   000001AA   0x6812             LDR      R2,[R2, #+0]
   \   000001AC   0x....             LDR      R3,??DataTable12  ;; 0xfcffffff
   \   000001AE   0x4013             ANDS     R3,R3,R2
   \   000001B0   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   000001B2   0x6013             STR      R3,[R2, #+0]
    685                  xHWREG(SIM_SOPT2) |= SIM_SOPT2_TPMSRC_OSCERCLK;
   \   000001B4   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   000001B6   0x6812             LDR      R2,[R2, #+0]
   \   000001B8   0x2380             MOVS     R3,#+128
   \   000001BA   0x049B             LSLS     R3,R3,#+18       ;; #+33554432
   \   000001BC   0x4313             ORRS     R3,R3,R2
   \   000001BE   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   000001C0   0x6013             STR      R3,[R2, #+0]
   \   000001C2   0xE04F             B        ??xSysCtlPeripheralClockSourceSet_1
    686              }
    687              else if(ulPeripheralSrc == SYSCTL_PERIPH_TPM_S_MCGIRCLK)
   \                     ??xSysCtlPeripheralClockSourceSet_11:
   \   000001C4   0x22C0             MOVS     R2,#+192
   \   000001C6   0x0492             LSLS     R2,R2,#+18       ;; #+50331648
   \   000001C8   0x4290             CMP      R0,R2
   \   000001CA   0xD10D             BNE      ??xSysCtlPeripheralClockSourceSet_12
    688              {
    689                  xHWREG(SIM_SOPT2) &= ~SIM_SOPT2_TPMSRC_M;
   \   000001CC   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   000001CE   0x6812             LDR      R2,[R2, #+0]
   \   000001D0   0x....             LDR      R3,??DataTable12  ;; 0xfcffffff
   \   000001D2   0x4013             ANDS     R3,R3,R2
   \   000001D4   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   000001D6   0x6013             STR      R3,[R2, #+0]
    690                  xHWREG(SIM_SOPT2) |= SIM_SOPT2_TPMSRC_MCGIRCLK;
   \   000001D8   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   000001DA   0x6812             LDR      R2,[R2, #+0]
   \   000001DC   0x23C0             MOVS     R3,#+192
   \   000001DE   0x049B             LSLS     R3,R3,#+18       ;; #+50331648
   \   000001E0   0x4313             ORRS     R3,R3,R2
   \   000001E2   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   000001E4   0x6013             STR      R3,[R2, #+0]
   \   000001E6   0xE03D             B        ??xSysCtlPeripheralClockSourceSet_1
    691              }
    692              else if(ulPeripheralSrc == SYSCTL_PERIPH_USB_S_USB_CLKIN)
   \                     ??xSysCtlPeripheralClockSourceSet_12:
   \   000001E8   0x22B0             MOVS     R2,#+176
   \   000001EA   0x0612             LSLS     R2,R2,#+24       ;; #-1342177280
   \   000001EC   0x4290             CMP      R0,R2
   \   000001EE   0xD106             BNE      ??xSysCtlPeripheralClockSourceSet_13
    693              {
    694                  xHWREG(SIM_SOPT2) &= ~SIM_SOPT2_USBSRC;
   \   000001F0   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   000001F2   0x6812             LDR      R2,[R2, #+0]
   \   000001F4   0x....             LDR      R3,??DataTable14  ;; 0xfffbffff
   \   000001F6   0x4013             ANDS     R3,R3,R2
   \   000001F8   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   000001FA   0x6013             STR      R3,[R2, #+0]
   \   000001FC   0xE032             B        ??xSysCtlPeripheralClockSourceSet_1
    695              }
    696              else if(ulPeripheralSrc == SYSCTL_PERIPH_USB_S_MCGPLLCLK_2)
   \                     ??xSysCtlPeripheralClockSourceSet_13:
   \   000001FE   0x....             LDR      R2,??DataTable14_1  ;; 0x80704
   \   00000200   0x4290             CMP      R0,R2
   \   00000202   0xD10E             BNE      ??xSysCtlPeripheralClockSourceSet_14
    697              {
    698                  xHWREG(SIM_SOPT2) |= SIM_SOPT2_PLLFLLSEL;    	
   \   00000204   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   00000206   0x6812             LDR      R2,[R2, #+0]
   \   00000208   0x2380             MOVS     R3,#+128
   \   0000020A   0x025B             LSLS     R3,R3,#+9        ;; #+65536
   \   0000020C   0x4313             ORRS     R3,R3,R2
   \   0000020E   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   00000210   0x6013             STR      R3,[R2, #+0]
    699                  xHWREG(SIM_SOPT2) |= SIM_SOPT2_USBSRC;
   \   00000212   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   00000214   0x6812             LDR      R2,[R2, #+0]
   \   00000216   0x2380             MOVS     R3,#+128
   \   00000218   0x02DB             LSLS     R3,R3,#+11       ;; #+262144
   \   0000021A   0x4313             ORRS     R3,R3,R2
   \   0000021C   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   0000021E   0x6013             STR      R3,[R2, #+0]
   \   00000220   0xE020             B        ??xSysCtlPeripheralClockSourceSet_1
    700              }
    701              else if(ulPeripheralSrc == SYSCTL_PERIPH_USB_S_MCGFLLCLK)
   \                     ??xSysCtlPeripheralClockSourceSet_14:
   \   00000222   0x....             LDR      R2,??DataTable14_2  ;; 0xc0700
   \   00000224   0x4290             CMP      R0,R2
   \   00000226   0xD10D             BNE      ??xSysCtlPeripheralClockSourceSet_15
    702              {
    703                  xHWREG(SIM_SOPT2) &= ~SIM_SOPT2_PLLFLLSEL;
   \   00000228   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   0000022A   0x6812             LDR      R2,[R2, #+0]
   \   0000022C   0x....             LDR      R3,??DataTable9_1  ;; 0xfffeffff
   \   0000022E   0x4013             ANDS     R3,R3,R2
   \   00000230   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   00000232   0x6013             STR      R3,[R2, #+0]
    704                  xHWREG(SIM_SOPT2) |= SIM_SOPT2_USBSRC;
   \   00000234   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   00000236   0x6812             LDR      R2,[R2, #+0]
   \   00000238   0x2380             MOVS     R3,#+128
   \   0000023A   0x02DB             LSLS     R3,R3,#+11       ;; #+262144
   \   0000023C   0x4313             ORRS     R3,R3,R2
   \   0000023E   0x....             LDR      R2,??DataTable9  ;; 0x40048004
   \   00000240   0x6013             STR      R3,[R2, #+0]
   \   00000242   0xE00F             B        ??xSysCtlPeripheralClockSourceSet_1
    705              }
    706              else if(ulPeripheralSrc == SYSCTL_PERIPH_WDG_S_1K)
   \                     ??xSysCtlPeripheralClockSourceSet_15:
   \   00000244   0x....             LDR      R2,??DataTable14_3  ;; 0xc0701
   \   00000246   0x4290             CMP      R0,R2
   \   00000248   0xD106             BNE      ??xSysCtlPeripheralClockSourceSet_16
    707              {
    708                  xHWREG(SIM_COPC ) &= ~SIM_COPC_COPCLKS;
   \   0000024A   0x....             LDR      R2,??DataTable14_4  ;; 0x40048100
   \   0000024C   0x6812             LDR      R2,[R2, #+0]
   \   0000024E   0x2302             MOVS     R3,#+2
   \   00000250   0x439A             BICS     R2,R2,R3
   \   00000252   0x....             LDR      R3,??DataTable14_4  ;; 0x40048100
   \   00000254   0x601A             STR      R2,[R3, #+0]
   \   00000256   0xE005             B        ??xSysCtlPeripheralClockSourceSet_1
    709              }
    710              else
    711              {
    712                  xHWREG(SIM_COPC ) |= SIM_COPC_COPCLKS;
   \                     ??xSysCtlPeripheralClockSourceSet_16:
   \   00000258   0x....             LDR      R2,??DataTable14_4  ;; 0x40048100
   \   0000025A   0x6812             LDR      R2,[R2, #+0]
   \   0000025C   0x2302             MOVS     R3,#+2
   \   0000025E   0x4313             ORRS     R3,R3,R2
   \   00000260   0x....             LDR      R2,??DataTable14_4  ;; 0x40048100
   \   00000262   0x6013             STR      R3,[R2, #+0]
    713              }
    714          }
   \                     ??xSysCtlPeripheralClockSourceSet_1:
   \   00000264   0xBD00             POP      {PC}             ;; return
    715          
    716          //*****************************************************************************
    717          //
    718          //! \brief Enables a peripheral.
    719          //!
    720          //! \param ulPeripheral is the peripheral to enable.
    721          //!
    722          //! Peripherals are enabled with this function.  At power-up, all peripherals
    723          //! are disabled; they must be enabled in order to operate or respond to
    724          //! register reads/writes.
    725          //!
    726          //! The \e ulPeripheral parameter must be only one of the following values:
    727          //! \b SYSCTL_PERIPH_DMA,  \b SYSCTL_PERIPH_DAC,  \b SYSCTL_PERIPH_TMR0,
    728          //! \b SYSCTL_PERIPH_TMR1, \b SYSCTL_PERIPH_TMR2, \b SYSCTL_PERIPH_RTC,
    729          //! \b SYSCTL_PERIPH_I2C0, \b SYSCTL_PERIPH_I2C1, \b SYSCTL_PERIPH_SPI0,
    730          //! \b SYSCTL_PERIPH_SPI1, \b SYSCTL_PERIPH_PIT,  \b SYSCTL_PERIPH_DMAMUX,
    731          //! \b SYSCTL_PERIPH_UART0,\b SYSCTL_PERIPH_UART1,\b SYSCTL_PERIPH_UART2,
    732          //! \b SYSCTL_PERIPH_PWMA, \b SYSCTL_PERIPH_PWMB, \b SYSCTL_PERIPH_PWMC,
    733          //! \b SYSCTL_PERIPH_USB,  \b SYSCTL_PERIPH_ADC,  \b SYSCTL_PERIPH_FLASH,
    734          //! \b SYSCTL_PERIPH_ACMP, \b SYSCTL_PERIPH_GPIOA,\b SYSCTL_PERIPH_GPIOB,
    735          //! \b SYSCTL_PERIPH_GPIOC,\b SYSCTL_PERIPH_GPIOD,\b SYSCTL_PERIPH_GPIOE.
    736          //!
    737          //! \return None.
    738          //
    739          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
    740          void
    741          SysCtlPeripheralEnable(unsigned long ulPeripheral)
    742          {
   \                     SysCtlPeripheralEnable:
   \   00000000   0xB430             PUSH     {R4,R5}
    743              unsigned long ulReadValue = 0, ulIndex = 0;
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x2200             MOVS     R2,#+0
    744              //
    745              // Check the arguments.
    746              //
    747              xASSERT(SysCtlPeripheralValid(ulPeripheral));
    748              ulIndex = SYSCTL_PERIPH_INDEX_E(ulPeripheral);
   \   00000006   0x0003             MOVS     R3,R0
   \   00000008   0x0B9B             LSRS     R3,R3,#+14
   \   0000000A   0x079B             LSLS     R3,R3,#+30       ;; ZeroExtS R3,R3,#+30,#+30
   \   0000000C   0x0F9B             LSRS     R3,R3,#+30
   \   0000000E   0x001A             MOVS     R2,R3
    749              ulReadValue = SYSCTL_PERIPH_MASK_E(ulPeripheral);
   \   00000010   0xB2C3             UXTB     R3,R0
   \   00000012   0x0004             MOVS     R4,R0
   \   00000014   0x0A24             LSRS     R4,R4,#+8
   \   00000016   0x06E4             LSLS     R4,R4,#+27       ;; ZeroExtS R4,R4,#+27,#+27
   \   00000018   0x0EE4             LSRS     R4,R4,#+27
   \   0000001A   0x40A3             LSLS     R3,R3,R4
   \   0000001C   0x0019             MOVS     R1,R3
    750              //
    751              // Enable this peripheral.
    752              //
    753              xHWREG(g_pulAXBCLKRegs[ulIndex]) |= ulReadValue;
   \   0000001E   0x2304             MOVS     R3,#+4
   \   00000020   0x4353             MULS     R3,R2,R3
   \   00000022   0x....             LDR      R4,??DataTable14_5
   \   00000024   0x58E3             LDR      R3,[R4, R3]
   \   00000026   0x681B             LDR      R3,[R3, #+0]
   \   00000028   0x430B             ORRS     R3,R3,R1
   \   0000002A   0x2404             MOVS     R4,#+4
   \   0000002C   0x4354             MULS     R4,R2,R4
   \   0000002E   0x....             LDR      R5,??DataTable14_5
   \   00000030   0x592C             LDR      R4,[R5, R4]
   \   00000032   0x6023             STR      R3,[R4, #+0]
    754          }
   \   00000034   0xBC30             POP      {R4,R5}
   \   00000036   0x4770             BX       LR               ;; return
    755          
    756          //*****************************************************************************
    757          //
    758          //! \brief Disable a peripheral.
    759          //!
    760          //! \param ulPeripheral is the peripheral to Disable.
    761          //!
    762          //! Peripherals are disabled with this function.  Once disabled, they will not
    763          //! operate or respond to register reads/writes.
    764          //!
    765          //! The \e ulPeripheral parameter must be only one of the following values:
    766          //! \b SYSCTL_PERIPH_DMA,  \b SYSCTL_PERIPH_DAC,  \b SYSCTL_PERIPH_TMR0,
    767          //! \b SYSCTL_PERIPH_TMR1, \b SYSCTL_PERIPH_TMR2, \b SYSCTL_PERIPH_RTC,
    768          //! \b SYSCTL_PERIPH_I2C0, \b SYSCTL_PERIPH_I2C1, \b SYSCTL_PERIPH_SPI0,
    769          //! \b SYSCTL_PERIPH_SPI1, \b SYSCTL_PERIPH_PIT,  \b SYSCTL_PERIPH_DMAMUX,
    770          //! \b SYSCTL_PERIPH_UART0,\b SYSCTL_PERIPH_UART1,\b SYSCTL_PERIPH_UART2,
    771          //! \b SYSCTL_PERIPH_PWMA, \b SYSCTL_PERIPH_PWMB, \b SYSCTL_PERIPH_PWMC,
    772          //! \b SYSCTL_PERIPH_USB,  \b SYSCTL_PERIPH_ADC,  \b SYSCTL_PERIPH_FLASH,
    773          //! \b SYSCTL_PERIPH_ACMP, \b SYSCTL_PERIPH_GPIOA,\b SYSCTL_PERIPH_GPIOB,
    774          //! \b SYSCTL_PERIPH_GPIOC,\b SYSCTL_PERIPH_GPIOD,\b SYSCTL_PERIPH_GPIOE.
    775          //!
    776          //! \return None.
    777          //
    778          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
    779          void
    780          SysCtlPeripheralDisable(unsigned long ulPeripheral)
    781          {
    782              //
    783              // Check the arguments.
    784              //
    785              xASSERT(SysCtlPeripheralValid(ulPeripheral));
    786          
    787              //
    788              // Enable this peripheral.
    789              //
    790              xHWREG(g_pulAXBCLKRegs[SYSCTL_PERIPH_INDEX_E(ulPeripheral)]) &=
    791                  ~(SYSCTL_PERIPH_MASK_E(ulPeripheral));
   \                     SysCtlPeripheralDisable:
   \   00000000   0x0001             MOVS     R1,R0
   \   00000002   0x0B89             LSRS     R1,R1,#+14
   \   00000004   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   00000006   0x0F89             LSRS     R1,R1,#+30
   \   00000008   0x2204             MOVS     R2,#+4
   \   0000000A   0x4351             MULS     R1,R2,R1
   \   0000000C   0x....             LDR      R2,??DataTable14_5
   \   0000000E   0x5851             LDR      R1,[R2, R1]
   \   00000010   0x6809             LDR      R1,[R1, #+0]
   \   00000012   0xB2C2             UXTB     R2,R0
   \   00000014   0x0003             MOVS     R3,R0
   \   00000016   0x0A1B             LSRS     R3,R3,#+8
   \   00000018   0x06DB             LSLS     R3,R3,#+27       ;; ZeroExtS R3,R3,#+27,#+27
   \   0000001A   0x0EDB             LSRS     R3,R3,#+27
   \   0000001C   0x409A             LSLS     R2,R2,R3
   \   0000001E   0x4391             BICS     R1,R1,R2
   \   00000020   0x0002             MOVS     R2,R0
   \   00000022   0x0B92             LSRS     R2,R2,#+14
   \   00000024   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   00000026   0x0F92             LSRS     R2,R2,#+30
   \   00000028   0x2304             MOVS     R3,#+4
   \   0000002A   0x435A             MULS     R2,R3,R2
   \   0000002C   0x....             LDR      R3,??DataTable14_5
   \   0000002E   0x589A             LDR      R2,[R3, R2]
   \   00000030   0x6011             STR      R1,[R2, #+0]
    792          }
   \   00000032   0x4770             BX       LR               ;; return
    793          
    794          //*****************************************************************************
    795          //
    796          //! \brief Enables and configures the edge detection for the wakeup pin.
    797          //!
    798          //! \param bEnable is a boolean that is \b true if Enable wakeup pin,
    799          //! \b false if not.
    800          //! \param ulPinIndex is the index of the wakeup pin.
    801          //! \param ulEdge is mode of wakeup pin edge.
    802          //!
    803          //! This function is to Enable and configures the edge detection for the wakeup
    804          //! pin or not.
    805          //!
    806          //! \return This function does not return.
    807          //
    808          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
    809          void
    810          SysCtlWakeupPinConfig(xtBoolean bEnable, unsigned long ulPinIndex, unsigned long ulEdge)
    811          {
   \                     SysCtlWakeupPinConfig:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    812              xASSERT((ulPinIndex >= 0 && ulPinIndex <= 15));
    813              xASSERT((ulEdge == SYSCTL_WAKEUP_PIN_DIS) ||
    814                      (ulEdge == SYSCTL_WAKEUP_PIN_ANY) ||
    815                      (ulEdge == SYSCTL_WAKEUP_PIN_RISING) ||
    816                      (ulEdge == SYSCTL_WAKEUP_PIN_FALLING));
    817              //
    818              // Enable the edge detection for the wakeup pin.
    819              //
    820              if(bEnable)
   \   00000008   0xB2E4             UXTB     R4,R4
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD024             BEQ      ??SysCtlWakeupPinConfig_0
    821              {
    822                  xHWREGB(LLWU_PE1 + ulPinIndex/4) &= ~(LLWU_PE1_WUPE0_M << ((ulPinIndex%4)*2));
   \   0000000E   0x0028             MOVS     R0,R5
   \   00000010   0x0880             LSRS     R0,R0,#+2
   \   00000012   0x....             LDR      R1,??DataTable14_6  ;; 0x4007c000
   \   00000014   0x5C40             LDRB     R0,[R0, R1]
   \   00000016   0x9000             STR      R0,[SP, #+0]
   \   00000018   0x2703             MOVS     R7,#+3
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0x2104             MOVS     R1,#+4
   \   0000001E   0x.... 0x....      BL       __aeabi_uidivmod
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0x4341             MULS     R1,R0,R1
   \   00000026   0x408F             LSLS     R7,R7,R1
   \   00000028   0x9800             LDR      R0,[SP, #+0]
   \   0000002A   0x43B8             BICS     R0,R0,R7
   \   0000002C   0x0029             MOVS     R1,R5
   \   0000002E   0x0889             LSRS     R1,R1,#+2
   \   00000030   0x....             LDR      R2,??DataTable14_6  ;; 0x4007c000
   \   00000032   0x5488             STRB     R0,[R1, R2]
    823                  xHWREGB(LLWU_PE1 + ulPinIndex/4) |= ulEdge << ((ulPinIndex%4)*2);
   \   00000034   0x0028             MOVS     R0,R5
   \   00000036   0x0880             LSRS     R0,R0,#+2
   \   00000038   0x....             LDR      R1,??DataTable14_6  ;; 0x4007c000
   \   0000003A   0x5C47             LDRB     R7,[R0, R1]
   \   0000003C   0x0028             MOVS     R0,R5
   \   0000003E   0x2104             MOVS     R1,#+4
   \   00000040   0x.... 0x....      BL       __aeabi_uidivmod
   \   00000044   0x2002             MOVS     R0,#+2
   \   00000046   0x4341             MULS     R1,R0,R1
   \   00000048   0x0030             MOVS     R0,R6
   \   0000004A   0x4088             LSLS     R0,R0,R1
   \   0000004C   0x4338             ORRS     R0,R0,R7
   \   0000004E   0x0029             MOVS     R1,R5
   \   00000050   0x0889             LSRS     R1,R1,#+2
   \   00000052   0x....             LDR      R2,??DataTable14_6  ;; 0x4007c000
   \   00000054   0x5488             STRB     R0,[R1, R2]
   \   00000056   0xE012             B        ??SysCtlWakeupPinConfig_1
    824              }
    825              else
    826              {
    827                  xHWREGB(LLWU_PE1 + ulPinIndex/4) &= ~(LLWU_PE1_WUPE0_M << ((ulPinIndex%4)*2));
   \                     ??SysCtlWakeupPinConfig_0:
   \   00000058   0x0028             MOVS     R0,R5
   \   0000005A   0x0880             LSRS     R0,R0,#+2
   \   0000005C   0x....             LDR      R1,??DataTable14_6  ;; 0x4007c000
   \   0000005E   0x5C40             LDRB     R0,[R0, R1]
   \   00000060   0x9000             STR      R0,[SP, #+0]
   \   00000062   0x2703             MOVS     R7,#+3
   \   00000064   0x0028             MOVS     R0,R5
   \   00000066   0x2104             MOVS     R1,#+4
   \   00000068   0x.... 0x....      BL       __aeabi_uidivmod
   \   0000006C   0x2002             MOVS     R0,#+2
   \   0000006E   0x4341             MULS     R1,R0,R1
   \   00000070   0x408F             LSLS     R7,R7,R1
   \   00000072   0x9800             LDR      R0,[SP, #+0]
   \   00000074   0x43B8             BICS     R0,R0,R7
   \   00000076   0x0029             MOVS     R1,R5
   \   00000078   0x0889             LSRS     R1,R1,#+2
   \   0000007A   0x....             LDR      R2,??DataTable14_6  ;; 0x4007c000
   \   0000007C   0x5488             STRB     R0,[R1, R2]
    828              }
    829          }
   \                     ??SysCtlWakeupPinConfig_1:
   \   0000007E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    830          
    831          //*****************************************************************************
    832          //
    833          //! \brief Enables and configures the edge detection for the wakeup pin.
    834          //!
    835          //! \param bEnable is a boolean that is \b true if Enable wakeup pin,
    836          //! \b false if not.
    837          //! \param ulPinIndex is the index of the wakeup pin.
    838          //! \param ulEdge is mode of wakeup pin edge.
    839          //!
    840          //! This function is to Enable and configures the edge detection for the wakeup
    841          //! pin or not.
    842          //!
    843          //! \return This function does not return.
    844          //
    845          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
    846          void
    847          SysCtlWakeupFilterConfig(unsigned long ulFilterIndex, unsigned long ulPinIndex,
    848                                   unsigned long ulEdge)
    849          {
   \                     SysCtlWakeupFilterConfig:
   \   00000000   0xB430             PUSH     {R4,R5}
    850              xASSERT((ulFilterIndex >= 1 && ulFilterIndex <= 2));
    851              xASSERT((ulPinIndex >= 0 && ulPinIndex <= 15));
    852              xASSERT((ulEdge == SYSCTL_WAKEUP_FILTER_DIS) ||
    853                      (ulEdge == SYSCTL_WAKEUP_FILTER_ANY) ||
    854                      (ulEdge == SYSCTL_WAKEUP_FILTER_RISING) ||
    855                      (ulEdge == SYSCTL_WAKEUP_FILTER_FALLING));
    856          
    857              //
    858              // Controls the digital filter options for the external pin detect
    859              //
    860              xHWREGB(LLWU_FILT1+ulFilterIndex/2) &= ~LLWU_FILT1_FILTE_M;
   \   00000002   0x0003             MOVS     R3,R0
   \   00000004   0x085B             LSRS     R3,R3,#+1
   \   00000006   0x....             LDR      R4,??DataTable14_7  ;; 0x4007c008
   \   00000008   0x5D1B             LDRB     R3,[R3, R4]
   \   0000000A   0x249F             MOVS     R4,#+159
   \   0000000C   0x401C             ANDS     R4,R4,R3
   \   0000000E   0x0003             MOVS     R3,R0
   \   00000010   0x085B             LSRS     R3,R3,#+1
   \   00000012   0x....             LDR      R5,??DataTable14_7  ;; 0x4007c008
   \   00000014   0x555C             STRB     R4,[R3, R5]
    861              xHWREGB(LLWU_FILT1+ulFilterIndex/2) |= ulEdge;
   \   00000016   0x0003             MOVS     R3,R0
   \   00000018   0x085B             LSRS     R3,R3,#+1
   \   0000001A   0x....             LDR      R4,??DataTable14_7  ;; 0x4007c008
   \   0000001C   0x5D1B             LDRB     R3,[R3, R4]
   \   0000001E   0x0014             MOVS     R4,R2
   \   00000020   0x431C             ORRS     R4,R4,R3
   \   00000022   0x0003             MOVS     R3,R0
   \   00000024   0x085B             LSRS     R3,R3,#+1
   \   00000026   0x....             LDR      R5,??DataTable14_7  ;; 0x4007c008
   \   00000028   0x555C             STRB     R4,[R3, R5]
    862              
    863              //
    864              // Selects 1 out of the 16 wakeup pins to be muxed into the filter.
    865              //
    866              xHWREGB(LLWU_FILT1+ulFilterIndex/2) &= ~LLWU_FILT1_FILTSEL_M;
   \   0000002A   0x0003             MOVS     R3,R0
   \   0000002C   0x085B             LSRS     R3,R3,#+1
   \   0000002E   0x....             LDR      R4,??DataTable14_7  ;; 0x4007c008
   \   00000030   0x5D1B             LDRB     R3,[R3, R4]
   \   00000032   0x24F0             MOVS     R4,#+240
   \   00000034   0x401C             ANDS     R4,R4,R3
   \   00000036   0x0003             MOVS     R3,R0
   \   00000038   0x085B             LSRS     R3,R3,#+1
   \   0000003A   0x....             LDR      R5,??DataTable14_7  ;; 0x4007c008
   \   0000003C   0x555C             STRB     R4,[R3, R5]
    867              xHWREGB(LLWU_FILT1+ulFilterIndex/2) |= ulPinIndex;
   \   0000003E   0x0003             MOVS     R3,R0
   \   00000040   0x085B             LSRS     R3,R3,#+1
   \   00000042   0x....             LDR      R4,??DataTable14_7  ;; 0x4007c008
   \   00000044   0x5D1B             LDRB     R3,[R3, R4]
   \   00000046   0x000C             MOVS     R4,R1
   \   00000048   0x431C             ORRS     R4,R4,R3
   \   0000004A   0x0003             MOVS     R3,R0
   \   0000004C   0x085B             LSRS     R3,R3,#+1
   \   0000004E   0x....             LDR      R5,??DataTable14_7  ;; 0x4007c008
   \   00000050   0x555C             STRB     R4,[R3, R5]
    868          }
   \   00000052   0xBC30             POP      {R4,R5}
   \   00000054   0x4770             BX       LR               ;; return
    869          
    870          //*****************************************************************************
    871          //
    872          //! \brief Get the wakeup pin flag of the specified index.
    873          //!
    874          //! \param ulPinIndex is the index of the wakeup pin.
    875          //!
    876          //! This function is to Get the wakeup pin flag of the specified index.
    877          //!
    878          //! \return This function return the wakeup source Flag,if it is the wakeup
    879          //!  source, it returns xtrue, xfalse if not.
    880          //
    881          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
    882          xtBoolean
    883          SysCtlWakeupPinFlagGet(unsigned long ulPinIndex)
    884          {
   \                     SysCtlWakeupPinFlagGet:
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0x0001             MOVS     R1,R0
    885              xtBoolean xtFlag = 0;
   \   00000004   0x2200             MOVS     R2,#+0
    886              xASSERT((ulPinIndex >= 0 && ulPinIndex <= 15));
    887          
    888              xtFlag = (xHWREGB(LLWU_F1+ulPinIndex/8) & (LLWU_F1_WUF0 << ulPinIndex));
   \   00000006   0x0008             MOVS     R0,R1
   \   00000008   0x08C0             LSRS     R0,R0,#+3
   \   0000000A   0x....             LDR      R3,??DataTable14_8  ;; 0x4007c005
   \   0000000C   0x5CC0             LDRB     R0,[R0, R3]
   \   0000000E   0x2301             MOVS     R3,#+1
   \   00000010   0x408B             LSLS     R3,R3,R1
   \   00000012   0x4003             ANDS     R3,R3,R0
   \   00000014   0x001A             MOVS     R2,R3
    889              if(xtFlag)
   \   00000016   0xB2D2             UXTB     R2,R2
   \   00000018   0x2A00             CMP      R2,#+0
   \   0000001A   0xD001             BEQ      ??SysCtlWakeupPinFlagGet_0
    890              {
    891                  return xtrue;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xE000             B        ??SysCtlWakeupPinFlagGet_1
    892              }
    893              else
    894              {
    895                  return xfalse;
   \                     ??SysCtlWakeupPinFlagGet_0:
   \   00000020   0x2000             MOVS     R0,#+0
   \                     ??SysCtlWakeupPinFlagGet_1:
   \   00000022   0xBD00             POP      {PC}             ;; return
    896              }
    897          }
    898          
    899          //*****************************************************************************
    900          //
    901          //! \brief Get the wakeup pin Filter flag of the specified index.
    902          //!
    903          //! \param ulFilterIndex is the index of the wakeup pin filter.
    904          //!
    905          //! This function is to Get the wakeup pin filter flag of the specified index.
    906          //!
    907          //! \return This function return the wakeup filter source Flag,if it is the wakeup
    908          //!  source, it returns xtrue, xfalse if not.
    909          //
    910          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
    911          xtBoolean
    912          SysCtlWakeupPinFilterFlagGet(unsigned long ulFilterIndex)
    913          {
   \                     SysCtlWakeupPinFilterFlagGet:
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0x0001             MOVS     R1,R0
    914              xtBoolean xtFlag = 0;
   \   00000004   0x2200             MOVS     R2,#+0
    915              xASSERT((ulFilterIndex >= 1 && ulFilterIndex <= 2));
    916          
    917              xtFlag = (xHWREGB(LLWU_FILT1+ulFilterIndex/2) & LLWU_FILT1_FILTSEL_FILTF);
   \   00000006   0x0008             MOVS     R0,R1
   \   00000008   0x0840             LSRS     R0,R0,#+1
   \   0000000A   0x....             LDR      R3,??DataTable14_7  ;; 0x4007c008
   \   0000000C   0x5CC0             LDRB     R0,[R0, R3]
   \   0000000E   0x2380             MOVS     R3,#+128
   \   00000010   0x4018             ANDS     R0,R0,R3
   \   00000012   0x0002             MOVS     R2,R0
    918              if(xtFlag)
   \   00000014   0xB2D2             UXTB     R2,R2
   \   00000016   0x2A00             CMP      R2,#+0
   \   00000018   0xD001             BEQ      ??SysCtlWakeupPinFilterFlagGet_0
    919              {
    920                  return xtrue;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xE000             B        ??SysCtlWakeupPinFilterFlagGet_1
    921              }
    922              else
    923              {
    924                  return xfalse;
   \                     ??SysCtlWakeupPinFilterFlagGet_0:
   \   0000001E   0x2000             MOVS     R0,#+0
   \                     ??SysCtlWakeupPinFilterFlagGet_1:
   \   00000020   0xBD00             POP      {PC}             ;; return
    925              }
    926          }
    927          //*****************************************************************************
    928          //
    929          //! \brief Get the wakeup Module flag of the specified index.
    930          //!
    931          //! \param ulModuleIndex is the index of the wakeup Module.
    932          //!
    933          //! This function is to Get the wakeup module flag of the specified index.
    934          //!
    935          //! \return This function return the wakeup source Flag,if it is the wakeup
    936          //!  source, it returns xtrue, xfalse if not.
    937          //
    938          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
    939          xtBoolean
    940          SysCtlWakeupModuleFlagGet(unsigned long ulModuleIndex)
    941          {
   \                     SysCtlWakeupModuleFlagGet:
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0x0001             MOVS     R1,R0
    942              xtBoolean xtFlag = 0;
   \   00000004   0x2200             MOVS     R2,#+0
    943              xASSERT((ulModuleIndex >= 0 && ulModuleIndex <= 7));
    944          
    945              xtFlag = (xHWREGB(LLWU_F3) & (LLWU_F3_MWUF0 << ulModuleIndex));
   \   00000006   0x....             LDR      R0,??DataTable14_9  ;; 0x4007c007
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2301             MOVS     R3,#+1
   \   0000000C   0x408B             LSLS     R3,R3,R1
   \   0000000E   0x4003             ANDS     R3,R3,R0
   \   00000010   0x001A             MOVS     R2,R3
    946              if(xtFlag)
   \   00000012   0xB2D2             UXTB     R2,R2
   \   00000014   0x2A00             CMP      R2,#+0
   \   00000016   0xD001             BEQ      ??SysCtlWakeupModuleFlagGet_0
    947              {
    948                  return xtrue;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xE000             B        ??SysCtlWakeupModuleFlagGet_1
    949              }
    950              else
    951              {
    952                  return xfalse;
   \                     ??SysCtlWakeupModuleFlagGet_0:
   \   0000001C   0x2000             MOVS     R0,#+0
   \                     ??SysCtlWakeupModuleFlagGet_1:
   \   0000001E   0xBD00             POP      {PC}             ;; return
    953              }
    954          }
    955          
    956          //*****************************************************************************
    957          //
    958          //! \brief Enables Wakeup Module or not.
    959          //!
    960          //! \param bEnable is a boolean that is \b true if Enable wakeup pin,
    961          //! \b false if not.
    962          //! \param ulModuleIndex is the index of the wakeup pin.
    963          //!
    964          //! This function is to Enable Wakeup Module or not.
    965          //!
    966          //! \return This function does not return.
    967          //
    968          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
    969          void
    970          SysCtlWakeupModuleEnable(xtBoolean bEnable, unsigned long ulModuleIndex)
    971          {
   \                     SysCtlWakeupModuleEnable:
   \   00000000   0xB510             PUSH     {R4,LR}
    972              xASSERT((ulModuleIndex >= 0 && ulModuleIndex <= 15));
    973          
    974              //
    975              // Enable wakeup module.
    976              //
    977              if(bEnable)
   \   00000002   0xB2C0             UXTB     R0,R0
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD00C             BEQ      ??SysCtlWakeupModuleEnable_0
    978              {
    979                  xHWREGB(LLWU_ME) &= 0x00;
   \   00000008   0x....             LDR      R2,??DataTable15  ;; 0x4007c004
   \   0000000A   0x7812             LDRB     R2,[R2, #+0]
   \   0000000C   0x....             LDR      R3,??DataTable15  ;; 0x4007c004
   \   0000000E   0x2400             MOVS     R4,#+0
   \   00000010   0x701C             STRB     R4,[R3, #+0]
    980                  xHWREGB(LLWU_ME) |= LLWU_ME_WUME0 << ulModuleIndex;
   \   00000012   0x....             LDR      R3,??DataTable15  ;; 0x4007c004
   \   00000014   0x781B             LDRB     R3,[R3, #+0]
   \   00000016   0x2401             MOVS     R4,#+1
   \   00000018   0x408C             LSLS     R4,R4,R1
   \   0000001A   0x431C             ORRS     R4,R4,R3
   \   0000001C   0x....             LDR      R3,??DataTable15  ;; 0x4007c004
   \   0000001E   0x701C             STRB     R4,[R3, #+0]
   \   00000020   0xE006             B        ??SysCtlWakeupModuleEnable_1
    981              }
    982              else
    983              {
    984                  xHWREGB(LLWU_ME) &= ~(LLWU_ME_WUME0 << ulModuleIndex);
   \                     ??SysCtlWakeupModuleEnable_0:
   \   00000022   0x....             LDR      R2,??DataTable15  ;; 0x4007c004
   \   00000024   0x7812             LDRB     R2,[R2, #+0]
   \   00000026   0x2301             MOVS     R3,#+1
   \   00000028   0x408B             LSLS     R3,R3,R1
   \   0000002A   0x439A             BICS     R2,R2,R3
   \   0000002C   0x....             LDR      R3,??DataTable15  ;; 0x4007c004
   \   0000002E   0x701A             STRB     R2,[R3, #+0]
    985              }
    986          }
   \                     ??SysCtlWakeupModuleEnable_1:
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    987          //*****************************************************************************
    988          //
    989          //! \brief Puts the processor into sleep mode.
    990          //!
    991          //! This function places the processor into sleep mode; it will not return
    992          //! until the processor returns to run mode.
    993          //!
    994          //! \return None.
    995          //
    996          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
    997          void
    998          SysCtlSleep(void)
    999          {
   \                     SysCtlSleep:
   \   00000000   0xB580             PUSH     {R7,LR}
   1000              //
   1001              // Clear the SLEEPDEEP bit to make sure we go into WAIT(sleep) mode 
   1002              // instead of deep sleep
   1003              //
   1004              xHWREG(SCB_SCR) &= ~SCB_SCR_SLEEPDEEP;
   \   00000002   0x....             LDR      R0,??DataTable16  ;; 0xe000e000
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2104             MOVS     R1,#+4
   \   00000008   0x4388             BICS     R0,R0,R1
   \   0000000A   0x....             LDR      R1,??DataTable16  ;; 0xe000e000
   \   0000000C   0x6008             STR      R0,[R1, #+0]
   1005              //
   1006              // WFI instruction will start entry into STOP mode
   1007              //
   1008              xCPUwfi();
   \   0000000E   0x.... 0x....      BL       xCPUwfi
   1009          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
   1010          
   1011          //*****************************************************************************
   1012          //
   1013          //! \brief Puts the processor into deep-sleep mode.
   1014          //!
   1015          //! This function places the processor into deep-sleep mode; it will not return
   1016          //! until the processor returns to run mode.
   1017          //!
   1018          //! \return None.
   1019          //
   1020          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   1021          void
   1022          SysCtlDeepSleep(void)
   1023          {
   \                     SysCtlDeepSleep:
   \   00000000   0xB580             PUSH     {R7,LR}
   1024              //
   1025              // Set the SLEEPDEEP bit to enable deep sleep mode(STOP).
   1026              //
   1027              xHWREG(SCB_SCR) |= SCB_SCR_SLEEPDEEP;
   \   00000002   0x....             LDR      R0,??DataTable16  ;; 0xe000e000
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2104             MOVS     R1,#+4
   \   00000008   0x4301             ORRS     R1,R1,R0
   \   0000000A   0x....             LDR      R0,??DataTable16  ;; 0xe000e000
   \   0000000C   0x6001             STR      R1,[R0, #+0]
   1028              
   1029              //
   1030              // WFI instruction will start entry into STOP mode
   1031              //
   1032              xCPUwfi();
   \   0000000E   0x.... 0x....      BL       xCPUwfi
   1033          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
   1034          
   1035          //*****************************************************************************
   1036          //
   1037          //! \brief Set a peripheral clock source.
   1038          //!
   1039          //! \param ulPeripheralSrc is the peripheral clock source to set.
   1040          //!
   1041          //! Peripherals clock source are seted with this function.  At power-up, all 
   1042          //! Peripherals clock source are Peripherals clock source; they must be set in 
   1043          //! order to operate or respond to register reads/writes.
   1044          //!
   1045          //! The \e ulPeripheralSrc parameter must be only one of the following values:
   1046          //! \b SYSCTL_PERIPH_RTC_S_OSC32KCLK,  \b SYSCTL_PERIPH_RTC_S_RTC_CLKIN, 
   1047          //! \b SYSCTL_PERIPH_RTC_S_LPO,        \b SYSCTL_PERIPH_LPTMR_S_OSC32KCLK, 
   1048          //! \b SYSCTL_PERIPH_LPTMR_S_RTC_CLKIN,\b SYSCTL_PERIPH_LPTMR_S_LPO, 
   1049          //! \b SYSCTL_PERIPH_TPM_S_MCGFLLCLK,  \b SYSCTL_PERIPH_TPM_S_MCGPLLCLK_2, 
   1050          //! \b SYSCTL_PERIPH_TPM_S_OSCERCLK,   \b SYSCTL_PERIPH_TPM_S_MCGIRCLK, 
   1051          //! \b SYSCTL_PERIPH_UART0_S_MCGFLLCLK,\b SYSCTL_PERIPH_UART0_S_MCGPLLCLK_2,
   1052          //! \b SYSCTL_PERIPH_UART0_S_OSCERCLK, \b SYSCTL_PERIPH_UART0_S_MCGIRCLK, 
   1053          //! \b SYSCTL_PERIPH_USB_S_USB_CLKIN,  \b SYSCTL_PERIPH_USB_S_MCGPLLCLK_2, 
   1054          //! \b SYSCTL_PERIPH_USB_S_MCGFLLCLK,  \b SYSCTL_PERIPH_WDG_S_1K,
   1055          //! \b SYSCTL_PERIPH_WDG_S_BUS,        \b SYSCTL_PERIPH_ADC_S_BUSCLK,
   1056          //! \b SYSCTL_PERIPH_ADC_S_BUSCLK_2,   \b SYSCTL_PERIPH_ADC_S_ATCLK,
   1057          //! \b SYSCTL_PERIPH_ADC_S_ADACK.
   1058          //!
   1059          //! \return None.
   1060          //
   1061          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   1062          void
   1063          SysCtlPeripheralClockSourceSet(unsigned long ulPeripheralSrc)
   1064          {
   \                     SysCtlPeripheralClockSourceSet:
   \   00000000   0xB500             PUSH     {LR}
   1065              //
   1066              // Check the arguments.
   1067              //
   1068              xASSERT((ulPeripheralSrc == SYSCTL_PERIPH_RTC_S_OSC32KCLK) ||
   1069                      (ulPeripheralSrc == SYSCTL_PERIPH_RTC_S_RTC_CLKIN) ||
   1070                      (ulPeripheralSrc == SYSCTL_PERIPH_LPTMR_S_OSC32KCLK)||
   1071                      (ulPeripheralSrc == SYSCTL_PERIPH_LPTMR_S_RTC_CLKIN) ||
   1072                      (ulPeripheralSrc == SYSCTL_PERIPH_LPTMR_S_LPO) ||
   1073                      (ulPeripheralSrc == SYSCTL_PERIPH_RTC_S_LPO) ||
   1074                      (ulPeripheralSrc == SYSCTL_PERIPH_WDG_S_1K) ||
   1075                      (ulPeripheralSrc == SYSCTL_PERIPH_ADC_S_BUSCLK) ||
   1076                      (ulPeripheralSrc == SYSCTL_PERIPH_ADC_S_BUSCLK_2) ||
   1077                      (ulPeripheralSrc == SYSCTL_PERIPH_ADC_S_ATCLK) ||
   1078                      (ulPeripheralSrc == SYSCTL_PERIPH_ADC_S_ADACK) ||
   1079                      (ulPeripheralSrc == SYSCTL_PERIPH_TPM_S_MCGFLLCLK)||
   1080                      (ulPeripheralSrc == SYSCTL_PERIPH_TPM_S_MCGPLLCLK_2) ||
   1081                      (ulPeripheralSrc == SYSCTL_PERIPH_TPM_S_OSCERCLK) ||
   1082                      (ulPeripheralSrc == SYSCTL_PERIPH_TPM_S_MCGIRCLK)||
   1083                      (ulPeripheralSrc == SYSCTL_PERIPH_UART0_S_MCGFLLCLK) ||
   1084                      (ulPeripheralSrc == SYSCTL_PERIPH_UART0_S_MCGPLLCLK_2) ||
   1085                      (ulPeripheralSrc == SYSCTL_PERIPH_UART0_S_OSCERCLK) ||
   1086                      (ulPeripheralSrc == SYSCTL_PERIPH_UART0_S_MCGIRCLK) ||
   1087                      (ulPeripheralSrc == SYSCTL_PERIPH_USB_S_USB_CLKIN) ||
   1088                      (ulPeripheralSrc == SYSCTL_PERIPH_USB_S_MCGPLLCLK_2) ||
   1089                      (ulPeripheralSrc == SYSCTL_PERIPH_USB_S_MCGFLLCLK) ||
   1090                      (ulPeripheralSrc == SYSCTL_PERIPH_WDG_S_BUS));
   1091          
   1092              //
   1093              // Set this peripheral clock source
   1094              //
   1095              if(ulPeripheralSrc == SYSCTL_PERIPH_RTC_S_OSC32KCLK)
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD10A             BNE      ??SysCtlPeripheralClockSourceSet_0
   1096              {
   1097                  xHWREG(SIM_SOPT1) &= ~SIM_SOPT1_OSC32KSEL_M;
   \   00000006   0x....             LDR      R1,??DataTable16_1  ;; 0x40047000
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x....             LDR      R2,??DataTable16_2  ;; 0xfff3ffff
   \   0000000C   0x400A             ANDS     R2,R2,R1
   \   0000000E   0x....             LDR      R1,??DataTable16_1  ;; 0x40047000
   \   00000010   0x600A             STR      R2,[R1, #+0]
   1098                  xHWREG(SIM_SOPT1) |= SIM_SOPT1_OSC32KSEL_OSC32KCLK;
   \   00000012   0x....             LDR      R1,??DataTable16_1  ;; 0x40047000
   \   00000014   0x....             LDR      R2,??DataTable16_1  ;; 0x40047000
   \   00000016   0x6812             LDR      R2,[R2, #+0]
   \   00000018   0x600A             STR      R2,[R1, #+0]
   \   0000001A   0xE149             B        ??SysCtlPeripheralClockSourceSet_1
   1099              }
   1100              else if(ulPeripheralSrc == SYSCTL_PERIPH_RTC_S_RTC_CLKIN)
   \                     ??SysCtlPeripheralClockSourceSet_0:
   \   0000001C   0x2180             MOVS     R1,#+128
   \   0000001E   0x0249             LSLS     R1,R1,#+9        ;; #+65536
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xD10D             BNE      ??SysCtlPeripheralClockSourceSet_2
   1101              {
   1102                  xHWREG(SIM_SOPT1) &= ~SIM_SOPT1_OSC32KSEL_M;
   \   00000024   0x....             LDR      R1,??DataTable16_1  ;; 0x40047000
   \   00000026   0x6809             LDR      R1,[R1, #+0]
   \   00000028   0x....             LDR      R2,??DataTable16_2  ;; 0xfff3ffff
   \   0000002A   0x400A             ANDS     R2,R2,R1
   \   0000002C   0x....             LDR      R1,??DataTable16_1  ;; 0x40047000
   \   0000002E   0x600A             STR      R2,[R1, #+0]
   1103                  xHWREG(SIM_SOPT1) |= SIM_SOPT1_OSC32KSEL_RTC_CLKIN;
   \   00000030   0x....             LDR      R1,??DataTable16_1  ;; 0x40047000
   \   00000032   0x6809             LDR      R1,[R1, #+0]
   \   00000034   0x2280             MOVS     R2,#+128
   \   00000036   0x0312             LSLS     R2,R2,#+12       ;; #+524288
   \   00000038   0x430A             ORRS     R2,R2,R1
   \   0000003A   0x....             LDR      R1,??DataTable16_1  ;; 0x40047000
   \   0000003C   0x600A             STR      R2,[R1, #+0]
   \   0000003E   0xE137             B        ??SysCtlPeripheralClockSourceSet_1
   1104              }
   1105              else if(ulPeripheralSrc == SYSCTL_PERIPH_RTC_S_LPO)
   \                     ??SysCtlPeripheralClockSourceSet_2:
   \   00000040   0x21C0             MOVS     R1,#+192
   \   00000042   0x0309             LSLS     R1,R1,#+12       ;; #+786432
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xD10D             BNE      ??SysCtlPeripheralClockSourceSet_3
   1106              {
   1107                  xHWREG(SIM_SOPT1) &= ~SIM_SOPT1_OSC32KSEL_M;
   \   00000048   0x....             LDR      R1,??DataTable16_1  ;; 0x40047000
   \   0000004A   0x6809             LDR      R1,[R1, #+0]
   \   0000004C   0x....             LDR      R2,??DataTable16_2  ;; 0xfff3ffff
   \   0000004E   0x400A             ANDS     R2,R2,R1
   \   00000050   0x....             LDR      R1,??DataTable16_1  ;; 0x40047000
   \   00000052   0x600A             STR      R2,[R1, #+0]
   1108                  xHWREG(SIM_SOPT1) |= SIM_SOPT1_OSC32KSEL_LPO;
   \   00000054   0x....             LDR      R1,??DataTable16_1  ;; 0x40047000
   \   00000056   0x6809             LDR      R1,[R1, #+0]
   \   00000058   0x22C0             MOVS     R2,#+192
   \   0000005A   0x0312             LSLS     R2,R2,#+12       ;; #+786432
   \   0000005C   0x430A             ORRS     R2,R2,R1
   \   0000005E   0x....             LDR      R1,??DataTable16_1  ;; 0x40047000
   \   00000060   0x600A             STR      R2,[R1, #+0]
   \   00000062   0xE125             B        ??SysCtlPeripheralClockSourceSet_1
   1109              }
   1110              else if(ulPeripheralSrc == SYSCTL_PERIPH_ADC_S_BUSCLK)
   \                     ??SysCtlPeripheralClockSourceSet_3:
   \   00000064   0x21CC             MOVS     R1,#+204
   \   00000066   0x0609             LSLS     R1,R1,#+24       ;; #-872415232
   \   00000068   0x4288             CMP      R0,R1
   \   0000006A   0xD106             BNE      ??SysCtlPeripheralClockSourceSet_4
   1111              {
   1112                  xHWREG(ADC_BASE + ADC0_CFG1) &= ~ADC0_CFG1_ADICLK_M;
   \   0000006C   0x....             LDR      R1,??DataTable18  ;; 0x4003b008
   \   0000006E   0x6809             LDR      R1,[R1, #+0]
   \   00000070   0x2203             MOVS     R2,#+3
   \   00000072   0x4391             BICS     R1,R1,R2
   \   00000074   0x....             LDR      R2,??DataTable18  ;; 0x4003b008
   \   00000076   0x6011             STR      R1,[R2, #+0]
   \   00000078   0xE11A             B        ??SysCtlPeripheralClockSourceSet_1
   1113              }
   1114              else if(ulPeripheralSrc == SYSCTL_PERIPH_ADC_S_BUSCLK_2)
   \                     ??SysCtlPeripheralClockSourceSet_4:
   \   0000007A   0x21CD             MOVS     R1,#+205
   \   0000007C   0x0609             LSLS     R1,R1,#+24       ;; #-855638016
   \   0000007E   0x4288             CMP      R0,R1
   \   00000080   0xD10C             BNE      ??SysCtlPeripheralClockSourceSet_5
   1115              {
   1116                  xHWREG(ADC_BASE + ADC0_CFG1) &= ~ADC0_CFG1_ADICLK_M;
   \   00000082   0x....             LDR      R1,??DataTable18  ;; 0x4003b008
   \   00000084   0x6809             LDR      R1,[R1, #+0]
   \   00000086   0x2203             MOVS     R2,#+3
   \   00000088   0x4391             BICS     R1,R1,R2
   \   0000008A   0x....             LDR      R2,??DataTable18  ;; 0x4003b008
   \   0000008C   0x6011             STR      R1,[R2, #+0]
   1117                  xHWREG(ADC_BASE + ADC0_CFG1) |= ADC0_CFG1_ADICLK_BUSCLK_2;
   \   0000008E   0x....             LDR      R1,??DataTable18  ;; 0x4003b008
   \   00000090   0x6809             LDR      R1,[R1, #+0]
   \   00000092   0x2201             MOVS     R2,#+1
   \   00000094   0x430A             ORRS     R2,R2,R1
   \   00000096   0x....             LDR      R1,??DataTable18  ;; 0x4003b008
   \   00000098   0x600A             STR      R2,[R1, #+0]
   \   0000009A   0xE109             B        ??SysCtlPeripheralClockSourceSet_1
   1118              }
   1119              else if(ulPeripheralSrc == SYSCTL_PERIPH_ADC_S_ATCLK)
   \                     ??SysCtlPeripheralClockSourceSet_5:
   \   0000009C   0x21CE             MOVS     R1,#+206
   \   0000009E   0x0609             LSLS     R1,R1,#+24       ;; #-838860800
   \   000000A0   0x4288             CMP      R0,R1
   \   000000A2   0xD10C             BNE      ??SysCtlPeripheralClockSourceSet_6
   1120              {
   1121                  xHWREG(ADC_BASE + ADC0_CFG1) &= ~ADC0_CFG1_ADICLK_M;
   \   000000A4   0x....             LDR      R1,??DataTable18  ;; 0x4003b008
   \   000000A6   0x6809             LDR      R1,[R1, #+0]
   \   000000A8   0x2203             MOVS     R2,#+3
   \   000000AA   0x4391             BICS     R1,R1,R2
   \   000000AC   0x....             LDR      R2,??DataTable18  ;; 0x4003b008
   \   000000AE   0x6011             STR      R1,[R2, #+0]
   1122                  xHWREG(ADC_BASE + ADC0_CFG1) |= ADC0_CFG1_ADICLK_ALTCLK;
   \   000000B0   0x....             LDR      R1,??DataTable18  ;; 0x4003b008
   \   000000B2   0x6809             LDR      R1,[R1, #+0]
   \   000000B4   0x2202             MOVS     R2,#+2
   \   000000B6   0x430A             ORRS     R2,R2,R1
   \   000000B8   0x....             LDR      R1,??DataTable18  ;; 0x4003b008
   \   000000BA   0x600A             STR      R2,[R1, #+0]
   \   000000BC   0xE0F8             B        ??SysCtlPeripheralClockSourceSet_1
   1123              }
   1124              else if(ulPeripheralSrc == SYSCTL_PERIPH_ADC_S_ADACK)
   \                     ??SysCtlPeripheralClockSourceSet_6:
   \   000000BE   0x21CF             MOVS     R1,#+207
   \   000000C0   0x0609             LSLS     R1,R1,#+24       ;; #-822083584
   \   000000C2   0x4288             CMP      R0,R1
   \   000000C4   0xD10C             BNE      ??SysCtlPeripheralClockSourceSet_7
   1125              {
   1126                  xHWREG(ADC_BASE + ADC0_CFG1) &= ~ADC0_CFG1_ADICLK_M;
   \   000000C6   0x....             LDR      R1,??DataTable18  ;; 0x4003b008
   \   000000C8   0x6809             LDR      R1,[R1, #+0]
   \   000000CA   0x2203             MOVS     R2,#+3
   \   000000CC   0x4391             BICS     R1,R1,R2
   \   000000CE   0x....             LDR      R2,??DataTable18  ;; 0x4003b008
   \   000000D0   0x6011             STR      R1,[R2, #+0]
   1127                  xHWREG(ADC_BASE + ADC0_CFG1) |= ADC0_CFG1_ADICLK_ADACK;
   \   000000D2   0x....             LDR      R1,??DataTable18  ;; 0x4003b008
   \   000000D4   0x6809             LDR      R1,[R1, #+0]
   \   000000D6   0x2203             MOVS     R2,#+3
   \   000000D8   0x430A             ORRS     R2,R2,R1
   \   000000DA   0x....             LDR      R1,??DataTable18  ;; 0x4003b008
   \   000000DC   0x600A             STR      R2,[R1, #+0]
   \   000000DE   0xE0E7             B        ??SysCtlPeripheralClockSourceSet_1
   1128              }
   1129              else if(ulPeripheralSrc == SYSCTL_PERIPH_UART0_S_MCGFLLCLK)
   \                     ??SysCtlPeripheralClockSourceSet_7:
   \   000000E0   0x2180             MOVS     R1,#+128
   \   000000E2   0x04C9             LSLS     R1,R1,#+19       ;; #+67108864
   \   000000E4   0x4288             CMP      R0,R1
   \   000000E6   0xD113             BNE      ??SysCtlPeripheralClockSourceSet_8
   1130              {
   1131                  xHWREG(SIM_SOPT2) &= ~SIM_SOPT2_PLLFLLSEL;    
   \   000000E8   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   000000EA   0x6809             LDR      R1,[R1, #+0]
   \   000000EC   0x....             LDR      R2,??DataTable24  ;; 0xfffeffff
   \   000000EE   0x400A             ANDS     R2,R2,R1
   \   000000F0   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   000000F2   0x600A             STR      R2,[R1, #+0]
   1132                  xHWREG(SIM_SOPT2) &= ~SIM_SOPT2_UART0SRC_M;
   \   000000F4   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   000000F6   0x6809             LDR      R1,[R1, #+0]
   \   000000F8   0x....             LDR      R2,??DataTable23  ;; 0xf3ffffff
   \   000000FA   0x400A             ANDS     R2,R2,R1
   \   000000FC   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   000000FE   0x600A             STR      R2,[R1, #+0]
   1133                  xHWREG(SIM_SOPT2) |= SIM_SOPT2_UART0SRC_MCGXLL;
   \   00000100   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   00000102   0x6809             LDR      R1,[R1, #+0]
   \   00000104   0x2280             MOVS     R2,#+128
   \   00000106   0x04D2             LSLS     R2,R2,#+19       ;; #+67108864
   \   00000108   0x430A             ORRS     R2,R2,R1
   \   0000010A   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   0000010C   0x600A             STR      R2,[R1, #+0]
   \   0000010E   0xE0CF             B        ??SysCtlPeripheralClockSourceSet_1
   1134              }
   1135              else if(ulPeripheralSrc == SYSCTL_PERIPH_UART0_S_MCGPLLCLK_2)
   \                     ??SysCtlPeripheralClockSourceSet_8:
   \   00000110   0x21A4             MOVS     R1,#+164
   \   00000112   0x0609             LSLS     R1,R1,#+24       ;; #-1543503872
   \   00000114   0x4288             CMP      R0,R1
   \   00000116   0xD114             BNE      ??SysCtlPeripheralClockSourceSet_9
   1136              {
   1137                  xHWREG(SIM_SOPT2) |= SIM_SOPT2_PLLFLLSEL;    
   \   00000118   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   0000011A   0x6809             LDR      R1,[R1, #+0]
   \   0000011C   0x2280             MOVS     R2,#+128
   \   0000011E   0x0252             LSLS     R2,R2,#+9        ;; #+65536
   \   00000120   0x430A             ORRS     R2,R2,R1
   \   00000122   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   00000124   0x600A             STR      R2,[R1, #+0]
   1138                  xHWREG(SIM_SOPT2) &= ~SIM_SOPT2_UART0SRC_M;
   \   00000126   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   00000128   0x6809             LDR      R1,[R1, #+0]
   \   0000012A   0x....             LDR      R2,??DataTable23  ;; 0xf3ffffff
   \   0000012C   0x400A             ANDS     R2,R2,R1
   \   0000012E   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   00000130   0x600A             STR      R2,[R1, #+0]
   1139                  xHWREG(SIM_SOPT2) |= SIM_SOPT2_UART0SRC_MCGXLL;
   \   00000132   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   00000134   0x6809             LDR      R1,[R1, #+0]
   \   00000136   0x2280             MOVS     R2,#+128
   \   00000138   0x04D2             LSLS     R2,R2,#+19       ;; #+67108864
   \   0000013A   0x430A             ORRS     R2,R2,R1
   \   0000013C   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   0000013E   0x600A             STR      R2,[R1, #+0]
   \   00000140   0xE0B6             B        ??SysCtlPeripheralClockSourceSet_1
   1140              }
   1141              else if(ulPeripheralSrc == SYSCTL_PERIPH_UART0_S_OSCERCLK)
   \                     ??SysCtlPeripheralClockSourceSet_9:
   \   00000142   0x2180             MOVS     R1,#+128
   \   00000144   0x0509             LSLS     R1,R1,#+20       ;; #+134217728
   \   00000146   0x4288             CMP      R0,R1
   \   00000148   0xD10D             BNE      ??SysCtlPeripheralClockSourceSet_10
   1142              {
   1143                  xHWREG(SIM_SOPT2) &= ~SIM_SOPT2_UART0SRC_M;
   \   0000014A   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   0000014C   0x6809             LDR      R1,[R1, #+0]
   \   0000014E   0x....             LDR      R2,??DataTable23  ;; 0xf3ffffff
   \   00000150   0x400A             ANDS     R2,R2,R1
   \   00000152   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   00000154   0x600A             STR      R2,[R1, #+0]
   1144                  xHWREG(SIM_SOPT2) |= SIM_SOPT2_UART0SRC_OSCERCLK;
   \   00000156   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   00000158   0x6809             LDR      R1,[R1, #+0]
   \   0000015A   0x2280             MOVS     R2,#+128
   \   0000015C   0x0512             LSLS     R2,R2,#+20       ;; #+134217728
   \   0000015E   0x430A             ORRS     R2,R2,R1
   \   00000160   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   00000162   0x600A             STR      R2,[R1, #+0]
   \   00000164   0xE0A4             B        ??SysCtlPeripheralClockSourceSet_1
   1145              }
   1146              else if(ulPeripheralSrc == SYSCTL_PERIPH_UART0_S_MCGIRCLK)
   \                     ??SysCtlPeripheralClockSourceSet_10:
   \   00000166   0x21C0             MOVS     R1,#+192
   \   00000168   0x0509             LSLS     R1,R1,#+20       ;; #+201326592
   \   0000016A   0x4288             CMP      R0,R1
   \   0000016C   0xD10D             BNE      ??SysCtlPeripheralClockSourceSet_11
   1147              {
   1148                  xHWREG(SIM_SOPT2) &= ~SIM_SOPT2_UART0SRC_M;
   \   0000016E   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   00000170   0x6809             LDR      R1,[R1, #+0]
   \   00000172   0x....             LDR      R2,??DataTable23  ;; 0xf3ffffff
   \   00000174   0x400A             ANDS     R2,R2,R1
   \   00000176   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   00000178   0x600A             STR      R2,[R1, #+0]
   1149                  xHWREG(SIM_SOPT2) |= SIM_SOPT2_UART0SRC_MCGIRCLK;
   \   0000017A   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   0000017C   0x6809             LDR      R1,[R1, #+0]
   \   0000017E   0x22C0             MOVS     R2,#+192
   \   00000180   0x0512             LSLS     R2,R2,#+20       ;; #+201326592
   \   00000182   0x430A             ORRS     R2,R2,R1
   \   00000184   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   00000186   0x600A             STR      R2,[R1, #+0]
   \   00000188   0xE092             B        ??SysCtlPeripheralClockSourceSet_1
   1150              }
   1151              else if(ulPeripheralSrc == SYSCTL_PERIPH_TPM_S_MCGFLLCLK)
   \                     ??SysCtlPeripheralClockSourceSet_11:
   \   0000018A   0x2180             MOVS     R1,#+128
   \   0000018C   0x0449             LSLS     R1,R1,#+17       ;; #+16777216
   \   0000018E   0x4288             CMP      R0,R1
   \   00000190   0xD113             BNE      ??SysCtlPeripheralClockSourceSet_12
   1152              {
   1153                  xHWREG(SIM_SOPT2) &= ~SIM_SOPT2_PLLFLLSEL;  
   \   00000192   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   00000194   0x6809             LDR      R1,[R1, #+0]
   \   00000196   0x....             LDR      R2,??DataTable24  ;; 0xfffeffff
   \   00000198   0x400A             ANDS     R2,R2,R1
   \   0000019A   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   0000019C   0x600A             STR      R2,[R1, #+0]
   1154                  xHWREG(SIM_SOPT2) &= ~SIM_SOPT2_TPMSRC_M;
   \   0000019E   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   000001A0   0x6809             LDR      R1,[R1, #+0]
   \   000001A2   0x....             LDR      R2,??DataTable28  ;; 0xfcffffff
   \   000001A4   0x400A             ANDS     R2,R2,R1
   \   000001A6   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   000001A8   0x600A             STR      R2,[R1, #+0]
   1155                  xHWREG(SIM_SOPT2) |= SIM_SOPT2_TPMSRC_MCGXLL;
   \   000001AA   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   000001AC   0x6809             LDR      R1,[R1, #+0]
   \   000001AE   0x2280             MOVS     R2,#+128
   \   000001B0   0x0452             LSLS     R2,R2,#+17       ;; #+16777216
   \   000001B2   0x430A             ORRS     R2,R2,R1
   \   000001B4   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   000001B6   0x600A             STR      R2,[R1, #+0]
   \   000001B8   0xE07A             B        ??SysCtlPeripheralClockSourceSet_1
   1156              }
   1157              else if(ulPeripheralSrc == SYSCTL_PERIPH_TPM_S_MCGPLLCLK_2)
   \                     ??SysCtlPeripheralClockSourceSet_12:
   \   000001BA   0x21A1             MOVS     R1,#+161
   \   000001BC   0x0609             LSLS     R1,R1,#+24       ;; #-1593835520
   \   000001BE   0x4288             CMP      R0,R1
   \   000001C0   0xD114             BNE      ??SysCtlPeripheralClockSourceSet_13
   1158              {
   1159                  xHWREG(SIM_SOPT2)|= SIM_SOPT2_PLLFLLSEL;  
   \   000001C2   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   000001C4   0x6809             LDR      R1,[R1, #+0]
   \   000001C6   0x2280             MOVS     R2,#+128
   \   000001C8   0x0252             LSLS     R2,R2,#+9        ;; #+65536
   \   000001CA   0x430A             ORRS     R2,R2,R1
   \   000001CC   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   000001CE   0x600A             STR      R2,[R1, #+0]
   1160                  xHWREG(SIM_SOPT2) &= ~SIM_SOPT2_TPMSRC_M;
   \   000001D0   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   000001D2   0x6809             LDR      R1,[R1, #+0]
   \   000001D4   0x....             LDR      R2,??DataTable28  ;; 0xfcffffff
   \   000001D6   0x400A             ANDS     R2,R2,R1
   \   000001D8   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   000001DA   0x600A             STR      R2,[R1, #+0]
   1161                  xHWREG(SIM_SOPT2) |= SIM_SOPT2_TPMSRC_MCGXLL;
   \   000001DC   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   000001DE   0x6809             LDR      R1,[R1, #+0]
   \   000001E0   0x2280             MOVS     R2,#+128
   \   000001E2   0x0452             LSLS     R2,R2,#+17       ;; #+16777216
   \   000001E4   0x430A             ORRS     R2,R2,R1
   \   000001E6   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   000001E8   0x600A             STR      R2,[R1, #+0]
   \   000001EA   0xE061             B        ??SysCtlPeripheralClockSourceSet_1
   1162              }
   1163              else if(ulPeripheralSrc == SYSCTL_PERIPH_TPM_S_OSCERCLK)
   \                     ??SysCtlPeripheralClockSourceSet_13:
   \   000001EC   0x2180             MOVS     R1,#+128
   \   000001EE   0x0489             LSLS     R1,R1,#+18       ;; #+33554432
   \   000001F0   0x4288             CMP      R0,R1
   \   000001F2   0xD10D             BNE      ??SysCtlPeripheralClockSourceSet_14
   1164              {
   1165                  xHWREG(SIM_SOPT2) &= ~SIM_SOPT2_TPMSRC_M;
   \   000001F4   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   000001F6   0x6809             LDR      R1,[R1, #+0]
   \   000001F8   0x....             LDR      R2,??DataTable28  ;; 0xfcffffff
   \   000001FA   0x400A             ANDS     R2,R2,R1
   \   000001FC   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   000001FE   0x600A             STR      R2,[R1, #+0]
   1166                  xHWREG(SIM_SOPT2) |= SIM_SOPT2_TPMSRC_OSCERCLK;
   \   00000200   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   00000202   0x6809             LDR      R1,[R1, #+0]
   \   00000204   0x2280             MOVS     R2,#+128
   \   00000206   0x0492             LSLS     R2,R2,#+18       ;; #+33554432
   \   00000208   0x430A             ORRS     R2,R2,R1
   \   0000020A   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   0000020C   0x600A             STR      R2,[R1, #+0]
   \   0000020E   0xE04F             B        ??SysCtlPeripheralClockSourceSet_1
   1167              }
   1168              else if(ulPeripheralSrc == SYSCTL_PERIPH_TPM_S_MCGIRCLK)
   \                     ??SysCtlPeripheralClockSourceSet_14:
   \   00000210   0x21C0             MOVS     R1,#+192
   \   00000212   0x0489             LSLS     R1,R1,#+18       ;; #+50331648
   \   00000214   0x4288             CMP      R0,R1
   \   00000216   0xD10D             BNE      ??SysCtlPeripheralClockSourceSet_15
   1169              {
   1170                  xHWREG(SIM_SOPT2) &= ~SIM_SOPT2_TPMSRC_M;
   \   00000218   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   0000021A   0x6809             LDR      R1,[R1, #+0]
   \   0000021C   0x....             LDR      R2,??DataTable28  ;; 0xfcffffff
   \   0000021E   0x400A             ANDS     R2,R2,R1
   \   00000220   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   00000222   0x600A             STR      R2,[R1, #+0]
   1171                  xHWREG(SIM_SOPT2) |= SIM_SOPT2_TPMSRC_MCGIRCLK;
   \   00000224   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   00000226   0x6809             LDR      R1,[R1, #+0]
   \   00000228   0x22C0             MOVS     R2,#+192
   \   0000022A   0x0492             LSLS     R2,R2,#+18       ;; #+50331648
   \   0000022C   0x430A             ORRS     R2,R2,R1
   \   0000022E   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   00000230   0x600A             STR      R2,[R1, #+0]
   \   00000232   0xE03D             B        ??SysCtlPeripheralClockSourceSet_1
   1172              }
   1173              else if(ulPeripheralSrc == SYSCTL_PERIPH_USB_S_USB_CLKIN)
   \                     ??SysCtlPeripheralClockSourceSet_15:
   \   00000234   0x21B0             MOVS     R1,#+176
   \   00000236   0x0609             LSLS     R1,R1,#+24       ;; #-1342177280
   \   00000238   0x4288             CMP      R0,R1
   \   0000023A   0xD106             BNE      ??SysCtlPeripheralClockSourceSet_16
   1174              {
   1175                  xHWREG(SIM_SOPT2) &= ~SIM_SOPT2_USBSRC;
   \   0000023C   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   0000023E   0x6809             LDR      R1,[R1, #+0]
   \   00000240   0x....             LDR      R2,??DataTable31  ;; 0xfffbffff
   \   00000242   0x400A             ANDS     R2,R2,R1
   \   00000244   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   00000246   0x600A             STR      R2,[R1, #+0]
   \   00000248   0xE032             B        ??SysCtlPeripheralClockSourceSet_1
   1176              }
   1177              else if(ulPeripheralSrc == SYSCTL_PERIPH_USB_S_MCGFLLCLK)
   \                     ??SysCtlPeripheralClockSourceSet_16:
   \   0000024A   0x....             LDR      R1,??DataTable31_1  ;; 0xc0700
   \   0000024C   0x4288             CMP      R0,R1
   \   0000024E   0xD10D             BNE      ??SysCtlPeripheralClockSourceSet_17
   1178              {
   1179                  xHWREG(SIM_SOPT2) &= ~SIM_SOPT2_PLLFLLSEL; 
   \   00000250   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   00000252   0x6809             LDR      R1,[R1, #+0]
   \   00000254   0x....             LDR      R2,??DataTable24  ;; 0xfffeffff
   \   00000256   0x400A             ANDS     R2,R2,R1
   \   00000258   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   0000025A   0x600A             STR      R2,[R1, #+0]
   1180                  xHWREG(SIM_SOPT2) |= SIM_SOPT2_USBSRC;
   \   0000025C   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   0000025E   0x6809             LDR      R1,[R1, #+0]
   \   00000260   0x2280             MOVS     R2,#+128
   \   00000262   0x02D2             LSLS     R2,R2,#+11       ;; #+262144
   \   00000264   0x430A             ORRS     R2,R2,R1
   \   00000266   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   00000268   0x600A             STR      R2,[R1, #+0]
   \   0000026A   0xE021             B        ??SysCtlPeripheralClockSourceSet_1
   1181              }
   1182              else if(ulPeripheralSrc == SYSCTL_PERIPH_USB_S_MCGPLLCLK_2)
   \                     ??SysCtlPeripheralClockSourceSet_17:
   \   0000026C   0x....             LDR      R1,??DataTable31_2  ;; 0x80704
   \   0000026E   0x4288             CMP      R0,R1
   \   00000270   0xD10E             BNE      ??SysCtlPeripheralClockSourceSet_18
   1183              {
   1184                  xHWREG(SIM_SOPT2) |= SIM_SOPT2_PLLFLLSEL; 
   \   00000272   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   00000274   0x6809             LDR      R1,[R1, #+0]
   \   00000276   0x2280             MOVS     R2,#+128
   \   00000278   0x0252             LSLS     R2,R2,#+9        ;; #+65536
   \   0000027A   0x430A             ORRS     R2,R2,R1
   \   0000027C   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   0000027E   0x600A             STR      R2,[R1, #+0]
   1185                  xHWREG(SIM_SOPT2) |= SIM_SOPT2_USBSRC;
   \   00000280   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   00000282   0x6809             LDR      R1,[R1, #+0]
   \   00000284   0x2280             MOVS     R2,#+128
   \   00000286   0x02D2             LSLS     R2,R2,#+11       ;; #+262144
   \   00000288   0x430A             ORRS     R2,R2,R1
   \   0000028A   0x....             LDR      R1,??DataTable25  ;; 0x40048004
   \   0000028C   0x600A             STR      R2,[R1, #+0]
   \   0000028E   0xE00F             B        ??SysCtlPeripheralClockSourceSet_1
   1186              }
   1187              else if(ulPeripheralSrc == SYSCTL_PERIPH_WDG_S_1K)
   \                     ??SysCtlPeripheralClockSourceSet_18:
   \   00000290   0x....             LDR      R1,??DataTable31_3  ;; 0xc0701
   \   00000292   0x4288             CMP      R0,R1
   \   00000294   0xD106             BNE      ??SysCtlPeripheralClockSourceSet_19
   1188              {
   1189                  xHWREG(SIM_COPC ) &= ~SIM_COPC_COPCLKS;
   \   00000296   0x....             LDR      R1,??DataTable31_4  ;; 0x40048100
   \   00000298   0x6809             LDR      R1,[R1, #+0]
   \   0000029A   0x2202             MOVS     R2,#+2
   \   0000029C   0x4391             BICS     R1,R1,R2
   \   0000029E   0x....             LDR      R2,??DataTable31_4  ;; 0x40048100
   \   000002A0   0x6011             STR      R1,[R2, #+0]
   \   000002A2   0xE005             B        ??SysCtlPeripheralClockSourceSet_1
   1190              }
   1191              else
   1192              {
   1193                  xHWREG(SIM_COPC ) |= SIM_COPC_COPCLKS;
   \                     ??SysCtlPeripheralClockSourceSet_19:
   \   000002A4   0x....             LDR      R1,??DataTable31_4  ;; 0x40048100
   \   000002A6   0x6809             LDR      R1,[R1, #+0]
   \   000002A8   0x2202             MOVS     R2,#+2
   \   000002AA   0x430A             ORRS     R2,R2,R1
   \   000002AC   0x....             LDR      R1,??DataTable31_4  ;; 0x40048100
   \   000002AE   0x600A             STR      R2,[R1, #+0]
   1194              }
   1195          }
   \                     ??SysCtlPeripheralClockSourceSet_1:
   \   000002B0   0xBD00             POP      {PC}             ;; return
   1196          
   1197          //*****************************************************************************
   1198          //
   1199          //! \brief Set a HCLK clock source.
   1200          //!
   1201          //! \param ucHclkSrcSel is the HCLK clock source to set.
   1202          //!
   1203          //! The function is used to select HCLK clock source
   1204          //!
   1205          //! The \e ucHclkSrcSel parameter must be only one of the following values:
   1206          //! \b SYSCTL_HLCK_S_PLL, \b SYSCTL_HLCK_S_INT, \b SYSCTL_HLCK_S_MAIN.
   1207          //!
   1208          //! \return None.
   1209          //
   1210          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   1211          void
   1212          SysCtlHClockSourceSet(unsigned char ucHclkSrcSel)
   1213          {
   1214              //
   1215              // Check the arguments.
   1216              //
   1217              xASSERT((ucHclkSrcSel==SYSCTL_HLCK_S_MAIN) ||
   1218                      (ucHclkSrcSel==SYSCTL_HLCK_S_PLL) ||
   1219                      (ucHclkSrcSel==SYSCTL_HLCK_S_INT));
   1220          
   1221              xHWREGB(MCG_C1) &= ~MCG_C1_SRC_MCGOUTCLK_M;
   \                     SysCtlHClockSourceSet:
   \   00000000   0x....             LDR      R1,??DataTable31_5  ;; 0x40064000
   \   00000002   0x7809             LDRB     R1,[R1, #+0]
   \   00000004   0x0689             LSLS     R1,R1,#+26       ;; ZeroExtS R1,R1,#+26,#+26
   \   00000006   0x0E89             LSRS     R1,R1,#+26
   \   00000008   0x....             LDR      R2,??DataTable31_5  ;; 0x40064000
   \   0000000A   0x7011             STRB     R1,[R2, #+0]
   1222              xHWREGB(MCG_C1) |= ucHclkSrcSel;
   \   0000000C   0x....             LDR      R1,??DataTable31_5  ;; 0x40064000
   \   0000000E   0x7809             LDRB     R1,[R1, #+0]
   \   00000010   0x4301             ORRS     R1,R1,R0
   \   00000012   0x....             LDR      R2,??DataTable31_5  ;; 0x40064000
   \   00000014   0x7011             STRB     R1,[R2, #+0]
   1223          }
   \   00000016   0x4770             BX       LR               ;; return
   1224          
   1225          //*****************************************************************************
   1226          //
   1227          //! \brief The function is used to Get reset source from last operation
   1228          //!
   1229          //! \param None.
   1230          //!
   1231          //! The function is used to Get reset source from last operation
   1232          //!
   1233          //! \return Reset source enumerated as a bit field of
   1234          //! \b SYSCTL_RSTSRC_POR, \b SYSCTL_RSTSRC_PAD, \b SYSCTL_RSTSRC_WDG,
   1235          //! \b SYSCTL_RSTSRC_LOL, \b SYSCTL_RSTSRC_LOC, \b SYSCTL_RSTSRC_LVD, 
   1236          //! \b SYSCTL_RSTSRC_WAKEUP, \b SYSCTL_RSTSRC_SACKERR, \b SYSCTL_RSTSRC_MDM_AP
   1237          //! \b SYSCTL_RSTSRC_SW, and \b SYSCTL_RSTSRC_LOCKUP.
   1238          //
   1239          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   1240          unsigned long 
   1241          SysCtlResetSrcGet(void)
   1242          {
   \                     SysCtlResetSrcGet:
   \   00000000   0xB500             PUSH     {LR}
   1243              
   1244              unsigned long ulResetSrc = 0;
   \   00000002   0x2100             MOVS     R1,#+0
   1245              //
   1246              // Get reset source from last operation.
   1247              //
   1248              if((xHWREGB(RCM_SRS0)&SYSCTL_RSTSRC_PAD))
   \   00000004   0x....             LDR      R0,??DataTable31_6  ;; 0x4007f000
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x0640             LSLS     R0,R0,#+25
   \   0000000A   0xD501             BPL      ??SysCtlResetSrcGet_0
   1249              {
   1250                  return SYSCTL_RSTSRC_PAD;
   \   0000000C   0x2040             MOVS     R0,#+64
   \   0000000E   0xE01B             B        ??SysCtlResetSrcGet_1
   1251              }
   1252              if((xHWREGB(RCM_SRS0)&SYSCTL_RSTSRC_LOC))
   \                     ??SysCtlResetSrcGet_0:
   \   00000010   0x....             LDR      R0,??DataTable31_6  ;; 0x4007f000
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x0740             LSLS     R0,R0,#+29
   \   00000016   0xD501             BPL      ??SysCtlResetSrcGet_2
   1253              {
   1254                  return SYSCTL_RSTSRC_LOC;
   \   00000018   0x2004             MOVS     R0,#+4
   \   0000001A   0xE015             B        ??SysCtlResetSrcGet_1
   1255              }
   1256              if((xHWREGB(RCM_SRS0)&SYSCTL_RSTSRC_LOL))
   \                     ??SysCtlResetSrcGet_2:
   \   0000001C   0x....             LDR      R0,??DataTable31_6  ;; 0x4007f000
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x0700             LSLS     R0,R0,#+28
   \   00000022   0xD501             BPL      ??SysCtlResetSrcGet_3
   1257              {
   1258                  return SYSCTL_RSTSRC_LOL;
   \   00000024   0x2008             MOVS     R0,#+8
   \   00000026   0xE00F             B        ??SysCtlResetSrcGet_1
   1259              }
   1260              if((xHWREGB(RCM_SRS0)&SYSCTL_RSTSRC_WDG))
   \                     ??SysCtlResetSrcGet_3:
   \   00000028   0x....             LDR      R0,??DataTable31_6  ;; 0x4007f000
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0x0680             LSLS     R0,R0,#+26
   \   0000002E   0xD501             BPL      ??SysCtlResetSrcGet_4
   1261              {
   1262                  return SYSCTL_RSTSRC_WDG;
   \   00000030   0x2020             MOVS     R0,#+32
   \   00000032   0xE009             B        ??SysCtlResetSrcGet_1
   1263              }
   1264              else
   1265              {
   1266                  ulResetSrc = xHWREGB(RCM_SRS0);
   \                     ??SysCtlResetSrcGet_4:
   \   00000034   0x....             LDR      R0,??DataTable31_6  ;; 0x4007f000
   \   00000036   0x7800             LDRB     R0,[R0, #+0]
   \   00000038   0xB2C0             UXTB     R0,R0
   \   0000003A   0x0001             MOVS     R1,R0
   1267                  ulResetSrc = ulResetSrc | xHWREGB(RCM_SRS1);
   \   0000003C   0x000A             MOVS     R2,R1
   \   0000003E   0x....             LDR      R0,??DataTable31_7  ;; 0x4007f001
   \   00000040   0x7801             LDRB     R1,[R0, #+0]
   \   00000042   0xB2C9             UXTB     R1,R1
   \   00000044   0x4311             ORRS     R1,R1,R2
   1268                  return ulResetSrc;
   \   00000046   0x0008             MOVS     R0,R1
   \                     ??SysCtlResetSrcGet_1:
   \   00000048   0xBD00             POP      {PC}             ;; return
   1269              }
   1270          }
   1271          
   1272          //*****************************************************************************
   1273          //
   1274          //! \brief The function is used to Get The Current Power Mode
   1275          //!
   1276          //! \param None.
   1277          //!
   1278          //! The function is used to The Current Power Mode
   1279          //!
   1280          //! \return Reset source enumerated as a bit field of
   1281          //! \b SYSCTL_POWER_MODE_RUN,  \b SYSCTL_POWER_MODE_STOP, 
   1282          //! \b SYSCTL_POWER_MODE_VLPR, \b SYSCTL_POWER_MODE_VLPW,
   1283          //! \b SYSCTL_POWER_MODE_VLPS, \b SYSCTL_POWER_MODE_LLS, SYSCTL_POWER_MODE_VLLS
   1284          //
   1285          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   1286          unsigned long 
   1287          SysCtlPowerModeGet(void)
   1288          {
   1289              //
   1290              // Get The Current Power Mode.
   1291              //
   1292              return (xHWREGB(SMC_PMSTAT)&SMC_PMSTAT_PMSTAT_M);
   \                     SysCtlPowerModeGet:
   \   00000000   0x....             LDR      R0,??DataTable31_8  ;; 0x4007e003
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0xB2C0             UXTB     R0,R0
   \   00000006   0x0640             LSLS     R0,R0,#+25       ;; ZeroExtS R0,R0,#+25,#+25
   \   00000008   0x0E40             LSRS     R0,R0,#+25
   \   0000000A   0x4770             BX       LR               ;; return
   1293          }
   1294          //*****************************************************************************
   1295          //
   1296          //! \brief The function is to Enable or Disbale Reset Pin Filter Select in Stop Mode 
   1297          //!
   1298          //! \param bEnable is a boolean that is \b true if Enable Reset Pin Filter Select
   1299          //! in Stop Mode, \b false if not.
   1300          //!
   1301          //! \return None.
   1302          //
   1303          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   1304          void 
   1305          SysCtlResetPinFilterStopModeEnable(xtBoolean bEnable)
   1306          {
   \                     SysCtlResetPinFilterStopModeEnable:
   \   00000000   0xB500             PUSH     {LR}
   1307              //
   1308              // Enable Reset Pin Filter Select in Stop Mode or not.
   1309              //
   1310              if(bEnable)
   \   00000002   0xB2C0             UXTB     R0,R0
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD006             BEQ      ??SysCtlResetPinFilterStopModeEnable_0
   1311              {
   1312                  xHWREGB(RCM_RPFC) |= RCM_RPFC_RSTFLTSRW_LPO;
   \   00000008   0x....             LDR      R1,??DataTable31_9  ;; 0x4007f004
   \   0000000A   0x7809             LDRB     R1,[R1, #+0]
   \   0000000C   0x2202             MOVS     R2,#+2
   \   0000000E   0x430A             ORRS     R2,R2,R1
   \   00000010   0x....             LDR      R1,??DataTable31_9  ;; 0x4007f004
   \   00000012   0x700A             STRB     R2,[R1, #+0]
   \   00000014   0xE005             B        ??SysCtlResetPinFilterStopModeEnable_1
   1313              }
   1314              else
   1315              {
   1316                  xHWREGB(RCM_RPFC) &= ~RCM_RPFC_RSTFLTSRW_LPO;
   \                     ??SysCtlResetPinFilterStopModeEnable_0:
   \   00000016   0x....             LDR      R1,??DataTable31_9  ;; 0x4007f004
   \   00000018   0x7809             LDRB     R1,[R1, #+0]
   \   0000001A   0x22FD             MOVS     R2,#+253
   \   0000001C   0x400A             ANDS     R2,R2,R1
   \   0000001E   0x....             LDR      R1,??DataTable31_9  ;; 0x4007f004
   \   00000020   0x700A             STRB     R2,[R1, #+0]
   1317              }
   1318          }
   \                     ??SysCtlResetPinFilterStopModeEnable_1:
   \   00000022   0xBD00             POP      {PC}             ;; return
   1319          
   1320          //*****************************************************************************
   1321          //
   1322          //! \brief The function is used to Selects the reset pin bus clock filter width
   1323          //!
   1324          //! \param ulBusClkWidth the volt will be Select.
   1325          //!
   1326          //! The function is used to Select Reset Pin Filter in Run and Wait Modes
   1327          //!
   1328          //! The \e ulFilter parameter must be only one of the following values:1~32. 
   1329          //!
   1330          //! \return None.
   1331          //
   1332          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   1333          void 
   1334          SysCtlResetPinFilterBusClkWidthSet(unsigned char ulBusClkWidth)
   1335          {
   1336              //
   1337              // Check the arguments.
   1338              //
   1339              xASSERT((ulBusClkWidth > 0 && ulBusClkWidth <= 32));
   1340          
   1341              //
   1342              // Reset Pin Filter Bus Clock Select.
   1343              //
   1344              xHWREGB(RCM_RPFW) &= ~RCM_RPFW_RSTFLTSEL_M;
   \                     SysCtlResetPinFilterBusClkWidthSet:
   \   00000000   0x....             LDR      R1,??DataTable32  ;; 0x4007f005
   \   00000002   0x7809             LDRB     R1,[R1, #+0]
   \   00000004   0x22E0             MOVS     R2,#+224
   \   00000006   0x400A             ANDS     R2,R2,R1
   \   00000008   0x....             LDR      R1,??DataTable32  ;; 0x4007f005
   \   0000000A   0x700A             STRB     R2,[R1, #+0]
   1345              xHWREGB(RCM_RPFW) |= ulBusClkWidth;
   \   0000000C   0x....             LDR      R1,??DataTable32  ;; 0x4007f005
   \   0000000E   0x7809             LDRB     R1,[R1, #+0]
   \   00000010   0x4301             ORRS     R1,R1,R0
   \   00000012   0x....             LDR      R2,??DataTable32  ;; 0x4007f005
   \   00000014   0x7011             STRB     R1,[R2, #+0]
   1346          }
   \   00000016   0x4770             BX       LR               ;; return
   1347          
   1348          //*****************************************************************************
   1349          //
   1350          //! \brief The function is used to Select Reset Pin Filter in Run and Wait Modes.
   1351          //!
   1352          //! \param ulFilter the volt will be Select.
   1353          //!
   1354          //! The function is used to Select Reset Pin Filter in Run and Wait Modes
   1355          //!
   1356          //! The \e ulFilter parameter must be only one of the following values:
   1357          //! \b SYSCTL_RESET_PIN_FILTER_RUN_DIS, \b SYSCTL_RESET_PIN_FILTER_RUN_BUS, 
   1358          //! \b SYSCTL_RESET_PIN_FILTER_RUN_LPO. 
   1359          //!
   1360          //! \return None.
   1361          //
   1362          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   1363          void 
   1364          SysCtlResetPinFilterRunModeSelect(unsigned long ulFilter)
   1365          {
   1366              //
   1367              // Check the arguments.
   1368              //
   1369              xASSERT((ulFilter == SYSCTL_RESET_PIN_FILTER_RUN_DIS) ||
   1370                      (ulFilter == SYSCTL_RESET_PIN_FILTER_RUN_BUS) ||
   1371                      (ulFilter == SYSCTL_RESET_PIN_FILTER_RUN_LPO));
   1372              //
   1373              // Reset Pin Filter in Run and Wait Modes.
   1374              //
   1375              xHWREGB(RCM_RPFC) &= ~RCM_RPFC_RSTFLTSRW_M;
   \                     SysCtlResetPinFilterRunModeSelect:
   \   00000000   0x....             LDR      R1,??DataTable31_9  ;; 0x4007f004
   \   00000002   0x7809             LDRB     R1,[R1, #+0]
   \   00000004   0x22FC             MOVS     R2,#+252
   \   00000006   0x400A             ANDS     R2,R2,R1
   \   00000008   0x....             LDR      R1,??DataTable31_9  ;; 0x4007f004
   \   0000000A   0x700A             STRB     R2,[R1, #+0]
   1376              xHWREGB(RCM_RPFC) |= ulFilter;
   \   0000000C   0x....             LDR      R1,??DataTable31_9  ;; 0x4007f004
   \   0000000E   0x7809             LDRB     R1,[R1, #+0]
   \   00000010   0x0002             MOVS     R2,R0
   \   00000012   0x430A             ORRS     R2,R2,R1
   \   00000014   0x....             LDR      R1,??DataTable31_9  ;; 0x4007f004
   \   00000016   0x700A             STRB     R2,[R1, #+0]
   1377          }
   \   00000018   0x4770             BX       LR               ;; return
   1378          
   1379          //*****************************************************************************
   1380          //
   1381          //! \brief The function is used to Select Low-Voltage Detect Voltage.
   1382          //!
   1383          //! \param ulVoltage the volt will be Select.
   1384          //!
   1385          //! The function is used to Select Low-Voltage Detect Voltage.
   1386          //!
   1387          //! The \e ulVoltage parameter must be only one of the following values:
   1388          //! \b SYSCTL_LVD_DET_LOW, \b SYSCTL_LVD_DET_HIGH. 
   1389          //!
   1390          //! \return None.
   1391          //
   1392          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   1393          void 
   1394          SysCtlLVDVolSet(unsigned long ulVoltage)
   1395          {
   1396              //
   1397              // Check the arguments.
   1398              //
   1399              xASSERT((ulVoltage == SYSCTL_LVD_DET_LOW) ||
   1400                      (ulVoltage == SYSCTL_LVD_DET_HIGH));
   1401              //
   1402              // Select Low-Voltage Detect Voltage.
   1403              //
   1404              xHWREGB(PMC_LVDSC1) &= ~PMC_LVDSC1_LVDV_M;
   \                     SysCtlLVDVolSet:
   \   00000000   0x....             LDR      R1,??DataTable32_1  ;; 0x4007d000
   \   00000002   0x7809             LDRB     R1,[R1, #+0]
   \   00000004   0x22FC             MOVS     R2,#+252
   \   00000006   0x400A             ANDS     R2,R2,R1
   \   00000008   0x....             LDR      R1,??DataTable32_1  ;; 0x4007d000
   \   0000000A   0x700A             STRB     R2,[R1, #+0]
   1405              xHWREGB(PMC_LVDSC1) |= ulVoltage;
   \   0000000C   0x....             LDR      R1,??DataTable32_1  ;; 0x4007d000
   \   0000000E   0x7809             LDRB     R1,[R1, #+0]
   \   00000010   0x0002             MOVS     R2,R0
   \   00000012   0x430A             ORRS     R2,R2,R1
   \   00000014   0x....             LDR      R1,??DataTable32_1  ;; 0x4007d000
   \   00000016   0x700A             STRB     R2,[R1, #+0]
   1406          }
   \   00000018   0x4770             BX       LR               ;; return
   1407          
   1408          //*****************************************************************************
   1409          //
   1410          //! \brief The function is used to Select Low-Voltage Warning Voltage.
   1411          //!
   1412          //! \param ulVoltage the volt will be Select.
   1413          //!
   1414          //! The function is used to Select Low-Voltage Warning Voltage.
   1415          //!
   1416          //! The \e ulVoltage parameter must be only one of the following values:
   1417          //! \b SYSCTL_LVD_WARNING_LOW, \b SYSCTL_LVD_WARNING_MID1,
   1418          //! \b SYSCTL_LVD_WARNING_MID2, \b SYSCTL_LVD_WARNING_HIGH.
   1419          //!
   1420          //! \return None.
   1421          //
   1422          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   1423          void 
   1424          SysCtlLVDWarningVolSet(unsigned long ulVoltage)
   1425          {
   1426              //
   1427              // Check the arguments.
   1428              //
   1429              xASSERT((ulVoltage == SYSCTL_LVD_WARNING_LOW) ||
   1430                      (ulVoltage == SYSCTL_LVD_WARNING_MID1) ||
   1431                      (ulVoltage == SYSCTL_LVD_WARNING_MID2) ||
   1432                      (ulVoltage == SYSCTL_LVD_WARNING_HIGH));
   1433              //
   1434              // Select Low-Voltage Warning Voltage.
   1435              //
   1436              xHWREGB(PMC_LVDSC2) &= ~PMC_LVDSC2_LVWV_M;
   \                     SysCtlLVDWarningVolSet:
   \   00000000   0x....             LDR      R1,??DataTable32_2  ;; 0x4007d001
   \   00000002   0x7809             LDRB     R1,[R1, #+0]
   \   00000004   0x22FC             MOVS     R2,#+252
   \   00000006   0x400A             ANDS     R2,R2,R1
   \   00000008   0x....             LDR      R1,??DataTable32_2  ;; 0x4007d001
   \   0000000A   0x700A             STRB     R2,[R1, #+0]
   1437              xHWREGB(PMC_LVDSC2) |= ulVoltage;
   \   0000000C   0x....             LDR      R1,??DataTable32_2  ;; 0x4007d001
   \   0000000E   0x7809             LDRB     R1,[R1, #+0]
   \   00000010   0x0002             MOVS     R2,R0
   \   00000012   0x430A             ORRS     R2,R2,R1
   \   00000014   0x....             LDR      R1,??DataTable32_2  ;; 0x4007d001
   \   00000016   0x700A             STRB     R2,[R1, #+0]
   1438          }
   \   00000018   0x4770             BX       LR               ;; return
   1439          
   1440          //*****************************************************************************
   1441          //
   1442          //! \brief Get Low-Voltage Detect Flag.
   1443          //!
   1444          //! \param None.
   1445          //!
   1446          //! This function is to Get Low-Voltage Detect Flag
   1447          //!
   1448          //! \return This function return the LVD Detect Flag,if a low-voltage detect
   1449          //! event happens, it returns xtrue, xfalse if not.
   1450          //
   1451          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   1452          xtBoolean
   1453          SysCtlLVDEventFlagGet(void)
   1454          {
   \                     SysCtlLVDEventFlagGet:
   \   00000000   0xB500             PUSH     {LR}
   1455              xtBoolean xtFlag = 0;
   \   00000002   0x2100             MOVS     R1,#+0
   1456          
   1457              xtFlag = xHWREGB(PMC_LVDSC1) & PMC_LVDSC1_LVDF;
   \   00000004   0x....             LDR      R0,??DataTable32_1  ;; 0x4007d000
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2280             MOVS     R2,#+128
   \   0000000A   0x4010             ANDS     R0,R0,R2
   \   0000000C   0x0001             MOVS     R1,R0
   1458              if(xtFlag)
   \   0000000E   0xB2C9             UXTB     R1,R1
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD001             BEQ      ??SysCtlLVDEventFlagGet_0
   1459              {
   1460                  return xtrue;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xE000             B        ??SysCtlLVDEventFlagGet_1
   1461              }
   1462              else
   1463              {
   1464                  return xfalse;
   \                     ??SysCtlLVDEventFlagGet_0:
   \   00000018   0x2000             MOVS     R0,#+0
   \                     ??SysCtlLVDEventFlagGet_1:
   \   0000001A   0xBD00             POP      {PC}             ;; return
   1465              }
   1466          }
   1467          
   1468          //*****************************************************************************
   1469          //
   1470          //! \brief Clear Low-Voltage Detect Flag.
   1471          //!
   1472          //! \param None.
   1473          //!
   1474          //! This function is to Clear Low-Voltage Detect Flag
   1475          //!
   1476          //! \return None.
   1477          //
   1478          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   1479          void
   1480          SysCtlLVDEventFlagClear(void)
   1481          {
   1482              xHWREGB(PMC_LVDSC1) |= PMC_LVDSC1_LVDACK;
   \                     SysCtlLVDEventFlagClear:
   \   00000000   0x....             LDR      R0,??DataTable32_1  ;; 0x4007d000
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x2140             MOVS     R1,#+64
   \   00000006   0x4301             ORRS     R1,R1,R0
   \   00000008   0x....             LDR      R0,??DataTable32_1  ;; 0x4007d000
   \   0000000A   0x7001             STRB     R1,[R0, #+0]
   1483          }
   \   0000000C   0x4770             BX       LR               ;; return
   1484          
   1485          //*****************************************************************************
   1486          //
   1487          //! \brief Get Low-Voltage Warning Flag.
   1488          //!
   1489          //! \param None.
   1490          //!
   1491          //! This function is to Get Low-Voltage Warning Flag
   1492          //!
   1493          //! \return This function return LVD Warning Flag,if a low-voltage Warning
   1494          //! event happens, it returns xtrue, xfalse if not.
   1495          //
   1496          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   1497          xtBoolean
   1498          SysCtlLVDWaringFlagGet(void)
   1499          {
   \                     SysCtlLVDWaringFlagGet:
   \   00000000   0xB500             PUSH     {LR}
   1500              xtBoolean xtFlag = 0;
   \   00000002   0x2100             MOVS     R1,#+0
   1501          
   1502              xtFlag = xHWREGB(PMC_LVDSC2) & PMC_LVDSC2_LVWF;
   \   00000004   0x....             LDR      R0,??DataTable32_2  ;; 0x4007d001
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2280             MOVS     R2,#+128
   \   0000000A   0x4010             ANDS     R0,R0,R2
   \   0000000C   0x0001             MOVS     R1,R0
   1503              if(xtFlag)
   \   0000000E   0xB2C9             UXTB     R1,R1
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD001             BEQ      ??SysCtlLVDWaringFlagGet_0
   1504              {
   1505                  return xtrue;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xE000             B        ??SysCtlLVDWaringFlagGet_1
   1506              }
   1507              else
   1508              {
   1509                  return xfalse;
   \                     ??SysCtlLVDWaringFlagGet_0:
   \   00000018   0x2000             MOVS     R0,#+0
   \                     ??SysCtlLVDWaringFlagGet_1:
   \   0000001A   0xBD00             POP      {PC}             ;; return
   1510              }
   1511          }
   1512          
   1513          //*****************************************************************************
   1514          //
   1515          //! \brief Clear Low-Voltage Warning Flag.
   1516          //!
   1517          //! \param None.
   1518          //!
   1519          //! This function is to Clear Low-Voltage Warning Flag
   1520          //!
   1521          //! \return None.
   1522          //
   1523          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   1524          void
   1525          SysCtlLVDWarningFlagClear(void)
   1526          {
   1527              xHWREGB(PMC_LVDSC2) |= PMC_LVDSC2_LVWACK;
   \                     SysCtlLVDWarningFlagClear:
   \   00000000   0x....             LDR      R0,??DataTable32_2  ;; 0x4007d001
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x2140             MOVS     R1,#+64
   \   00000006   0x4301             ORRS     R1,R1,R0
   \   00000008   0x....             LDR      R0,??DataTable32_2  ;; 0x4007d001
   \   0000000A   0x7001             STRB     R1,[R0, #+0]
   1528          }
   \   0000000C   0x4770             BX       LR               ;; return
   1529          
   1530          //*****************************************************************************
   1531          //
   1532          //! \brief The function is to Enter very low power run mode or not
   1533          //!
   1534          //! \param bEnable is a boolean that is \b true if Enter very low power run mode
   1535          //! and \b false if exit very low power run mode to run mode.
   1536          //!
   1537          //! The function is used to Enter very low power run mode or not
   1538          //!
   1539          //! \return None.
   1540          //
   1541          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   1542          void 
   1543          SysCtlVeryLowPowerRunModeEnable(xtBoolean bEnable)
   1544          {
   \                     SysCtlVeryLowPowerRunModeEnable:
   \   00000000   0xB500             PUSH     {LR}
   1545              //
   1546              // Enter very low power run mode.
   1547              //
   1548              if(bEnable)
   \   00000002   0xB2C0             UXTB     R0,R0
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD012             BEQ      ??SysCtlVeryLowPowerRunModeEnable_0
   1549              {
   1550                  xHWREGB(SMC_PMPROT) |= SMC_PMPROT_AVLP;
   \   00000008   0x....             LDR      R1,??DataTable32_3  ;; 0x4007e000
   \   0000000A   0x7809             LDRB     R1,[R1, #+0]
   \   0000000C   0x2220             MOVS     R2,#+32
   \   0000000E   0x430A             ORRS     R2,R2,R1
   \   00000010   0x....             LDR      R1,??DataTable32_3  ;; 0x4007e000
   \   00000012   0x700A             STRB     R2,[R1, #+0]
   1551                  xHWREGB(SMC_PMCTRL) &= ~SMC_PMCTRL_RUNM_M;
   \   00000014   0x....             LDR      R1,??DataTable33  ;; 0x4007e001
   \   00000016   0x7809             LDRB     R1,[R1, #+0]
   \   00000018   0x229F             MOVS     R2,#+159
   \   0000001A   0x400A             ANDS     R2,R2,R1
   \   0000001C   0x....             LDR      R1,??DataTable33  ;; 0x4007e001
   \   0000001E   0x700A             STRB     R2,[R1, #+0]
   1552                  xHWREGB(SMC_PMCTRL) |= SMC_PMCTRL_RUNM_VLPR;
   \   00000020   0x....             LDR      R1,??DataTable33  ;; 0x4007e001
   \   00000022   0x7809             LDRB     R1,[R1, #+0]
   \   00000024   0x2240             MOVS     R2,#+64
   \   00000026   0x430A             ORRS     R2,R2,R1
   \   00000028   0x....             LDR      R1,??DataTable33  ;; 0x4007e001
   \   0000002A   0x700A             STRB     R2,[R1, #+0]
   \   0000002C   0xE00B             B        ??SysCtlVeryLowPowerRunModeEnable_1
   1553              }
   1554              //
   1555              // Exit very low power run mode.
   1556              //
   1557              else
   1558              {
   1559                  xHWREGB(SMC_PMPROT) &= ~SMC_PMPROT_AVLP;
   \                     ??SysCtlVeryLowPowerRunModeEnable_0:
   \   0000002E   0x....             LDR      R1,??DataTable32_3  ;; 0x4007e000
   \   00000030   0x7809             LDRB     R1,[R1, #+0]
   \   00000032   0x22DF             MOVS     R2,#+223
   \   00000034   0x400A             ANDS     R2,R2,R1
   \   00000036   0x....             LDR      R1,??DataTable32_3  ;; 0x4007e000
   \   00000038   0x700A             STRB     R2,[R1, #+0]
   1560                  xHWREGB(SMC_PMCTRL) &= ~SMC_PMCTRL_RUNM_M;
   \   0000003A   0x....             LDR      R1,??DataTable33  ;; 0x4007e001
   \   0000003C   0x7809             LDRB     R1,[R1, #+0]
   \   0000003E   0x229F             MOVS     R2,#+159
   \   00000040   0x400A             ANDS     R2,R2,R1
   \   00000042   0x....             LDR      R1,??DataTable33  ;; 0x4007e001
   \   00000044   0x700A             STRB     R2,[R1, #+0]
   1561              }
   1562          }
   \                     ??SysCtlVeryLowPowerRunModeEnable_1:
   \   00000046   0xBD00             POP      {PC}             ;; return
   1563          
   1564          //*****************************************************************************
   1565          //
   1566          //! \brief The function is to Enable Low-Voltage Detect Interrupt or not
   1567          //!
   1568          //! \param bEnable is a boolean that is \b true if Enable Low-Voltage Detect 
   1569          //!  Interrupt and \b false if not.
   1570          //!
   1571          //! The function is used to Enable Low-Voltage Detect Interrupt or not
   1572          //!
   1573          //! \return None.
   1574          //
   1575          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   1576          void 
   1577          SysCtlLVDIntEnable(xtBoolean bEnable)
   1578          {
   \                     SysCtlLVDIntEnable:
   \   00000000   0xB500             PUSH     {LR}
   1579              //
   1580              // Enable Low-Voltage Detect Interrupt.
   1581              //
   1582              if(bEnable)
   \   00000002   0xB2C0             UXTB     R0,R0
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD006             BEQ      ??SysCtlLVDIntEnable_0
   1583              {
   1584                  xHWREGB(PMC_LVDSC1) |= PMC_LVDSC1_LVDIE;
   \   00000008   0x....             LDR      R1,??DataTable32_1  ;; 0x4007d000
   \   0000000A   0x7809             LDRB     R1,[R1, #+0]
   \   0000000C   0x2220             MOVS     R2,#+32
   \   0000000E   0x430A             ORRS     R2,R2,R1
   \   00000010   0x....             LDR      R1,??DataTable32_1  ;; 0x4007d000
   \   00000012   0x700A             STRB     R2,[R1, #+0]
   \   00000014   0xE005             B        ??SysCtlLVDIntEnable_1
   1585              }
   1586              //
   1587              // Disable Low-Voltage Detect Interrupt.
   1588              //
   1589              else
   1590              {
   1591                  xHWREGB(PMC_LVDSC1) &= ~PMC_LVDSC1_LVDIE;
   \                     ??SysCtlLVDIntEnable_0:
   \   00000016   0x....             LDR      R1,??DataTable32_1  ;; 0x4007d000
   \   00000018   0x7809             LDRB     R1,[R1, #+0]
   \   0000001A   0x22DF             MOVS     R2,#+223
   \   0000001C   0x400A             ANDS     R2,R2,R1
   \   0000001E   0x....             LDR      R1,??DataTable32_1  ;; 0x4007d000
   \   00000020   0x700A             STRB     R2,[R1, #+0]
   1592              }
   1593          }
   \                     ??SysCtlLVDIntEnable_1:
   \   00000022   0xBD00             POP      {PC}             ;; return
   1594          
   1595          //*****************************************************************************
   1596          //
   1597          //! \brief The function is to Enable Low-Voltage Detect Warning Interrupt or not
   1598          //!
   1599          //! \param bEnable is a boolean that is \b true if Enable Low-Voltage Warning 
   1600          //!  Interrupt and \b false if not.
   1601          //!
   1602          //! The function is used to Enable Low-Voltage Detect Warning Interrupt or not
   1603          //!
   1604          //! \return None.
   1605          //
   1606          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   1607          void 
   1608          SysCtlLVDWarningIntEnable(xtBoolean bEnable)
   1609          {
   \                     SysCtlLVDWarningIntEnable:
   \   00000000   0xB500             PUSH     {LR}
   1610              //
   1611              // Enable Low-Voltage Detect Warning Interrupt.
   1612              //
   1613              if(bEnable)
   \   00000002   0xB2C0             UXTB     R0,R0
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD006             BEQ      ??SysCtlLVDWarningIntEnable_0
   1614              {
   1615                  xHWREGB(PMC_LVDSC2) |= PMC_LVDSC2_LVDRE;
   \   00000008   0x....             LDR      R1,??DataTable32_2  ;; 0x4007d001
   \   0000000A   0x7809             LDRB     R1,[R1, #+0]
   \   0000000C   0x2220             MOVS     R2,#+32
   \   0000000E   0x430A             ORRS     R2,R2,R1
   \   00000010   0x....             LDR      R1,??DataTable32_2  ;; 0x4007d001
   \   00000012   0x700A             STRB     R2,[R1, #+0]
   \   00000014   0xE005             B        ??SysCtlLVDWarningIntEnable_1
   1616              }
   1617              //
   1618              // Disable Low-Voltage Detect Warning Interrupt.
   1619              //
   1620              else
   1621              {
   1622                  xHWREGB(PMC_LVDSC2) &= ~PMC_LVDSC2_LVDRE;
   \                     ??SysCtlLVDWarningIntEnable_0:
   \   00000016   0x....             LDR      R1,??DataTable32_2  ;; 0x4007d001
   \   00000018   0x7809             LDRB     R1,[R1, #+0]
   \   0000001A   0x22DF             MOVS     R2,#+223
   \   0000001C   0x400A             ANDS     R2,R2,R1
   \   0000001E   0x....             LDR      R1,??DataTable32_2  ;; 0x4007d001
   \   00000020   0x700A             STRB     R2,[R1, #+0]
   1623              }
   1624          }
   \                     ??SysCtlLVDWarningIntEnable_1:
   \   00000022   0xBD00             POP      {PC}             ;; return
   1625          //*****************************************************************************
   1626          //
   1627          //! \brief The function is to Enable Low-Voltage Detect Reset or not
   1628          //!
   1629          //! \param bEnable is a boolean that is \b true if Enable Low-Voltage Detect 
   1630          //!  Reset and \b false if not.
   1631          //!
   1632          //! The function is used to Enable Low-Voltage Detect Reset or not
   1633          //!
   1634          //! \return None.
   1635          //
   1636          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   1637          void 
   1638          SysCtlLVDResetEnable(xtBoolean bEnable)
   1639          {
   \                     SysCtlLVDResetEnable:
   \   00000000   0xB500             PUSH     {LR}
   1640              //
   1641              // Enable Low-Voltage Detect Reset.
   1642              //
   1643              if(bEnable)
   \   00000002   0xB2C0             UXTB     R0,R0
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD006             BEQ      ??SysCtlLVDResetEnable_0
   1644              {
   1645                  xHWREGB(PMC_LVDSC1) |= PMC_LVDSC1_LVDRE;
   \   00000008   0x....             LDR      R1,??DataTable32_1  ;; 0x4007d000
   \   0000000A   0x7809             LDRB     R1,[R1, #+0]
   \   0000000C   0x2210             MOVS     R2,#+16
   \   0000000E   0x430A             ORRS     R2,R2,R1
   \   00000010   0x....             LDR      R1,??DataTable32_1  ;; 0x4007d000
   \   00000012   0x700A             STRB     R2,[R1, #+0]
   \   00000014   0xE005             B        ??SysCtlLVDResetEnable_1
   1646              }
   1647              //
   1648              // Disable Low-Voltage Detect Reset.
   1649              //
   1650              else
   1651              {
   1652                  xHWREGB(PMC_LVDSC1) &= ~PMC_LVDSC1_LVDRE;
   \                     ??SysCtlLVDResetEnable_0:
   \   00000016   0x....             LDR      R1,??DataTable32_1  ;; 0x4007d000
   \   00000018   0x7809             LDRB     R1,[R1, #+0]
   \   0000001A   0x22EF             MOVS     R2,#+239
   \   0000001C   0x400A             ANDS     R2,R2,R1
   \   0000001E   0x....             LDR      R1,??DataTable32_1  ;; 0x4007d000
   \   00000020   0x700A             STRB     R2,[R1, #+0]
   1653              }
   1654          }
   \                     ??SysCtlLVDResetEnable_1:
   \   00000022   0xBD00             POP      {PC}             ;; return
   1655          //*****************************************************************************
   1656          //
   1657          //! \brief The function is to Enter the various Stop mode.
   1658          //!
   1659          //! \param ulStopMode is the Stop mode which will enter.
   1660          //!
   1661          //! The function is used to Enter the various Stop mode
   1662          //!
   1663          //! \return None.
   1664          //
   1665          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   1666          void 
   1667          SysCtlStopModeSet(unsigned long ulStopMode)
   1668          {
   \                     SysCtlStopModeSet:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1669              //
   1670              // Check the arguments.
   1671              //
   1672              xASSERT((ulStopMode == SYSCTL_STOP_MODE_VLPS) ||
   1673                      (ulStopMode == SYSCTL_STOP_MODE_LLS)  ||
   1674                      (ulStopMode == SYSCTL_STOP_MODE_VLLS0)||
   1675                      (ulStopMode == SYSCTL_STOP_MODE_VLLS1)||
   1676                      (ulStopMode == SYSCTL_STOP_MODE_VLLS2)||
   1677                      (ulStopMode == SYSCTL_STOP_MODE_VLLS3)||
   1678                      (ulStopMode == SYSCTL_STOP_MODE_NORMAL));
   1679          
   1680              //
   1681              // Set the SLEEPDEEP bit to enable deep sleep mode(STOP).
   1682              //
   1683              xHWREG(SCB_SCR) |= SCB_SCR_SLEEPDEEP;
   \   00000004   0x....             LDR      R0,??DataTable33_1  ;; 0xe000e000
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x2104             MOVS     R1,#+4
   \   0000000A   0x4301             ORRS     R1,R1,R0
   \   0000000C   0x....             LDR      R0,??DataTable33_1  ;; 0xe000e000
   \   0000000E   0x6001             STR      R1,[R0, #+0]
   1684              //
   1685              // Enter the various Stop mode.
   1686              //
   1687              if(ulStopMode == SYSCTL_STOP_MODE_VLPS)
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD112             BNE      ??SysCtlStopModeSet_0
   1688              {
   1689                  xHWREGB(SMC_PMPROT) |= SMC_PMPROT_AVLP;
   \   00000014   0x....             LDR      R0,??DataTable32_3  ;; 0x4007e000
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x2120             MOVS     R1,#+32
   \   0000001A   0x4301             ORRS     R1,R1,R0
   \   0000001C   0x....             LDR      R0,??DataTable32_3  ;; 0x4007e000
   \   0000001E   0x7001             STRB     R1,[R0, #+0]
   1690                  xHWREGB(SMC_PMCTRL) &= ~SMC_PMCTRL_STOPM_M;
   \   00000020   0x....             LDR      R0,??DataTable33  ;; 0x4007e001
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x21F8             MOVS     R1,#+248
   \   00000026   0x4001             ANDS     R1,R1,R0
   \   00000028   0x....             LDR      R0,??DataTable33  ;; 0x4007e001
   \   0000002A   0x7001             STRB     R1,[R0, #+0]
   1691                  xHWREGB(SMC_PMCTRL) |= SMC_PMCTRL_STOPM_VLPS;
   \   0000002C   0x....             LDR      R0,??DataTable33  ;; 0x4007e001
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0x4301             ORRS     R1,R1,R0
   \   00000034   0x....             LDR      R0,??DataTable33  ;; 0x4007e001
   \   00000036   0x7001             STRB     R1,[R0, #+0]
   \   00000038   0xE0A2             B        ??SysCtlStopModeSet_1
   1692              }
   1693              else if(ulStopMode == SYSCTL_STOP_MODE_NORMAL)
   \                     ??SysCtlStopModeSet_0:
   \   0000003A   0x2C06             CMP      R4,#+6
   \   0000003C   0xD10C             BNE      ??SysCtlStopModeSet_2
   1694              {
   1695                  xHWREGB(SMC_PMCTRL) &= ~SMC_PMCTRL_RUNM_M;
   \   0000003E   0x....             LDR      R0,??DataTable33  ;; 0x4007e001
   \   00000040   0x7800             LDRB     R0,[R0, #+0]
   \   00000042   0x219F             MOVS     R1,#+159
   \   00000044   0x4001             ANDS     R1,R1,R0
   \   00000046   0x....             LDR      R0,??DataTable33  ;; 0x4007e001
   \   00000048   0x7001             STRB     R1,[R0, #+0]
   1696                  xHWREGB(SMC_PMCTRL) &= ~SMC_PMCTRL_STOPM_M;
   \   0000004A   0x....             LDR      R0,??DataTable33  ;; 0x4007e001
   \   0000004C   0x7800             LDRB     R0,[R0, #+0]
   \   0000004E   0x21F8             MOVS     R1,#+248
   \   00000050   0x4001             ANDS     R1,R1,R0
   \   00000052   0x....             LDR      R0,??DataTable33  ;; 0x4007e001
   \   00000054   0x7001             STRB     R1,[R0, #+0]
   \   00000056   0xE093             B        ??SysCtlStopModeSet_1
   1697              }
   1698              else if(ulStopMode == SYSCTL_STOP_MODE_LLS)
   \                     ??SysCtlStopModeSet_2:
   \   00000058   0x2C01             CMP      R4,#+1
   \   0000005A   0xD112             BNE      ??SysCtlStopModeSet_3
   1699              {
   1700                  xHWREGB(SMC_PMPROT) |= SMC_PMPROT_ALLS;
   \   0000005C   0x....             LDR      R0,??DataTable32_3  ;; 0x4007e000
   \   0000005E   0x7800             LDRB     R0,[R0, #+0]
   \   00000060   0x2108             MOVS     R1,#+8
   \   00000062   0x4301             ORRS     R1,R1,R0
   \   00000064   0x....             LDR      R0,??DataTable32_3  ;; 0x4007e000
   \   00000066   0x7001             STRB     R1,[R0, #+0]
   1701                  xHWREGB(SMC_PMCTRL) &= ~SMC_PMCTRL_STOPM_M;
   \   00000068   0x....             LDR      R0,??DataTable33  ;; 0x4007e001
   \   0000006A   0x7800             LDRB     R0,[R0, #+0]
   \   0000006C   0x21F8             MOVS     R1,#+248
   \   0000006E   0x4001             ANDS     R1,R1,R0
   \   00000070   0x....             LDR      R0,??DataTable33  ;; 0x4007e001
   \   00000072   0x7001             STRB     R1,[R0, #+0]
   1702                  xHWREGB(SMC_PMCTRL) |= SMC_PMCTRL_STOPM_LLS;
   \   00000074   0x....             LDR      R0,??DataTable33  ;; 0x4007e001
   \   00000076   0x7800             LDRB     R0,[R0, #+0]
   \   00000078   0x2103             MOVS     R1,#+3
   \   0000007A   0x4301             ORRS     R1,R1,R0
   \   0000007C   0x....             LDR      R0,??DataTable33  ;; 0x4007e001
   \   0000007E   0x7001             STRB     R1,[R0, #+0]
   \   00000080   0xE07E             B        ??SysCtlStopModeSet_1
   1703              }
   1704              else if(ulStopMode == SYSCTL_STOP_MODE_VLLS0)
   \                     ??SysCtlStopModeSet_3:
   \   00000082   0x2C02             CMP      R4,#+2
   \   00000084   0xD11C             BNE      ??SysCtlStopModeSet_4
   1705              {
   1706                  xHWREGB(SMC_PMPROT) |= SMC_PMPROT_AVLLS;
   \   00000086   0x....             LDR      R0,??DataTable32_3  ;; 0x4007e000
   \   00000088   0x7800             LDRB     R0,[R0, #+0]
   \   0000008A   0x2102             MOVS     R1,#+2
   \   0000008C   0x4301             ORRS     R1,R1,R0
   \   0000008E   0x....             LDR      R0,??DataTable32_3  ;; 0x4007e000
   \   00000090   0x7001             STRB     R1,[R0, #+0]
   1707                  xHWREGB(SMC_PMCTRL) &= ~SMC_PMCTRL_STOPM_M;
   \   00000092   0x....             LDR      R0,??DataTable33  ;; 0x4007e001
   \   00000094   0x7800             LDRB     R0,[R0, #+0]
   \   00000096   0x21F8             MOVS     R1,#+248
   \   00000098   0x4001             ANDS     R1,R1,R0
   \   0000009A   0x....             LDR      R0,??DataTable33  ;; 0x4007e001
   \   0000009C   0x7001             STRB     R1,[R0, #+0]
   1708                  xHWREGB(SMC_PMCTRL) |= SMC_PMCTRL_STOPM_VLLS;
   \   0000009E   0x....             LDR      R0,??DataTable33  ;; 0x4007e001
   \   000000A0   0x7800             LDRB     R0,[R0, #+0]
   \   000000A2   0x2104             MOVS     R1,#+4
   \   000000A4   0x4301             ORRS     R1,R1,R0
   \   000000A6   0x....             LDR      R0,??DataTable33  ;; 0x4007e001
   \   000000A8   0x7001             STRB     R1,[R0, #+0]
   1709                  xHWREGB(SMC_STOPCTRL) &= ~SMC_STOPCTRL_VLLSM_M;
   \   000000AA   0x....             LDR      R0,??DataTable33_2  ;; 0x4007e002
   \   000000AC   0x7800             LDRB     R0,[R0, #+0]
   \   000000AE   0x21F8             MOVS     R1,#+248
   \   000000B0   0x4001             ANDS     R1,R1,R0
   \   000000B2   0x....             LDR      R0,??DataTable33_2  ;; 0x4007e002
   \   000000B4   0x7001             STRB     R1,[R0, #+0]
   1710                  xHWREGB(SMC_STOPCTRL) |= SMC_STOPCTRL_VLLSM_VLLS0;
   \   000000B6   0x....             LDR      R0,??DataTable33_2  ;; 0x4007e002
   \   000000B8   0x....             LDR      R1,??DataTable33_2  ;; 0x4007e002
   \   000000BA   0x7809             LDRB     R1,[R1, #+0]
   \   000000BC   0x7001             STRB     R1,[R0, #+0]
   \   000000BE   0xE05F             B        ??SysCtlStopModeSet_1
   1711              }
   1712              else if(ulStopMode == SYSCTL_STOP_MODE_VLLS1)
   \                     ??SysCtlStopModeSet_4:
   \   000000C0   0x2C03             CMP      R4,#+3
   \   000000C2   0xD11E             BNE      ??SysCtlStopModeSet_5
   1713              {
   1714                  xHWREGB(SMC_PMPROT) |= SMC_PMPROT_AVLLS;
   \   000000C4   0x....             LDR      R0,??DataTable32_3  ;; 0x4007e000
   \   000000C6   0x7800             LDRB     R0,[R0, #+0]
   \   000000C8   0x2102             MOVS     R1,#+2
   \   000000CA   0x4301             ORRS     R1,R1,R0
   \   000000CC   0x....             LDR      R0,??DataTable32_3  ;; 0x4007e000
   \   000000CE   0x7001             STRB     R1,[R0, #+0]
   1715                  xHWREGB(SMC_PMCTRL) &= ~SMC_PMCTRL_STOPM_M;
   \   000000D0   0x....             LDR      R0,??DataTable33  ;; 0x4007e001
   \   000000D2   0x7800             LDRB     R0,[R0, #+0]
   \   000000D4   0x21F8             MOVS     R1,#+248
   \   000000D6   0x4001             ANDS     R1,R1,R0
   \   000000D8   0x....             LDR      R0,??DataTable33  ;; 0x4007e001
   \   000000DA   0x7001             STRB     R1,[R0, #+0]
   1716                  xHWREGB(SMC_PMCTRL) |= SMC_PMCTRL_STOPM_VLLS;
   \   000000DC   0x....             LDR      R0,??DataTable33  ;; 0x4007e001
   \   000000DE   0x7800             LDRB     R0,[R0, #+0]
   \   000000E0   0x2104             MOVS     R1,#+4
   \   000000E2   0x4301             ORRS     R1,R1,R0
   \   000000E4   0x....             LDR      R0,??DataTable33  ;; 0x4007e001
   \   000000E6   0x7001             STRB     R1,[R0, #+0]
   1717                  xHWREGB(SMC_STOPCTRL) &= ~SMC_STOPCTRL_VLLSM_M;
   \   000000E8   0x....             LDR      R0,??DataTable33_2  ;; 0x4007e002
   \   000000EA   0x7800             LDRB     R0,[R0, #+0]
   \   000000EC   0x21F8             MOVS     R1,#+248
   \   000000EE   0x4001             ANDS     R1,R1,R0
   \   000000F0   0x....             LDR      R0,??DataTable33_2  ;; 0x4007e002
   \   000000F2   0x7001             STRB     R1,[R0, #+0]
   1718                  xHWREGB(SMC_STOPCTRL) |= SMC_STOPCTRL_VLLSM_VLLS1;
   \   000000F4   0x....             LDR      R0,??DataTable33_2  ;; 0x4007e002
   \   000000F6   0x7800             LDRB     R0,[R0, #+0]
   \   000000F8   0x2101             MOVS     R1,#+1
   \   000000FA   0x4301             ORRS     R1,R1,R0
   \   000000FC   0x....             LDR      R0,??DataTable33_2  ;; 0x4007e002
   \   000000FE   0x7001             STRB     R1,[R0, #+0]
   \   00000100   0xE03E             B        ??SysCtlStopModeSet_1
   1719              }
   1720              else if(ulStopMode == SYSCTL_STOP_MODE_VLLS2)
   \                     ??SysCtlStopModeSet_5:
   \   00000102   0x2C04             CMP      R4,#+4
   \   00000104   0xD11E             BNE      ??SysCtlStopModeSet_6
   1721              {
   1722                  xHWREGB(SMC_PMPROT) |= SMC_PMPROT_AVLLS;
   \   00000106   0x....             LDR      R0,??DataTable32_3  ;; 0x4007e000
   \   00000108   0x7800             LDRB     R0,[R0, #+0]
   \   0000010A   0x2102             MOVS     R1,#+2
   \   0000010C   0x4301             ORRS     R1,R1,R0
   \   0000010E   0x....             LDR      R0,??DataTable32_3  ;; 0x4007e000
   \   00000110   0x7001             STRB     R1,[R0, #+0]
   1723                  xHWREGB(SMC_PMCTRL) &= ~SMC_PMCTRL_STOPM_M;
   \   00000112   0x....             LDR      R0,??DataTable33  ;; 0x4007e001
   \   00000114   0x7800             LDRB     R0,[R0, #+0]
   \   00000116   0x21F8             MOVS     R1,#+248
   \   00000118   0x4001             ANDS     R1,R1,R0
   \   0000011A   0x....             LDR      R0,??DataTable33  ;; 0x4007e001
   \   0000011C   0x7001             STRB     R1,[R0, #+0]
   1724                  xHWREGB(SMC_PMCTRL) |= SMC_PMCTRL_STOPM_VLLS;
   \   0000011E   0x....             LDR      R0,??DataTable33  ;; 0x4007e001
   \   00000120   0x7800             LDRB     R0,[R0, #+0]
   \   00000122   0x2104             MOVS     R1,#+4
   \   00000124   0x4301             ORRS     R1,R1,R0
   \   00000126   0x....             LDR      R0,??DataTable33  ;; 0x4007e001
   \   00000128   0x7001             STRB     R1,[R0, #+0]
   1725                  xHWREGB(SMC_STOPCTRL) &= ~SMC_STOPCTRL_VLLSM_M;
   \   0000012A   0x....             LDR      R0,??DataTable33_2  ;; 0x4007e002
   \   0000012C   0x7800             LDRB     R0,[R0, #+0]
   \   0000012E   0x21F8             MOVS     R1,#+248
   \   00000130   0x4001             ANDS     R1,R1,R0
   \   00000132   0x....             LDR      R0,??DataTable33_2  ;; 0x4007e002
   \   00000134   0x7001             STRB     R1,[R0, #+0]
   1726                  xHWREGB(SMC_STOPCTRL) |= SMC_STOPCTRL_VLLSM_VLLS2;
   \   00000136   0x....             LDR      R0,??DataTable33_2  ;; 0x4007e002
   \   00000138   0x7800             LDRB     R0,[R0, #+0]
   \   0000013A   0x2102             MOVS     R1,#+2
   \   0000013C   0x4301             ORRS     R1,R1,R0
   \   0000013E   0x....             LDR      R0,??DataTable33_2  ;; 0x4007e002
   \   00000140   0x7001             STRB     R1,[R0, #+0]
   \   00000142   0xE01D             B        ??SysCtlStopModeSet_1
   1727              }
   1728              else
   1729              {
   1730                  xHWREGB(SMC_PMPROT) |= SMC_PMPROT_AVLLS;
   \                     ??SysCtlStopModeSet_6:
   \   00000144   0x....             LDR      R0,??DataTable32_3  ;; 0x4007e000
   \   00000146   0x7800             LDRB     R0,[R0, #+0]
   \   00000148   0x2102             MOVS     R1,#+2
   \   0000014A   0x4301             ORRS     R1,R1,R0
   \   0000014C   0x....             LDR      R0,??DataTable32_3  ;; 0x4007e000
   \   0000014E   0x7001             STRB     R1,[R0, #+0]
   1731                  xHWREGB(SMC_PMCTRL) &= ~SMC_PMCTRL_STOPM_M;
   \   00000150   0x....             LDR      R0,??DataTable33  ;; 0x4007e001
   \   00000152   0x7800             LDRB     R0,[R0, #+0]
   \   00000154   0x21F8             MOVS     R1,#+248
   \   00000156   0x4001             ANDS     R1,R1,R0
   \   00000158   0x....             LDR      R0,??DataTable33  ;; 0x4007e001
   \   0000015A   0x7001             STRB     R1,[R0, #+0]
   1732                  xHWREGB(SMC_PMCTRL) |= SMC_PMCTRL_STOPM_VLLS;
   \   0000015C   0x....             LDR      R0,??DataTable33  ;; 0x4007e001
   \   0000015E   0x7800             LDRB     R0,[R0, #+0]
   \   00000160   0x2104             MOVS     R1,#+4
   \   00000162   0x4301             ORRS     R1,R1,R0
   \   00000164   0x....             LDR      R0,??DataTable33  ;; 0x4007e001
   \   00000166   0x7001             STRB     R1,[R0, #+0]
   1733                  xHWREGB(SMC_STOPCTRL) &= ~SMC_STOPCTRL_VLLSM_M;
   \   00000168   0x....             LDR      R0,??DataTable33_2  ;; 0x4007e002
   \   0000016A   0x7800             LDRB     R0,[R0, #+0]
   \   0000016C   0x21F8             MOVS     R1,#+248
   \   0000016E   0x4001             ANDS     R1,R1,R0
   \   00000170   0x....             LDR      R0,??DataTable33_2  ;; 0x4007e002
   \   00000172   0x7001             STRB     R1,[R0, #+0]
   1734                  xHWREGB(SMC_STOPCTRL) |= SMC_STOPCTRL_VLLSM_VLLS3;
   \   00000174   0x....             LDR      R0,??DataTable33_2  ;; 0x4007e002
   \   00000176   0x7800             LDRB     R0,[R0, #+0]
   \   00000178   0x2103             MOVS     R1,#+3
   \   0000017A   0x4301             ORRS     R1,R1,R0
   \   0000017C   0x....             LDR      R0,??DataTable33_2  ;; 0x4007e002
   \   0000017E   0x7001             STRB     R1,[R0, #+0]
   1735              }
   1736              //
   1737              // WFI instruction will start entry into STOP mode
   1738              //
   1739              xCPUwfi();
   \                     ??SysCtlStopModeSet_1:
   \   00000180   0x.... 0x....      BL       xCPUwfi
   1740          }
   \   00000184   0xBD10             POP      {R4,PC}          ;; return
   1741          
   1742          //*****************************************************************************
   1743          //
   1744          //! \brief The function is used to Get HCLK clock and the UNIT is in Hz
   1745          //!
   1746          //! \param None.
   1747          //!
   1748          //! The function is used to Get HCLK clock and the UNIT is in Hz
   1749          //!
   1750          //! \return HCLK clock frequency in Hz 
   1751          //
   1752          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   1753          unsigned long 
   1754          SysCtlHClockGet(void)
   1755          {
   \                     SysCtlHClockGet:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1756              unsigned long  ulFreqout = 0, ulDivider = 0, ulDividerPll = 0;
   \   00000002   0x2600             MOVS     R6,#+0
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0x2500             MOVS     R5,#+0
   1757          
   1758              //
   1759              // external 12MHz crystal clock.
   1760              //
   1761              if((xHWREG(MCG_C1)&SYSCTL_HLCK_S_MAIN) == SYSCTL_HLCK_S_MAIN)
   \   00000008   0x....             LDR      R0,??DataTable33_3  ;; 0x40064000
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x0600             LSLS     R0,R0,#+24
   \   0000000E   0xD50F             BPL      ??SysCtlHClockGet_0
   1762              {
   1763                  ulFreqout = s_ulExtClockMHz*1000000;
   \   00000010   0x....             LDR      R0,??DataTable33_4
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x....             LDR      R1,??DataTable33_5  ;; 0xf4240
   \   00000016   0x4348             MULS     R0,R1,R0
   \   00000018   0x0006             MOVS     R6,R0
   1764                  ulDivider = (xHWREG(SIM_CLKDIV1) & SIM_CLKDIV1_OUTDIV1_M) >> SIM_CLKDIV1_OUTDIV1_S;
   \   0000001A   0x....             LDR      R0,??DataTable33_6  ;; 0x40048044
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x0F00             LSRS     R0,R0,#+28
   \   00000020   0x0004             MOVS     R4,R0
   1765                  ulFreqout = ulFreqout/(ulDivider+1);  
   \   00000022   0x0030             MOVS     R0,R6
   \   00000024   0x0021             MOVS     R1,R4
   \   00000026   0x1C49             ADDS     R1,R1,#+1
   \   00000028   0x.... 0x....      BL       __aeabi_uidiv
   \   0000002C   0x0006             MOVS     R6,R0
   \   0000002E   0xE05C             B        ??SysCtlHClockGet_1
   1766              }
   1767              //
   1768              // internal 32KHz crystal clock.
   1769              //
   1770              else if((xHWREG(MCG_C1)&SYSCTL_HLCK_S_INT) == SYSCTL_HLCK_S_INT)     
   \                     ??SysCtlHClockGet_0:
   \   00000030   0x....             LDR      R0,??DataTable33_3  ;; 0x40064000
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x0640             LSLS     R0,R0,#+25
   \   00000036   0xD513             BPL      ??SysCtlHClockGet_2
   1771              {
   1772                  if((xHWREGB(MCG_C2)&MCG_C2_IRCS) == MCG_C2_IRCS)
   \   00000038   0x....             LDR      R0,??DataTable33_7  ;; 0x40064001
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0xB2C0             UXTB     R0,R0
   \   0000003E   0x07C0             LSLS     R0,R0,#+31
   \   00000040   0xD503             BPL      ??SysCtlHClockGet_3
   1773                  {
   1774                      ulFreqout = 32768;
   \   00000042   0x2080             MOVS     R0,#+128
   \   00000044   0x0200             LSLS     R0,R0,#+8        ;; #+32768
   \   00000046   0x0006             MOVS     R6,R0
   \   00000048   0xE04F             B        ??SysCtlHClockGet_1
   1775                  }
   1776                  else
   1777                  {
   1778                      ulDivider = (xHWREG(SIM_CLKDIV1) & SIM_CLKDIV1_OUTDIV1_M) >> SIM_CLKDIV1_OUTDIV1_S;
   \                     ??SysCtlHClockGet_3:
   \   0000004A   0x....             LDR      R0,??DataTable33_6  ;; 0x40048044
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x0F00             LSRS     R0,R0,#+28
   \   00000050   0x0004             MOVS     R4,R0
   1779                      ulFreqout = 4000000/(ulDivider+1);
   \   00000052   0x....             LDR      R0,??DataTable33_8  ;; 0x3d0900
   \   00000054   0x0021             MOVS     R1,R4
   \   00000056   0x1C49             ADDS     R1,R1,#+1
   \   00000058   0x.... 0x....      BL       __aeabi_uidiv
   \   0000005C   0x0006             MOVS     R6,R0
   \   0000005E   0xE044             B        ??SysCtlHClockGet_1
   1780                  }
   1781              }
   1782              //
   1783              // PLL or FLL clock.
   1784              //
   1785              else    
   1786              {
   1787                  //
   1788                  // PLL
   1789                  //
   1790                  if((xHWREGB(MCG_C6) & MCG_C6_PLLS) == MCG_C6_PLLS)
   \                     ??SysCtlHClockGet_2:
   \   00000060   0x....             LDR      R0,??DataTable33_9  ;; 0x40064005
   \   00000062   0x7800             LDRB     R0,[R0, #+0]
   \   00000064   0xB2C0             UXTB     R0,R0
   \   00000066   0x0640             LSLS     R0,R0,#+25
   \   00000068   0xD51F             BPL      ??SysCtlHClockGet_4
   1791                  {
   1792                      ulFreqout = s_ulExtClockMHz* ((xHWREGB(MCG_C6)&MCG_C6_VDIV0_M)+24)*1000000;
   \   0000006A   0x....             LDR      R0,??DataTable33_4
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0x....             LDR      R1,??DataTable33_9  ;; 0x40064005
   \   00000070   0x7809             LDRB     R1,[R1, #+0]
   \   00000072   0xB2C9             UXTB     R1,R1
   \   00000074   0x06C9             LSLS     R1,R1,#+27       ;; ZeroExtS R1,R1,#+27,#+27
   \   00000076   0x0EC9             LSRS     R1,R1,#+27
   \   00000078   0x3118             ADDS     R1,R1,#+24
   \   0000007A   0x4348             MULS     R0,R1,R0
   \   0000007C   0x....             LDR      R1,??DataTable33_5  ;; 0xf4240
   \   0000007E   0x4348             MULS     R0,R1,R0
   \   00000080   0x0006             MOVS     R6,R0
   1793                      ulDivider = (xHWREG(SIM_CLKDIV1) & SIM_CLKDIV1_OUTDIV1_M) >> SIM_CLKDIV1_OUTDIV1_S;
   \   00000082   0x....             LDR      R0,??DataTable33_6  ;; 0x40048044
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0x0F00             LSRS     R0,R0,#+28
   \   00000088   0x0004             MOVS     R4,R0
   1794                      ulDividerPll = (xHWREGB(MCG_C5)&MCG_C5_PRDIV0_M);
   \   0000008A   0x....             LDR      R0,??DataTable33_10  ;; 0x40064004
   \   0000008C   0x7800             LDRB     R0,[R0, #+0]
   \   0000008E   0xB2C0             UXTB     R0,R0
   \   00000090   0x06C0             LSLS     R0,R0,#+27       ;; ZeroExtS R0,R0,#+27,#+27
   \   00000092   0x0EC0             LSRS     R0,R0,#+27
   \   00000094   0x0005             MOVS     R5,R0
   1795                      ulFreqout = ulFreqout/((ulDivider+1)*(ulDividerPll+1));
   \   00000096   0x0030             MOVS     R0,R6
   \   00000098   0x0021             MOVS     R1,R4
   \   0000009A   0x1C49             ADDS     R1,R1,#+1
   \   0000009C   0x002A             MOVS     R2,R5
   \   0000009E   0x1C52             ADDS     R2,R2,#+1
   \   000000A0   0x4351             MULS     R1,R2,R1
   \   000000A2   0x.... 0x....      BL       __aeabi_uidiv
   \   000000A6   0x0006             MOVS     R6,R0
   \   000000A8   0xE01F             B        ??SysCtlHClockGet_1
   1796                  }
   1797                  //
   1798                  // FLL
   1799                  //
   1800                  else
   1801                  {
   1802                      //
   1803                      // The slow internal reference clock is FLL Source
   1804                      //
   1805                      if((xHWREG(MCG_C1)&MCG_C1_IREFS) == MCG_C1_IREFS)
   \                     ??SysCtlHClockGet_4:
   \   000000AA   0x....             LDR      R0,??DataTable33_3  ;; 0x40064000
   \   000000AC   0x6800             LDR      R0,[R0, #+0]
   \   000000AE   0x0740             LSLS     R0,R0,#+29
   \   000000B0   0xD50C             BPL      ??SysCtlHClockGet_5
   1806                      {
   1807                          ulFreqout = 96000000;
   \   000000B2   0x....             LDR      R0,??DataTable33_11  ;; 0x5b8d800
   \   000000B4   0x0006             MOVS     R6,R0
   1808                          ulDivider = (xHWREG(SIM_CLKDIV1) & SIM_CLKDIV1_OUTDIV1_M) >> SIM_CLKDIV1_OUTDIV1_S;
   \   000000B6   0x....             LDR      R0,??DataTable33_6  ;; 0x40048044
   \   000000B8   0x6800             LDR      R0,[R0, #+0]
   \   000000BA   0x0F00             LSRS     R0,R0,#+28
   \   000000BC   0x0004             MOVS     R4,R0
   1809                          ulFreqout = ulFreqout/(ulDivider+1);            
   \   000000BE   0x0030             MOVS     R0,R6
   \   000000C0   0x0021             MOVS     R1,R4
   \   000000C2   0x1C49             ADDS     R1,R1,#+1
   \   000000C4   0x.... 0x....      BL       __aeabi_uidiv
   \   000000C8   0x0006             MOVS     R6,R0
   \   000000CA   0xE00E             B        ??SysCtlHClockGet_1
   1810                      }
   1811                      //
   1812                      // The external reference clock is FLL Source
   1813                      //
   1814                      else
   1815                      {
   1816                          ulFreqout = s_ulExtClockMHz * 1000000;
   \                     ??SysCtlHClockGet_5:
   \   000000CC   0x....             LDR      R0,??DataTable33_4
   \   000000CE   0x6800             LDR      R0,[R0, #+0]
   \   000000D0   0x....             LDR      R1,??DataTable33_5  ;; 0xf4240
   \   000000D2   0x4348             MULS     R0,R1,R0
   \   000000D4   0x0006             MOVS     R6,R0
   1817                          ulDivider = (xHWREG(SIM_CLKDIV1) & SIM_CLKDIV1_OUTDIV1_M) >> SIM_CLKDIV1_OUTDIV1_S;
   \   000000D6   0x....             LDR      R0,??DataTable33_6  ;; 0x40048044
   \   000000D8   0x6800             LDR      R0,[R0, #+0]
   \   000000DA   0x0F00             LSRS     R0,R0,#+28
   \   000000DC   0x0004             MOVS     R4,R0
   1818                          ulFreqout = ulFreqout/(ulDivider+1);            
   \   000000DE   0x0030             MOVS     R0,R6
   \   000000E0   0x0021             MOVS     R1,R4
   \   000000E2   0x1C49             ADDS     R1,R1,#+1
   \   000000E4   0x.... 0x....      BL       __aeabi_uidiv
   \   000000E8   0x0006             MOVS     R6,R0
   1819                      }
   1820                  }
   1821              }
   1822          
   1823              return ulFreqout;
   \                     ??SysCtlHClockGet_1:
   \   000000EA   0x0030             MOVS     R0,R6
   \   000000EC   0xBD70             POP      {R4-R6,PC}       ;; return
   1824          }
   1825          
   1826          //*****************************************************************************
   1827          //
   1828          //! \brief This function is used to set HCLK for the system
   1829          //!
   1830          //! \param ulSysClk is the clock rate you will set.
   1831          //! \param ulConfig is the required configuration of the device clock.
   1832          //!
   1833          //! The \e ulConfig parameter is the logical OR of several different values,
   1834          //! many of which are grouped into sets where only one can be chosen.
   1835          //! 
   1836          //! The external crystal frequency is chosen with one of the following values:
   1837          //! \b SYSCTL_XTAL_3MHZ, \b SYSCTL_XTAL_4MHZ, 
   1838          //! \b SYSCTL_XTAL_5MHZ, \b SYSCTL_XTAL_6MHZ, ...
   1839          //! \b SYSCTL_XTAL_32MHZ, 
   1840          //!
   1841          //! The HCLK source is chosen with one of the following values:
   1842          //! \b SYSCTL_OSC_MAIN, \b SYSCTL_OSC_PLL, \b SYSCTL_OSC_INT_FAST,
   1843          //! \b SYSCTL_OSC_FLL_INT, \b SYSCTL_OSC_FLL_MAIN, \b SYSCTL_OSC_INT. 
   1844          //! 
   1845          //! \note The ulSysClk should be External Reference Clock Rate if you Set the 
   1846          //! parameter ulConfig is SYSCTL_OSC_FLL_MAIN.
   1847          //! \return None.
   1848          //
   1849          //*****************************************************************************

   \                                 In section .text, align 4, keep-with-next
   1850          void
   1851          SysCtlHClockSet(unsigned long ulSysClk, unsigned long ulConfig)
   1852          {
   \                     SysCtlHClockSet:
   \   00000000   0xB5F3             PUSH     {R0,R1,R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   1853          
   1854              unsigned long ulOscFreq=0, ulSysDiv, ulCount, i, ucTempReg, ulTemp;
   \   00000004   0x2700             MOVS     R7,#+0
   1855              xASSERT((ulSysClk > 0 && ulSysClk <= 48000000));
   1856          
   1857              ulSysDiv = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x0005             MOVS     R5,R0
   1858              //
   1859              // Calc oscillator freq
   1860              //
   1861              s_ulExtClockMHz = ((ulConfig & SYSCTL_XTAL_MASK) >> 8);
   \   0000000A   0x9804             LDR      R0,[SP, #+16]
   \   0000000C   0x0A00             LSRS     R0,R0,#+8
   \   0000000E   0xB2C0             UXTB     R0,R0
   \   00000010   0x49C1             LDR      R1,??SysCtlHClockSet_0
   \   00000012   0x6008             STR      R0,[R1, #+0]
   1862          
   1863              //
   1864              // HLCK clock source is SYSCTL_OSC_FLL_INT
   1865              //
   1866              if((ulConfig & 0x0F) == SYSCTL_OSC_FLL_INT)
   \   00000014   0x9804             LDR      R0,[SP, #+16]
   \   00000016   0x0700             LSLS     R0,R0,#+28       ;; ZeroExtS R0,R0,#+28,#+28
   \   00000018   0x0F00             LSRS     R0,R0,#+28
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD152             BNE      ??SysCtlHClockSet_1
   1867              {
   1868                  ulOscFreq = 96000000;
   \   0000001E   0x48BF             LDR      R0,??SysCtlHClockSet_0+0x4  ;; 0x5b8d800
   \   00000020   0x0007             MOVS     R7,R0
   1869                  xHWREG(MCG_C1) &= 0x3F;
   \   00000022   0x48BF             LDR      R0,??SysCtlHClockSet_0+0x8  ;; 0x40064000
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x0680             LSLS     R0,R0,#+26       ;; ZeroExtS R0,R0,#+26,#+26
   \   00000028   0x0E80             LSRS     R0,R0,#+26
   \   0000002A   0x49BD             LDR      R1,??SysCtlHClockSet_0+0x8  ;; 0x40064000
   \   0000002C   0x6008             STR      R0,[R1, #+0]
   1870                  xHWREG(MCG_C1) |= MCG_C1_IREFS;
   \   0000002E   0x48BC             LDR      R0,??SysCtlHClockSet_0+0x8  ;; 0x40064000
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x2104             MOVS     R1,#+4
   \   00000034   0x4301             ORRS     R1,R1,R0
   \   00000036   0x48BA             LDR      R0,??SysCtlHClockSet_0+0x8  ;; 0x40064000
   \   00000038   0x6001             STR      R1,[R0, #+0]
   1871                  xHWREG(MCG_C6) &= ~MCG_C6_PLLS;
   \   0000003A   0x48BA             LDR      R0,??SysCtlHClockSet_0+0xC  ;; 0x40064005
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x2140             MOVS     R1,#+64
   \   00000040   0x4388             BICS     R0,R0,R1
   \   00000042   0x49B8             LDR      R1,??SysCtlHClockSet_0+0xC  ;; 0x40064005
   \   00000044   0x6008             STR      R0,[R1, #+0]
   1872                  SysCtlHClockSourceSet(SYSCTL_HLCK_S_INT);
   \   00000046   0x2040             MOVS     R0,#+64
   \   00000048   0x.... 0x....      BL       SysCtlHClockSourceSet
   1873                  SysCtlDelay(100);
   \   0000004C   0x2064             MOVS     R0,#+100
   \   0000004E   0x.... 0x....      BL       SysCtlDelay
   1874                  if((ulConfig & OSC0_CR_ERCLKEN)!=0)
   \   00000052   0x9804             LDR      R0,[SP, #+16]
   \   00000054   0x0600             LSLS     R0,R0,#+24
   \   00000056   0xD505             BPL      ??SysCtlHClockSet_2
   1875                  {
   1876                      xHWREG(OSC0_CR) &= ~OSC0_CR_ERCLKEN;
   \   00000058   0x48B3             LDR      R0,??SysCtlHClockSet_0+0x10  ;; 0x40065000
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0x2180             MOVS     R1,#+128
   \   0000005E   0x4388             BICS     R0,R0,R1
   \   00000060   0x49B1             LDR      R1,??SysCtlHClockSet_0+0x10  ;; 0x40065000
   \   00000062   0x6008             STR      R0,[R1, #+0]
   1877                  }
   1878                  xHWREG(MCG_C5) &= ~MCG_C5_PLLCLKEN0;
   \                     ??SysCtlHClockSet_2:
   \   00000064   0x48B1             LDR      R0,??SysCtlHClockSet_0+0x14  ;; 0x40064004
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0x2140             MOVS     R1,#+64
   \   0000006A   0x4388             BICS     R0,R0,R1
   \   0000006C   0x49AF             LDR      R1,??SysCtlHClockSet_0+0x14  ;; 0x40064004
   \   0000006E   0x6008             STR      R0,[R1, #+0]
   1879                  xHWREG(MCG_C4) |= MCG_C4_DMX32;
   \   00000070   0x48AF             LDR      R0,??SysCtlHClockSet_0+0x18  ;; 0x40064003
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x2180             MOVS     R1,#+128
   \   00000076   0x4301             ORRS     R1,R1,R0
   \   00000078   0x48AD             LDR      R0,??SysCtlHClockSet_0+0x18  ;; 0x40064003
   \   0000007A   0x6001             STR      R1,[R0, #+0]
   1880                  xHWREG(MCG_C4) |= MCG_C4_DRST_DRS_MID_HIGH;
   \   0000007C   0x48AC             LDR      R0,??SysCtlHClockSet_0+0x18  ;; 0x40064003
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0x2140             MOVS     R1,#+64
   \   00000082   0x4301             ORRS     R1,R1,R0
   \   00000084   0x48AA             LDR      R0,??SysCtlHClockSet_0+0x18  ;; 0x40064003
   \   00000086   0x6001             STR      R1,[R0, #+0]
   1881                  if(ulSysClk <= ulOscFreq)
   \   00000088   0x9803             LDR      R0,[SP, #+12]
   \   0000008A   0x4287             CMP      R7,R0
   \   0000008C   0xD30D             BCC      ??SysCtlHClockSet_3
   1882                  {
   1883                      //
   1884                      // Calc the SysDiv
   1885                      //    
   1886                      xASSERT(ulSysClk <= ulOscFreq);
   1887                      
   1888                      for(ulSysDiv = 1; ulSysDiv < 16; ulSysDiv++)
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0x0005             MOVS     R5,R0
   \                     ??SysCtlHClockSet_4:
   \   00000092   0x2D10             CMP      R5,#+16
   \   00000094   0xD209             BCS      ??SysCtlHClockSet_3
   1889                      {
   1890                          if((ulOscFreq / (ulSysDiv + 1)) <= ulSysClk)
   \   00000096   0x0038             MOVS     R0,R7
   \   00000098   0x0029             MOVS     R1,R5
   \   0000009A   0x1C49             ADDS     R1,R1,#+1
   \   0000009C   0x.... 0x....      BL       __aeabi_uidiv
   \   000000A0   0x9903             LDR      R1,[SP, #+12]
   \   000000A2   0x4281             CMP      R1,R0
   \   000000A4   0xD201             BCS      ??SysCtlHClockSet_3
   1891                          {
   1892                              break;
   1893                          }
   1894                      }
   \                     ??SysCtlHClockSet_5:
   \   000000A6   0x1C6D             ADDS     R5,R5,#+1
   \   000000A8   0xE7F3             B        ??SysCtlHClockSet_4
   1895                  }
   1896                  xHWREG(SIM_CLKDIV1) &= ~SIM_CLKDIV1_OUTDIV1_M;
   \                     ??SysCtlHClockSet_3:
   \   000000AA   0x48C6             LDR      R0,??SysCtlHClockSet_6  ;; 0x40048044
   \   000000AC   0x6800             LDR      R0,[R0, #+0]
   \   000000AE   0x0100             LSLS     R0,R0,#+4        ;; ZeroExtS R0,R0,#+4,#+4
   \   000000B0   0x0900             LSRS     R0,R0,#+4
   \   000000B2   0x49C4             LDR      R1,??SysCtlHClockSet_6  ;; 0x40048044
   \   000000B4   0x6008             STR      R0,[R1, #+0]
   1897                  xHWREG(SIM_CLKDIV1) |= (ulSysDiv << SIM_CLKDIV1_OUTDIV1_S);
   \   000000B6   0x48C3             LDR      R0,??SysCtlHClockSet_6  ;; 0x40048044
   \   000000B8   0x6800             LDR      R0,[R0, #+0]
   \   000000BA   0x0729             LSLS     R1,R5,#+28
   \   000000BC   0x4301             ORRS     R1,R1,R0
   \   000000BE   0x48C1             LDR      R0,??SysCtlHClockSet_6  ;; 0x40048044
   \   000000C0   0x6001             STR      R1,[R0, #+0]
   \   000000C2   0xE263             B        ??SysCtlHClockSet_7
   1898              }
   1899              //
   1900              // HLCK clock source is SYSCTL_OSC_FLL_MAIN
   1901              //
   1902              else if((ulConfig & 0x0F) == SYSCTL_OSC_FLL_MAIN)
   \                     ??SysCtlHClockSet_1:
   \   000000C4   0x9804             LDR      R0,[SP, #+16]
   \   000000C6   0x0700             LSLS     R0,R0,#+28       ;; ZeroExtS R0,R0,#+28,#+28
   \   000000C8   0x0F00             LSRS     R0,R0,#+28
   \   000000CA   0x2808             CMP      R0,#+8
   \   000000CC   0xD173             BNE      ??SysCtlHClockSet_8
   1903              {
   1904                  if(!((((xHWREGB(MCG_S) & MCG_S_CLKST_M) >> MCG_S_CLKST_S) == 0x0) &&
   1905                    (xHWREGB(MCG_S) & MCG_S_IREFST) &&
   1906                    (!(xHWREGB(MCG_S) & MCG_S_PLLST))))                                
   \   000000CE   0x48BE             LDR      R0,??SysCtlHClockSet_6+0x4  ;; 0x40064006
   \   000000D0   0x7800             LDRB     R0,[R0, #+0]
   \   000000D2   0xB2C0             UXTB     R0,R0
   \   000000D4   0x1080             ASRS     R0,R0,#+2
   \   000000D6   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   000000D8   0x0F80             LSRS     R0,R0,#+30
   \   000000DA   0x2800             CMP      R0,#+0
   \   000000DC   0xD105             BNE      ??SysCtlHClockSet_9
   \   000000DE   0x48BA             LDR      R0,??SysCtlHClockSet_6+0x4  ;; 0x40064006
   \   000000E0   0x7800             LDRB     R0,[R0, #+0]
   \   000000E2   0x06C0             LSLS     R0,R0,#+27
   \   000000E4   0xD501             BPL      ??SysCtlHClockSet_9
   \   000000E6   0x48B8             LDR      R0,??SysCtlHClockSet_6+0x4  ;; 0x40064006
   \   000000E8   0x7800             LDRB     R0,[R0, #+0]
   1907                  {
   1908                  }
   1909                     
   1910                  ucTempReg = xHWREGB(MCG_C2);
   \                     ??SysCtlHClockSet_9:
   \   000000EA   0x48B8             LDR      R0,??SysCtlHClockSet_6+0x8  ;; 0x40064001
   \   000000EC   0x7800             LDRB     R0,[R0, #+0]
   \   000000EE   0xB2C0             UXTB     R0,R0
   \   000000F0   0x0006             MOVS     R6,R0
   1911                  ucTempReg &= ~(MCG_C2_RANGE0_M | MCG_C2_HGO0 | MCG_C2_EREFS0);
   \   000000F2   0x203C             MOVS     R0,#+60
   \   000000F4   0x4386             BICS     R6,R6,R0
   1912                  ucTempReg |= (MCG_C2_RANGE0_HIGH | MCG_C2_EREFS0); 
   \   000000F6   0x0030             MOVS     R0,R6
   \   000000F8   0x2614             MOVS     R6,#+20
   \   000000FA   0x4306             ORRS     R6,R6,R0
   1913                  xHWREGB(MCG_C2) = ucTempReg;
   \   000000FC   0x48B3             LDR      R0,??SysCtlHClockSet_6+0x8  ;; 0x40064001
   \   000000FE   0x0031             MOVS     R1,R6
   \   00000100   0x7001             STRB     R1,[R0, #+0]
   1914          
   1915                  ucTempReg = xHWREGB(MCG_C1);
   \   00000102   0x4887             LDR      R0,??SysCtlHClockSet_0+0x8  ;; 0x40064000
   \   00000104   0x7800             LDRB     R0,[R0, #+0]
   \   00000106   0xB2C0             UXTB     R0,R0
   \   00000108   0x0006             MOVS     R6,R0
   1916                  ucTempReg &= ~(MCG_C1_SRC_MCGOUTCLK_M | MCG_C1_FRDIV_M | MCG_C1_IREFS);
   \   0000010A   0x20FC             MOVS     R0,#+252
   \   0000010C   0x4386             BICS     R6,R6,R0
   1917                  ucTempReg |= (MCG_C1_SRC_MCGOUTCLK_EXTERAL | MCG_C1_FRDIV_256); 
   \   0000010E   0x0030             MOVS     R0,R6
   \   00000110   0x2698             MOVS     R6,#+152
   \   00000112   0x4306             ORRS     R6,R6,R0
   1918                  xHWREGB(MCG_C1) = ucTempReg;
   \   00000114   0x4882             LDR      R0,??SysCtlHClockSet_0+0x8  ;; 0x40064000
   \   00000116   0x0031             MOVS     R1,R6
   \   00000118   0x7001             STRB     R1,[R0, #+0]
   1919          
   1920                  for (i = 0 ; i < 20000 ; i++)
   \   0000011A   0x2000             MOVS     R0,#+0
   \   0000011C   0x0004             MOVS     R4,R0
   \                     ??SysCtlHClockSet_10:
   \   0000011E   0x48AC             LDR      R0,??SysCtlHClockSet_6+0xC  ;; 0x4e20
   \   00000120   0x4284             CMP      R4,R0
   \   00000122   0xD205             BCS      ??SysCtlHClockSet_11
   1921                  {
   1922                      if(xHWREGB(MCG_S) & MCG_S_OSCINIT0)
   \   00000124   0x48A8             LDR      R0,??SysCtlHClockSet_6+0x4  ;; 0x40064006
   \   00000126   0x7800             LDRB     R0,[R0, #+0]
   \   00000128   0x0780             LSLS     R0,R0,#+30
   \   0000012A   0xD401             BMI      ??SysCtlHClockSet_11
   1923                      {
   1924                          //
   1925                          // jump out early if OSCINIT sets before loop finishes
   1926                          //
   1927                          break;
   1928                      }
   1929                  }
   \                     ??SysCtlHClockSet_12:
   \   0000012C   0x1C64             ADDS     R4,R4,#+1
   \   0000012E   0xE7F6             B        ??SysCtlHClockSet_10
   1930                  //
   1931                  // wait for Reference clock Status bit to clear
   1932                  //
   1933                  for (i = 0 ; i < 20000 ; i++)
   \                     ??SysCtlHClockSet_11:
   \   00000130   0x2000             MOVS     R0,#+0
   \   00000132   0x0004             MOVS     R4,R0
   \                     ??SysCtlHClockSet_13:
   \   00000134   0x48A6             LDR      R0,??SysCtlHClockSet_6+0xC  ;; 0x4e20
   \   00000136   0x4284             CMP      R4,R0
   \   00000138   0xD205             BCS      ??SysCtlHClockSet_14
   1934                  {
   1935                      if(xHWREGB(MCG_S) & MCG_S_IREFST)
   \   0000013A   0x48A3             LDR      R0,??SysCtlHClockSet_6+0x4  ;; 0x40064006
   \   0000013C   0x7800             LDRB     R0,[R0, #+0]
   \   0000013E   0x06C0             LSLS     R0,R0,#+27
   \   00000140   0xD401             BMI      ??SysCtlHClockSet_14
   1936                      {
   1937                          //
   1938                          // jump out early if OSCINIT sets before loop finishes
   1939                          //
   1940                          break; 
   1941                      }
   1942                  }
   \                     ??SysCtlHClockSet_15:
   \   00000142   0x1C64             ADDS     R4,R4,#+1
   \   00000144   0xE7F6             B        ??SysCtlHClockSet_13
   1943                  //
   1944                  // Wait for clock status bits to show clock source is ext ref clk
   1945                  //
   1946                  for (i = 0 ; i < 20000 ; i++)
   \                     ??SysCtlHClockSet_14:
   \   00000146   0x2000             MOVS     R0,#+0
   \   00000148   0x0004             MOVS     R4,R0
   \                     ??SysCtlHClockSet_16:
   \   0000014A   0x48A1             LDR      R0,??SysCtlHClockSet_6+0xC  ;; 0x4e20
   \   0000014C   0x4284             CMP      R4,R0
   \   0000014E   0xD208             BCS      ??SysCtlHClockSet_17
   1947                  {
   1948                      if((xHWREGB(MCG_S) & MCG_S_CLKST_M)==MCG_S_CLKST_EXT)
   \   00000150   0x489D             LDR      R0,??SysCtlHClockSet_6+0x4  ;; 0x40064006
   \   00000152   0x7800             LDRB     R0,[R0, #+0]
   \   00000154   0xB2C0             UXTB     R0,R0
   \   00000156   0x210C             MOVS     R1,#+12
   \   00000158   0x4001             ANDS     R1,R1,R0
   \   0000015A   0x2908             CMP      R1,#+8
   \   0000015C   0xD001             BEQ      ??SysCtlHClockSet_17
   1949                      {
   1950                          //
   1951                          // jump out early if CLKST shows EXT CLK slected before loop finishes
   1952                          //
   1953                          break;
   1954                      }
   1955                  }
   \                     ??SysCtlHClockSet_18:
   \   0000015E   0x1C64             ADDS     R4,R4,#+1
   \   00000160   0xE7F3             B        ??SysCtlHClockSet_16
   1956                  xHWREGB(MCG_C6) |= MCG_C6_CME0;
   \                     ??SysCtlHClockSet_17:
   \   00000162   0x4870             LDR      R0,??SysCtlHClockSet_0+0xC  ;; 0x40064005
   \   00000164   0x7800             LDRB     R0,[R0, #+0]
   \   00000166   0x2120             MOVS     R1,#+32
   \   00000168   0x4301             ORRS     R1,R1,R0
   \   0000016A   0x486E             LDR      R0,??SysCtlHClockSet_0+0xC  ;; 0x40064005
   \   0000016C   0x7001             STRB     R1,[R0, #+0]
   1957                  ulOscFreq = s_ulExtClockMHz * 1000000;
   \   0000016E   0x486A             LDR      R0,??SysCtlHClockSet_0
   \   00000170   0x6800             LDR      R0,[R0, #+0]
   \   00000172   0x49C7             LDR      R1,??SysCtlHClockSet_19  ;; 0xf4240
   \   00000174   0x4348             MULS     R0,R1,R0
   \   00000176   0x0007             MOVS     R7,R0
   1958                  if(ulSysClk <= ulOscFreq)
   \   00000178   0x9803             LDR      R0,[SP, #+12]
   \   0000017A   0x4287             CMP      R7,R0
   \   0000017C   0xD200             BCS      .+4
   \   0000017E   0xE205             B        ??SysCtlHClockSet_7
   1959                  {
   1960                      //
   1961                      // Calc the SysDiv
   1962                      //    
   1963                      xASSERT(ulSysClk <= ulOscFreq);
   1964                      
   1965                      for(ulSysDiv = 1; ulSysDiv < 16; ulSysDiv++)
   \   00000180   0x2001             MOVS     R0,#+1
   \   00000182   0x0005             MOVS     R5,R0
   \                     ??SysCtlHClockSet_20:
   \   00000184   0x2D10             CMP      R5,#+16
   \   00000186   0xD209             BCS      ??SysCtlHClockSet_21
   1966                      {
   1967                          if((ulOscFreq / (ulSysDiv + 1)) <= ulSysClk)
   \   00000188   0x0038             MOVS     R0,R7
   \   0000018A   0x0029             MOVS     R1,R5
   \   0000018C   0x1C49             ADDS     R1,R1,#+1
   \   0000018E   0x.... 0x....      BL       __aeabi_uidiv
   \   00000192   0x9903             LDR      R1,[SP, #+12]
   \   00000194   0x4281             CMP      R1,R0
   \   00000196   0xD201             BCS      ??SysCtlHClockSet_21
   1968                          {
   1969                              break;
   1970                          }
   1971                      }
   \                     ??SysCtlHClockSet_22:
   \   00000198   0x1C6D             ADDS     R5,R5,#+1
   \   0000019A   0xE7F3             B        ??SysCtlHClockSet_20
   1972                      xHWREG(SIM_CLKDIV1) &= ~SIM_CLKDIV1_OUTDIV1_M;
   \                     ??SysCtlHClockSet_21:
   \   0000019C   0x4889             LDR      R0,??SysCtlHClockSet_6  ;; 0x40048044
   \   0000019E   0x6800             LDR      R0,[R0, #+0]
   \   000001A0   0x0100             LSLS     R0,R0,#+4        ;; ZeroExtS R0,R0,#+4,#+4
   \   000001A2   0x0900             LSRS     R0,R0,#+4
   \   000001A4   0x4987             LDR      R1,??SysCtlHClockSet_6  ;; 0x40048044
   \   000001A6   0x6008             STR      R0,[R1, #+0]
   1973                      xHWREG(SIM_CLKDIV1) |= (ulSysDiv << SIM_CLKDIV1_OUTDIV1_S);
   \   000001A8   0x4886             LDR      R0,??SysCtlHClockSet_6  ;; 0x40048044
   \   000001AA   0x6800             LDR      R0,[R0, #+0]
   \   000001AC   0x0729             LSLS     R1,R5,#+28
   \   000001AE   0x4301             ORRS     R1,R1,R0
   \   000001B0   0x4884             LDR      R0,??SysCtlHClockSet_6  ;; 0x40048044
   \   000001B2   0x6001             STR      R1,[R0, #+0]
   \   000001B4   0xE1EA             B        ??SysCtlHClockSet_7
   1974                  }
   1975              }
   1976              //
   1977              // HLCK clock source is SYSCTL_OSC_INT_FAST
   1978              //
   1979              else if((ulConfig & 0x0F) == SYSCTL_OSC_INT_FAST)
   \                     ??SysCtlHClockSet_8:
   \   000001B6   0x9804             LDR      R0,[SP, #+16]
   \   000001B8   0x0700             LSLS     R0,R0,#+28       ;; ZeroExtS R0,R0,#+28,#+28
   \   000001BA   0x0F00             LSRS     R0,R0,#+28
   \   000001BC   0x2804             CMP      R0,#+4
   \   000001BE   0xD14A             BNE      ??SysCtlHClockSet_23
   1980              {
   1981                  ulOscFreq = 4000000;
   \   000001C0   0x48B4             LDR      R0,??SysCtlHClockSet_19+0x4  ;; 0x3d0900
   \   000001C2   0x0007             MOVS     R7,R0
   1982                  xHWREG(OSC0_CR) &= ~OSC0_CR_ERCLKEN;
   \   000001C4   0x4858             LDR      R0,??SysCtlHClockSet_0+0x10  ;; 0x40065000
   \   000001C6   0x6800             LDR      R0,[R0, #+0]
   \   000001C8   0x2180             MOVS     R1,#+128
   \   000001CA   0x4388             BICS     R0,R0,R1
   \   000001CC   0x4956             LDR      R1,??SysCtlHClockSet_0+0x10  ;; 0x40065000
   \   000001CE   0x6008             STR      R0,[R1, #+0]
   1983                  SysCtlHClockSourceSet(SYSCTL_HLCK_S_INT);
   \   000001D0   0x2040             MOVS     R0,#+64
   \   000001D2   0x.... 0x....      BL       SysCtlHClockSourceSet
   1984                  xHWREG(MCG_C6) &= ~MCG_C6_PLLS;
   \   000001D6   0x4853             LDR      R0,??SysCtlHClockSet_0+0xC  ;; 0x40064005
   \   000001D8   0x6800             LDR      R0,[R0, #+0]
   \   000001DA   0x2140             MOVS     R1,#+64
   \   000001DC   0x4388             BICS     R0,R0,R1
   \   000001DE   0x4951             LDR      R1,??SysCtlHClockSet_0+0xC  ;; 0x40064005
   \   000001E0   0x6008             STR      R0,[R1, #+0]
   1985                  xHWREG(MCG_C2) &= ~MCG_C2_LP;
   \   000001E2   0x487A             LDR      R0,??SysCtlHClockSet_6+0x8  ;; 0x40064001
   \   000001E4   0x6800             LDR      R0,[R0, #+0]
   \   000001E6   0x2102             MOVS     R1,#+2
   \   000001E8   0x4388             BICS     R0,R0,R1
   \   000001EA   0x4978             LDR      R1,??SysCtlHClockSet_6+0x8  ;; 0x40064001
   \   000001EC   0x6008             STR      R0,[R1, #+0]
   1986                  xHWREG(MCG_C2) |= MCG_C2_IRCS;
   \   000001EE   0x4877             LDR      R0,??SysCtlHClockSet_6+0x8  ;; 0x40064001
   \   000001F0   0x6800             LDR      R0,[R0, #+0]
   \   000001F2   0x2101             MOVS     R1,#+1
   \   000001F4   0x4301             ORRS     R1,R1,R0
   \   000001F6   0x4875             LDR      R0,??SysCtlHClockSet_6+0x8  ;; 0x40064001
   \   000001F8   0x6001             STR      R1,[R0, #+0]
   1987                  SysCtlDelay(100);
   \   000001FA   0x2064             MOVS     R0,#+100
   \   000001FC   0x.... 0x....      BL       SysCtlDelay
   1988                  if((ulConfig & OSC0_CR_ERCLKEN)!=0)
   \   00000200   0x9804             LDR      R0,[SP, #+16]
   \   00000202   0x0600             LSLS     R0,R0,#+24
   \   00000204   0xD505             BPL      ??SysCtlHClockSet_24
   1989                  {
   1990                      xHWREG(OSC0_CR) &= ~OSC0_CR_ERCLKEN;
   \   00000206   0x4848             LDR      R0,??SysCtlHClockSet_0+0x10  ;; 0x40065000
   \   00000208   0x6800             LDR      R0,[R0, #+0]
   \   0000020A   0x2180             MOVS     R1,#+128
   \   0000020C   0x4388             BICS     R0,R0,R1
   \   0000020E   0x4946             LDR      R1,??SysCtlHClockSet_0+0x10  ;; 0x40065000
   \   00000210   0x6008             STR      R0,[R1, #+0]
   1991                  }
   1992                  while(!(xHWREG(MCG_S)&MCG_S_CLKST_INT));
   \                     ??SysCtlHClockSet_24:
   \   00000212   0x486D             LDR      R0,??SysCtlHClockSet_6+0x4  ;; 0x40064006
   \   00000214   0x6800             LDR      R0,[R0, #+0]
   \   00000216   0x0740             LSLS     R0,R0,#+29
   \   00000218   0xD5FB             BPL      ??SysCtlHClockSet_24
   1993                  if(ulSysClk <= ulOscFreq)
   \   0000021A   0x9803             LDR      R0,[SP, #+12]
   \   0000021C   0x4287             CMP      R7,R0
   \   0000021E   0xD30D             BCC      ??SysCtlHClockSet_25
   1994                  {
   1995                      //
   1996                      // Calc the SysDiv
   1997                      //    
   1998                      xASSERT(ulSysClk <= ulOscFreq);
   1999                      
   2000                      for(ulSysDiv = 1; ulSysDiv < 16; ulSysDiv++)
   \   00000220   0x2001             MOVS     R0,#+1
   \   00000222   0x0005             MOVS     R5,R0
   \                     ??SysCtlHClockSet_26:
   \   00000224   0x2D10             CMP      R5,#+16
   \   00000226   0xD209             BCS      ??SysCtlHClockSet_25
   2001                      {
   2002                          if((ulOscFreq / (ulSysDiv + 1)) <= ulSysClk)
   \   00000228   0x0038             MOVS     R0,R7
   \   0000022A   0x0029             MOVS     R1,R5
   \   0000022C   0x1C49             ADDS     R1,R1,#+1
   \   0000022E   0x.... 0x....      BL       __aeabi_uidiv
   \   00000232   0x9903             LDR      R1,[SP, #+12]
   \   00000234   0x4281             CMP      R1,R0
   \   00000236   0xD201             BCS      ??SysCtlHClockSet_25
   2003                          {
   2004                              break;
   2005                          }
   2006                      }
   \                     ??SysCtlHClockSet_27:
   \   00000238   0x1C6D             ADDS     R5,R5,#+1
   \   0000023A   0xE7F3             B        ??SysCtlHClockSet_26
   2007                  }
   2008                  xHWREG(SIM_CLKDIV1) &= ~SIM_CLKDIV1_OUTDIV1_M;
   \                     ??SysCtlHClockSet_25:
   \   0000023C   0x4861             LDR      R0,??SysCtlHClockSet_6  ;; 0x40048044
   \   0000023E   0x6800             LDR      R0,[R0, #+0]
   \   00000240   0x0100             LSLS     R0,R0,#+4        ;; ZeroExtS R0,R0,#+4,#+4
   \   00000242   0x0900             LSRS     R0,R0,#+4
   \   00000244   0x495F             LDR      R1,??SysCtlHClockSet_6  ;; 0x40048044
   \   00000246   0x6008             STR      R0,[R1, #+0]
   2009                  xHWREG(SIM_CLKDIV1) |= (ulSysDiv << SIM_CLKDIV1_OUTDIV1_S);
   \   00000248   0x485E             LDR      R0,??SysCtlHClockSet_6  ;; 0x40048044
   \   0000024A   0x6800             LDR      R0,[R0, #+0]
   \   0000024C   0x0729             LSLS     R1,R5,#+28
   \   0000024E   0x4301             ORRS     R1,R1,R0
   \   00000250   0x485C             LDR      R0,??SysCtlHClockSet_6  ;; 0x40048044
   \   00000252   0x6001             STR      R1,[R0, #+0]
   \   00000254   0xE19A             B        ??SysCtlHClockSet_7
   2010              }
   2011              //
   2012              // HLCK clock source is SYSCTL_OSC_INT
   2013              //
   2014              else if((ulConfig & 0x0F) == SYSCTL_OSC_INT)
   2015              {
   2016                  if(!((((xHWREGB(MCG_S) & MCG_S_CLKST_M) >> MCG_S_CLKST_S) == 0x0) &&
   2017                    (xHWREGB(MCG_S) & MCG_S_IREFST) &&
   2018                    (!(xHWREGB(MCG_S) & MCG_S_PLLST))))                                
   2019                  {
   2020                  }
   2021                  xHWREG(MCG_C2) &= ~MCG_C2_IRCS;
   2022                  //
   2023                  // Change the CLKS mux to select the IRC as the MCGOUT
   2024                  //
   2025                  ucTempReg = xHWREGB(MCG_C1);
   2026                  ucTempReg &= ~MCG_C1_SRC_MCGOUTCLK_M;
   2027                  //
   2028                  // select IRC as the MCG clock sourse
   2029                  //
   2030                  ucTempReg |= MCG_C1_SRC_MCGOUTCLK_INTERAL;
   2031                  xHWREGB(MCG_C1) = ucTempReg;
   2032                  //
   2033                  // wait until internal reference switches to requested irc.
   2034                  //
   2035                  for (i = 0 ; i < 2000 ; i++)
   2036                  {
   2037                      if((xHWREGB(MCG_S) & MCG_S_IRCST) != MCG_S_IRCST)
   2038                      {
   2039                          break;
   2040                      }
   2041          
   2042                  }
   2043                  //
   2044                  // Wait for clock status bits to update
   2045                  //
   2046                  for (i = 0 ; i < 2000 ; i++)
   2047                  {
   2048                      if((xHWREGB(MCG_S) & MCG_S_CLKST_INT) == MCG_S_CLKST_INT)
   2049                      {
   2050                          break;            
   2051                      }
   2052          
   2053                  }
   2054              }
   2055              //
   2056              // HLCK clock source is SYSCTL_OSC_PLL
   2057              //
   2058              else if((ulConfig & 0xF0) == SYSCTL_OSC_PLL)
   \                     ??SysCtlHClockSet_23:
   \   00000256   0x9804             LDR      R0,[SP, #+16]
   \   00000258   0x21F0             MOVS     R1,#+240
   \   0000025A   0x4001             ANDS     R1,R1,R0
   \   0000025C   0x2920             CMP      R1,#+32
   \   0000025E   0xD000             BEQ      .+4
   \   00000260   0xE0B8             B        ??SysCtlHClockSet_28
   2059              {
   2060                  ulCount = 4096;
   \   00000262   0x2080             MOVS     R0,#+128
   \   00000264   0x0140             LSLS     R0,R0,#+5        ;; #+4096
   \   00000266   0x9000             STR      R0,[SP, #+0]
   2061                  xHWREG(OSC0_CR) |= OSC0_CR_ERCLKEN;
   \   00000268   0x482F             LDR      R0,??SysCtlHClockSet_0+0x10  ;; 0x40065000
   \   0000026A   0x6800             LDR      R0,[R0, #+0]
   \   0000026C   0x2180             MOVS     R1,#+128
   \   0000026E   0x4301             ORRS     R1,R1,R0
   \   00000270   0x482D             LDR      R0,??SysCtlHClockSet_0+0x10  ;; 0x40065000
   \   00000272   0x6001             STR      R1,[R0, #+0]
   2062                  while(ulCount--);
   \                     ??SysCtlHClockSet_29:
   \   00000274   0x9800             LDR      R0,[SP, #+0]
   \   00000276   0x1E41             SUBS     R1,R0,#+1
   \   00000278   0x9100             STR      R1,[SP, #+0]
   \   0000027A   0x2800             CMP      R0,#+0
   \   0000027C   0xD1FA             BNE      ??SysCtlHClockSet_29
   2063                  xHWREG(MCG_C2) |= MCG_C2_RANGE0_HIGH;
   \   0000027E   0x4853             LDR      R0,??SysCtlHClockSet_6+0x8  ;; 0x40064001
   \   00000280   0x6800             LDR      R0,[R0, #+0]
   \   00000282   0x2110             MOVS     R1,#+16
   \   00000284   0x4301             ORRS     R1,R1,R0
   \   00000286   0x4851             LDR      R0,??SysCtlHClockSet_6+0x8  ;; 0x40064001
   \   00000288   0x6001             STR      R1,[R0, #+0]
   2064                  xHWREG(MCG_C2) |= MCG_C2_HGO0;
   \   0000028A   0x4850             LDR      R0,??SysCtlHClockSet_6+0x8  ;; 0x40064001
   \   0000028C   0x6800             LDR      R0,[R0, #+0]
   \   0000028E   0x2108             MOVS     R1,#+8
   \   00000290   0x4301             ORRS     R1,R1,R0
   \   00000292   0x484E             LDR      R0,??SysCtlHClockSet_6+0x8  ;; 0x40064001
   \   00000294   0x6001             STR      R1,[R0, #+0]
   2065                  xHWREG(MCG_C2) &= ~MCG_C2_EREFS0;
   \   00000296   0x484D             LDR      R0,??SysCtlHClockSet_6+0x8  ;; 0x40064001
   \   00000298   0x6800             LDR      R0,[R0, #+0]
   \   0000029A   0x2104             MOVS     R1,#+4
   \   0000029C   0x4388             BICS     R0,R0,R1
   \   0000029E   0x494B             LDR      R1,??SysCtlHClockSet_6+0x8  ;; 0x40064001
   \   000002A0   0x6008             STR      R0,[R1, #+0]
   2066                  xHWREG(MCG_C1) |= MCG_C1_SRC_MCGOUTCLK_EXTERAL;
   \   000002A2   0x481F             LDR      R0,??SysCtlHClockSet_0+0x8  ;; 0x40064000
   \   000002A4   0x6800             LDR      R0,[R0, #+0]
   \   000002A6   0x2180             MOVS     R1,#+128
   \   000002A8   0x4301             ORRS     R1,R1,R0
   \   000002AA   0x481D             LDR      R0,??SysCtlHClockSet_0+0x8  ;; 0x40064000
   \   000002AC   0x6001             STR      R1,[R0, #+0]
   2067                  xHWREG(MCG_C1) |= MCG_C1_FRDIV_128;
   \   000002AE   0x481C             LDR      R0,??SysCtlHClockSet_0+0x8  ;; 0x40064000
   \   000002B0   0x6800             LDR      R0,[R0, #+0]
   \   000002B2   0x2110             MOVS     R1,#+16
   \   000002B4   0x4301             ORRS     R1,R1,R0
   \   000002B6   0x481A             LDR      R0,??SysCtlHClockSet_0+0x8  ;; 0x40064000
   \   000002B8   0x6001             STR      R1,[R0, #+0]
   2068                  xHWREG(MCG_C1) &= ~MCG_C1_IREFS;
   \   000002BA   0x4819             LDR      R0,??SysCtlHClockSet_0+0x8  ;; 0x40064000
   \   000002BC   0x6800             LDR      R0,[R0, #+0]
   \   000002BE   0x2104             MOVS     R1,#+4
   \   000002C0   0x4388             BICS     R0,R0,R1
   \   000002C2   0x4917             LDR      R1,??SysCtlHClockSet_0+0x8  ;; 0x40064000
   \   000002C4   0x6008             STR      R0,[R1, #+0]
   2069                  while(!(xHWREG(MCG_S)&MCG_S_OSCINIT0));
   \                     ??SysCtlHClockSet_30:
   \   000002C6   0x4840             LDR      R0,??SysCtlHClockSet_6+0x4  ;; 0x40064006
   \   000002C8   0x6800             LDR      R0,[R0, #+0]
   \   000002CA   0x0780             LSLS     R0,R0,#+30
   \   000002CC   0xD5FB             BPL      ??SysCtlHClockSet_30
   2070                  while((xHWREG(MCG_S)&MCG_S_IREFST));
   \                     ??SysCtlHClockSet_31:
   \   000002CE   0x483E             LDR      R0,??SysCtlHClockSet_6+0x4  ;; 0x40064006
   \   000002D0   0x6800             LDR      R0,[R0, #+0]
   \   000002D2   0x06C0             LSLS     R0,R0,#+27
   \   000002D4   0xD4FB             BMI      ??SysCtlHClockSet_31
   2071                  while(!(xHWREG(MCG_S)&MCG_S_CLKST_EXT));
   \                     ??SysCtlHClockSet_32:
   \   000002D6   0x483C             LDR      R0,??SysCtlHClockSet_6+0x4  ;; 0x40064006
   \   000002D8   0x6800             LDR      R0,[R0, #+0]
   \   000002DA   0x0700             LSLS     R0,R0,#+28
   \   000002DC   0xD5FB             BPL      ??SysCtlHClockSet_32
   2072                  xHWREG(MCG_C5) &= ~MCG_C5_PRDIV0_M;
   \   000002DE   0x4813             LDR      R0,??SysCtlHClockSet_0+0x14  ;; 0x40064004
   \   000002E0   0x6800             LDR      R0,[R0, #+0]
   \   000002E2   0x211F             MOVS     R1,#+31
   \   000002E4   0x4388             BICS     R0,R0,R1
   \   000002E6   0x4911             LDR      R1,??SysCtlHClockSet_0+0x14  ;; 0x40064004
   \   000002E8   0x6008             STR      R0,[R1, #+0]
   2073                      
   2074                  ulOscFreq = s_ulExtClockMHz*1000000;
   \   000002EA   0x480B             LDR      R0,??SysCtlHClockSet_0
   \   000002EC   0x6800             LDR      R0,[R0, #+0]
   \   000002EE   0x4968             LDR      R1,??SysCtlHClockSet_19  ;; 0xf4240
   \   000002F0   0x4348             MULS     R0,R1,R0
   \   000002F2   0x0007             MOVS     R7,R0
   2075                  if (ulSysClk <= ulOscFreq)
   \   000002F4   0x9803             LDR      R0,[SP, #+12]
   \   000002F6   0x4287             CMP      R7,R0
   \   000002F8   0xD329             BCC      ??SysCtlHClockSet_33
   2076                  {
   2077                      //
   2078                      // Calc the SysDiv
   2079                      //    
   2080                      xASSERT(ulSysClk <= ulOscFreq);
   2081                      
   2082                      for(ulSysDiv = 1; ulSysDiv < 16; ulSysDiv++)
   \   000002FA   0x2001             MOVS     R0,#+1
   \   000002FC   0x0005             MOVS     R5,R0
   \                     ??SysCtlHClockSet_34:
   \   000002FE   0x2D10             CMP      R5,#+16
   \   00000300   0xD218             BCS      ??SysCtlHClockSet_35
   2083                      {
   2084                          if((ulOscFreq / (ulSysDiv + 1)) <= ulSysClk)
   \   00000302   0x0038             MOVS     R0,R7
   \   00000304   0x0029             MOVS     R1,R5
   \   00000306   0x1C49             ADDS     R1,R1,#+1
   \   00000308   0x.... 0x....      BL       __aeabi_uidiv
   \   0000030C   0x9903             LDR      R1,[SP, #+12]
   \   0000030E   0x4281             CMP      R1,R0
   \   00000310   0xD210             BCS      ??SysCtlHClockSet_35
   2085                          {
   2086                              break;
   2087                          }
   2088                      }
   \                     ??SysCtlHClockSet_36:
   \   00000312   0x1C6D             ADDS     R5,R5,#+1
   \   00000314   0xE7F3             B        ??SysCtlHClockSet_34
   \   00000316   0xBF00             Nop      
   \                     ??SysCtlHClockSet_0:
   \   00000318   0x........         DC32     s_ulExtClockMHz
   \   0000031C   0x05B8D800         DC32     0x5b8d800
   \   00000320   0x40064000         DC32     0x40064000
   \   00000324   0x40064005         DC32     0x40064005
   \   00000328   0x40065000         DC32     0x40065000
   \   0000032C   0x40064004         DC32     0x40064004
   \   00000330   0x40064003         DC32     0x40064003
   2089                      xHWREG(SIM_CLKDIV1) &= ~SIM_CLKDIV1_OUTDIV1_M;
   \                     ??SysCtlHClockSet_35:
   \   00000334   0x4823             LDR      R0,??SysCtlHClockSet_6  ;; 0x40048044
   \   00000336   0x6800             LDR      R0,[R0, #+0]
   \   00000338   0x0100             LSLS     R0,R0,#+4        ;; ZeroExtS R0,R0,#+4,#+4
   \   0000033A   0x0900             LSRS     R0,R0,#+4
   \   0000033C   0x4921             LDR      R1,??SysCtlHClockSet_6  ;; 0x40048044
   \   0000033E   0x6008             STR      R0,[R1, #+0]
   2090                      xHWREG(SIM_CLKDIV1) |= (ulSysDiv << SIM_CLKDIV1_OUTDIV1_S);
   \   00000340   0x4820             LDR      R0,??SysCtlHClockSet_6  ;; 0x40048044
   \   00000342   0x6800             LDR      R0,[R0, #+0]
   \   00000344   0x0729             LSLS     R1,R5,#+28
   \   00000346   0x4301             ORRS     R1,R1,R0
   \   00000348   0x481E             LDR      R0,??SysCtlHClockSet_6  ;; 0x40048044
   \   0000034A   0x6001             STR      R1,[R0, #+0]
   \   0000034C   0xE11E             B        ??SysCtlHClockSet_7
   2091                  }
   2092                  else
   2093                  {
   2094                      xHWREG(MCG_C6) |= MCG_C6_PLLS;
   \                     ??SysCtlHClockSet_33:
   \   0000034E   0x....             LDR      R0,??DataTable37  ;; 0x40064005
   \   00000350   0x6800             LDR      R0,[R0, #+0]
   \   00000352   0x2140             MOVS     R1,#+64
   \   00000354   0x4301             ORRS     R1,R1,R0
   \   00000356   0x....             LDR      R0,??DataTable37  ;; 0x40064005
   \   00000358   0x6001             STR      R1,[R0, #+0]
   2095                      while(!(xHWREG(MCG_S)&MCG_S_PLLST));
   \                     ??SysCtlHClockSet_37:
   \   0000035A   0x481B             LDR      R0,??SysCtlHClockSet_6+0x4  ;; 0x40064006
   \   0000035C   0x6800             LDR      R0,[R0, #+0]
   \   0000035E   0x0680             LSLS     R0,R0,#+26
   \   00000360   0xD5FB             BPL      ??SysCtlHClockSet_37
   2096                      while(!(xHWREG(MCG_S)&MCG_S_LOCK0));
   \                     ??SysCtlHClockSet_38:
   \   00000362   0x4819             LDR      R0,??SysCtlHClockSet_6+0x4  ;; 0x40064006
   \   00000364   0x6800             LDR      R0,[R0, #+0]
   \   00000366   0x0640             LSLS     R0,R0,#+25
   \   00000368   0xD5FB             BPL      ??SysCtlHClockSet_38
   2097                      SysCtlHClockSourceSet(SYSCTL_HLCK_S_PLL);
   \   0000036A   0x2000             MOVS     R0,#+0
   \   0000036C   0x.... 0x....      BL       SysCtlHClockSourceSet
   2098                      while(!((xHWREG(MCG_S)&MCG_S_CLKST_PLL)==MCG_S_CLKST_PLL));
   \                     ??SysCtlHClockSet_39:
   \   00000370   0x4815             LDR      R0,??SysCtlHClockSet_6+0x4  ;; 0x40064006
   \   00000372   0x6800             LDR      R0,[R0, #+0]
   \   00000374   0x210C             MOVS     R1,#+12
   \   00000376   0x4001             ANDS     R1,R1,R0
   \   00000378   0x290C             CMP      R1,#+12
   \   0000037A   0xD1F9             BNE      ??SysCtlHClockSet_39
   2099                      xHWREG(MCG_C6) |= MCG_C6_VDIV0_48;
   \   0000037C   0x....             LDR      R0,??DataTable37  ;; 0x40064005
   \   0000037E   0x6800             LDR      R0,[R0, #+0]
   \   00000380   0x2118             MOVS     R1,#+24
   \   00000382   0x4301             ORRS     R1,R1,R0
   \   00000384   0x....             LDR      R0,??DataTable37  ;; 0x40064005
   \   00000386   0x6001             STR      R1,[R0, #+0]
   2100                      ulOscFreq = 48*ulOscFreq;
   \   00000388   0x2030             MOVS     R0,#+48
   \   0000038A   0x4347             MULS     R7,R0,R7
   2101                      for(ulSysDiv = 1; ulSysDiv < 16; ulSysDiv++)
   \   0000038C   0x2001             MOVS     R0,#+1
   \   0000038E   0x0005             MOVS     R5,R0
   \                     ??SysCtlHClockSet_40:
   \   00000390   0x2D10             CMP      R5,#+16
   \   00000392   0xD209             BCS      ??SysCtlHClockSet_41
   2102                      {
   2103                          if((ulOscFreq / (ulSysDiv + 1)) <= ulSysClk)
   \   00000394   0x0038             MOVS     R0,R7
   \   00000396   0x0029             MOVS     R1,R5
   \   00000398   0x1C49             ADDS     R1,R1,#+1
   \   0000039A   0x.... 0x....      BL       __aeabi_uidiv
   \   0000039E   0x9903             LDR      R1,[SP, #+12]
   \   000003A0   0x4281             CMP      R1,R0
   \   000003A2   0xD201             BCS      ??SysCtlHClockSet_41
   2104                          {
   2105                              break;
   2106                          }
   2107                      }
   \                     ??SysCtlHClockSet_42:
   \   000003A4   0x1C6D             ADDS     R5,R5,#+1
   \   000003A6   0xE7F3             B        ??SysCtlHClockSet_40
   2108                      xHWREG(SIM_CLKDIV1) &= ~SIM_CLKDIV1_OUTDIV1_M;
   \                     ??SysCtlHClockSet_41:
   \   000003A8   0x4806             LDR      R0,??SysCtlHClockSet_6  ;; 0x40048044
   \   000003AA   0x6800             LDR      R0,[R0, #+0]
   \   000003AC   0x0100             LSLS     R0,R0,#+4        ;; ZeroExtS R0,R0,#+4,#+4
   \   000003AE   0x0900             LSRS     R0,R0,#+4
   \   000003B0   0x4904             LDR      R1,??SysCtlHClockSet_6  ;; 0x40048044
   \   000003B2   0x6008             STR      R0,[R1, #+0]
   2109                      xHWREG(SIM_CLKDIV1) |= (ulSysDiv << SIM_CLKDIV1_OUTDIV1_S);
   \   000003B4   0x4803             LDR      R0,??SysCtlHClockSet_6  ;; 0x40048044
   \   000003B6   0x6800             LDR      R0,[R0, #+0]
   \   000003B8   0x0729             LSLS     R1,R5,#+28
   \   000003BA   0x4301             ORRS     R1,R1,R0
   \   000003BC   0x4801             LDR      R0,??SysCtlHClockSet_6  ;; 0x40048044
   \   000003BE   0x6001             STR      R1,[R0, #+0]
   \   000003C0   0xE0E4             B        ??SysCtlHClockSet_7
   \   000003C2   0xBF00             Nop      
   \                     ??SysCtlHClockSet_6:
   \   000003C4   0x40048044         DC32     0x40048044
   \   000003C8   0x40064006         DC32     0x40064006
   \   000003CC   0x40064001         DC32     0x40064001
   \   000003D0   0x00004E20         DC32     0x4e20
   2110                  }
   2111              }
   2112              //
   2113              // HLCK clock source is SYSCTL_OSC_MAIN
   2114              //
   2115              else 
   2116              {
   2117                  xHWREG(SIM_CLKDIV1) &= ~SIM_CLKDIV1_OUTDIV1_M;
   \                     ??SysCtlHClockSet_28:
   \   000003D4   0x....             LDR      R0,??DataTable40  ;; 0x40048044
   \   000003D6   0x6800             LDR      R0,[R0, #+0]
   \   000003D8   0x0100             LSLS     R0,R0,#+4        ;; ZeroExtS R0,R0,#+4,#+4
   \   000003DA   0x0900             LSRS     R0,R0,#+4
   \   000003DC   0x....             LDR      R1,??DataTable40  ;; 0x40048044
   \   000003DE   0x6008             STR      R0,[R1, #+0]
   2118                  xHWREG(SIM_CLKDIV1) &= ~SIM_CLKDIV1_OUTDIV4_M;
   \   000003E0   0x....             LDR      R0,??DataTable40  ;; 0x40048044
   \   000003E2   0x6800             LDR      R0,[R0, #+0]
   \   000003E4   0x....             LDR      R1,??DataTable40_1  ;; 0xfff8ffff
   \   000003E6   0x4001             ANDS     R1,R1,R0
   \   000003E8   0x....             LDR      R0,??DataTable40  ;; 0x40048044
   \   000003EA   0x6001             STR      R1,[R0, #+0]
   2119                  xHWREG(SIM_CLKDIV1) |= SIM_CLKDIV1_OUTDIV4_2;
   \   000003EC   0x....             LDR      R0,??DataTable40  ;; 0x40048044
   \   000003EE   0x6800             LDR      R0,[R0, #+0]
   \   000003F0   0x2180             MOVS     R1,#+128
   \   000003F2   0x0249             LSLS     R1,R1,#+9        ;; #+65536
   \   000003F4   0x4301             ORRS     R1,R1,R0
   \   000003F6   0x....             LDR      R0,??DataTable40  ;; 0x40048044
   \   000003F8   0x6001             STR      R1,[R0, #+0]
   2120          
   2121                  if(!((((xHWREGB(MCG_S) & MCG_S_CLKST_M) >> MCG_S_CLKST_S) == 0x0) &&
   2122                    (xHWREGB(MCG_S) & MCG_S_IREFST) &&
   2123                    (!(xHWREGB(MCG_S) & MCG_S_PLLST))))                                
   \   000003FA   0x....             LDR      R0,??DataTable40_2  ;; 0x40064006
   \   000003FC   0x7800             LDRB     R0,[R0, #+0]
   \   000003FE   0xB2C0             UXTB     R0,R0
   \   00000400   0x1080             ASRS     R0,R0,#+2
   \   00000402   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   00000404   0x0F80             LSRS     R0,R0,#+30
   \   00000406   0x2800             CMP      R0,#+0
   \   00000408   0xD105             BNE      ??SysCtlHClockSet_43
   \   0000040A   0x....             LDR      R0,??DataTable40_2  ;; 0x40064006
   \   0000040C   0x7800             LDRB     R0,[R0, #+0]
   \   0000040E   0x06C0             LSLS     R0,R0,#+27
   \   00000410   0xD501             BPL      ??SysCtlHClockSet_43
   \   00000412   0x....             LDR      R0,??DataTable40_2  ;; 0x40064006
   \   00000414   0x7800             LDRB     R0,[R0, #+0]
   2124                  {
   2125                  }
   2126                     
   2127                  ucTempReg = xHWREGB(MCG_C2);
   \                     ??SysCtlHClockSet_43:
   \   00000416   0x....             LDR      R0,??DataTable40_3  ;; 0x40064001
   \   00000418   0x7800             LDRB     R0,[R0, #+0]
   \   0000041A   0xB2C0             UXTB     R0,R0
   \   0000041C   0x0006             MOVS     R6,R0
   2128                  ucTempReg &= ~(MCG_C2_RANGE0_M | MCG_C2_HGO0 | MCG_C2_EREFS0);
   \   0000041E   0x203C             MOVS     R0,#+60
   \   00000420   0x4386             BICS     R6,R6,R0
   2129                  ucTempReg |= (MCG_C2_RANGE0_HIGH | MCG_C2_EREFS0); 
   \   00000422   0x0030             MOVS     R0,R6
   \   00000424   0x2614             MOVS     R6,#+20
   \   00000426   0x4306             ORRS     R6,R6,R0
   2130                  xHWREGB(MCG_C2) = ucTempReg;
   \   00000428   0x....             LDR      R0,??DataTable40_3  ;; 0x40064001
   \   0000042A   0x0031             MOVS     R1,R6
   \   0000042C   0x7001             STRB     R1,[R0, #+0]
   2131          
   2132                  ucTempReg = xHWREGB(MCG_C1);
   \   0000042E   0x....             LDR      R0,??DataTable40_4  ;; 0x40064000
   \   00000430   0x7800             LDRB     R0,[R0, #+0]
   \   00000432   0xB2C0             UXTB     R0,R0
   \   00000434   0x0006             MOVS     R6,R0
   2133                  ucTempReg &= ~(MCG_C1_SRC_MCGOUTCLK_M | MCG_C1_FRDIV_M | MCG_C1_IREFS);
   \   00000436   0x20FC             MOVS     R0,#+252
   \   00000438   0x4386             BICS     R6,R6,R0
   2134                  ucTempReg |= (MCG_C1_SRC_MCGOUTCLK_EXTERAL | MCG_C1_FRDIV_256); 
   \   0000043A   0x0030             MOVS     R0,R6
   \   0000043C   0x2698             MOVS     R6,#+152
   \   0000043E   0x4306             ORRS     R6,R6,R0
   2135                  xHWREGB(MCG_C1) = ucTempReg;
   \   00000440   0x....             LDR      R0,??DataTable40_4  ;; 0x40064000
   \   00000442   0x0031             MOVS     R1,R6
   \   00000444   0x7001             STRB     R1,[R0, #+0]
   2136          
   2137                  for (i = 0 ; i < 20000 ; i++)
   \   00000446   0x2000             MOVS     R0,#+0
   \   00000448   0x0004             MOVS     R4,R0
   \                     ??SysCtlHClockSet_44:
   \   0000044A   0x....             LDR      R0,??DataTable41  ;; 0x4e20
   \   0000044C   0x4284             CMP      R4,R0
   \   0000044E   0xD205             BCS      ??SysCtlHClockSet_45
   2138                  {
   2139                      if(xHWREGB(MCG_S) & MCG_S_OSCINIT0)
   \   00000450   0x....             LDR      R0,??DataTable40_2  ;; 0x40064006
   \   00000452   0x7800             LDRB     R0,[R0, #+0]
   \   00000454   0x0780             LSLS     R0,R0,#+30
   \   00000456   0xD401             BMI      ??SysCtlHClockSet_45
   2140                      {
   2141                          //
   2142                          // jump out early if OSCINIT sets before loop finishes
   2143                          //
   2144                          break;
   2145                      }
   2146                  }
   \                     ??SysCtlHClockSet_46:
   \   00000458   0x1C64             ADDS     R4,R4,#+1
   \   0000045A   0xE7F6             B        ??SysCtlHClockSet_44
   2147                  //
   2148                  // wait for Reference clock Status bit to clear
   2149                  //
   2150                  for (i = 0 ; i < 20000 ; i++)
   \                     ??SysCtlHClockSet_45:
   \   0000045C   0x2000             MOVS     R0,#+0
   \   0000045E   0x0004             MOVS     R4,R0
   \                     ??SysCtlHClockSet_47:
   \   00000460   0x....             LDR      R0,??DataTable41  ;; 0x4e20
   \   00000462   0x4284             CMP      R4,R0
   \   00000464   0xD205             BCS      ??SysCtlHClockSet_48
   2151                  {
   2152                      if(xHWREGB(MCG_S) & MCG_S_IREFST)
   \   00000466   0x....             LDR      R0,??DataTable40_2  ;; 0x40064006
   \   00000468   0x7800             LDRB     R0,[R0, #+0]
   \   0000046A   0x06C0             LSLS     R0,R0,#+27
   \   0000046C   0xD401             BMI      ??SysCtlHClockSet_48
   2153                      {
   2154                          //
   2155                          // jump out early if OSCINIT sets before loop finishes
   2156                          //
   2157                          break; 
   2158                      }
   2159                  }
   \                     ??SysCtlHClockSet_49:
   \   0000046E   0x1C64             ADDS     R4,R4,#+1
   \   00000470   0xE7F6             B        ??SysCtlHClockSet_47
   2160                  //
   2161                  // Wait for clock status bits to show clock source is ext ref clk
   2162                  //
   2163                  for (i = 0 ; i < 20000 ; i++)
   \                     ??SysCtlHClockSet_48:
   \   00000472   0x2000             MOVS     R0,#+0
   \   00000474   0x0004             MOVS     R4,R0
   \                     ??SysCtlHClockSet_50:
   \   00000476   0x....             LDR      R0,??DataTable41  ;; 0x4e20
   \   00000478   0x4284             CMP      R4,R0
   \   0000047A   0xD20D             BCS      ??SysCtlHClockSet_51
   2164                  {
   2165                      if((xHWREGB(MCG_S) & MCG_S_CLKST_M)==MCG_S_CLKST_EXT)
   \   0000047C   0x....             LDR      R0,??DataTable40_2  ;; 0x40064006
   \   0000047E   0x7800             LDRB     R0,[R0, #+0]
   \   00000480   0xB2C0             UXTB     R0,R0
   \   00000482   0x210C             MOVS     R1,#+12
   \   00000484   0x4001             ANDS     R1,R1,R0
   \   00000486   0x2908             CMP      R1,#+8
   \   00000488   0xD006             BEQ      ??SysCtlHClockSet_51
   2166                      {
   2167                          //
   2168                          // jump out early if CLKST shows EXT CLK slected before loop finishes
   2169                          //
   2170                          break;
   2171                      }
   2172                  }
   \                     ??SysCtlHClockSet_52:
   \   0000048A   0x1C64             ADDS     R4,R4,#+1
   \   0000048C   0xE7F3             B        ??SysCtlHClockSet_50
   \   0000048E   0xBF00             Nop      
   \                     ??SysCtlHClockSet_19:
   \   00000490   0x000F4240         DC32     0xf4240
   \   00000494   0x003D0900         DC32     0x3d0900
   2173                  xHWREGB(MCG_C6) |= MCG_C6_CME0;
   \                     ??SysCtlHClockSet_51:
   \   00000498   0x....             LDR      R0,??DataTable37  ;; 0x40064005
   \   0000049A   0x7800             LDRB     R0,[R0, #+0]
   \   0000049C   0x2120             MOVS     R1,#+32
   \   0000049E   0x4301             ORRS     R1,R1,R0
   \   000004A0   0x....             LDR      R0,??DataTable37  ;; 0x40064005
   \   000004A2   0x7001             STRB     R1,[R0, #+0]
   2174          
   2175                  ucTempReg = xHWREGB(MCG_C5);
   \   000004A4   0x....             LDR      R0,??DataTable41_1  ;; 0x40064004
   \   000004A6   0x7800             LDRB     R0,[R0, #+0]
   \   000004A8   0xB2C0             UXTB     R0,R0
   \   000004AA   0x0006             MOVS     R6,R0
   2176                  ucTempReg &= ~(MCG_C5_PRDIV0_M);
   \   000004AC   0x201F             MOVS     R0,#+31
   \   000004AE   0x4386             BICS     R6,R6,R0
   2177                  ulTemp = ulSysClk/1000000;
   \   000004B0   0x9803             LDR      R0,[SP, #+12]
   \   000004B2   0x....             LDR      R1,??DataTable41_2  ;; 0xf4240
   \   000004B4   0x.... 0x....      BL       __aeabi_uidiv
   \   000004B8   0x9001             STR      R0,[SP, #+4]
   2178                  ulSysDiv = 192/ulTemp;
   \   000004BA   0x20C0             MOVS     R0,#+192
   \   000004BC   0x9901             LDR      R1,[SP, #+4]
   \   000004BE   0x.... 0x....      BL       __aeabi_uidiv
   \   000004C2   0x0005             MOVS     R5,R0
   2179                  if(ulSysDiv >= 24)
   \   000004C4   0x2D18             CMP      R5,#+24
   \   000004C6   0xD301             BCC      ??SysCtlHClockSet_53
   2180                  {
   2181                      ulSysDiv = 24;
   \   000004C8   0x2018             MOVS     R0,#+24
   \   000004CA   0x0005             MOVS     R5,R0
   2182                  }
   2183                  ucTempReg |= (ulSysDiv-1); 
   \                     ??SysCtlHClockSet_53:
   \   000004CC   0x0030             MOVS     R0,R6
   \   000004CE   0x1E6E             SUBS     R6,R5,#+1
   \   000004D0   0x4306             ORRS     R6,R6,R0
   2184                  xHWREGB(MCG_C5) = ucTempReg;
   \   000004D2   0x....             LDR      R0,??DataTable41_1  ;; 0x40064004
   \   000004D4   0x0031             MOVS     R1,R6
   \   000004D6   0x7001             STRB     R1,[R0, #+0]
   2185          
   2186                  ucTempReg = xHWREGB(MCG_C6);
   \   000004D8   0x....             LDR      R0,??DataTable37  ;; 0x40064005
   \   000004DA   0x7800             LDRB     R0,[R0, #+0]
   \   000004DC   0xB2C0             UXTB     R0,R0
   \   000004DE   0x0006             MOVS     R6,R0
   2187                  ucTempReg &= ~(MCG_C6_VDIV0_M);
   \   000004E0   0x201F             MOVS     R0,#+31
   \   000004E2   0x4386             BICS     R6,R6,R0
   2188                  ucTempReg |= (MCG_C6_PLLS | MCG_C6_VDIV0_24); 
   \   000004E4   0x0030             MOVS     R0,R6
   \   000004E6   0x2640             MOVS     R6,#+64
   \   000004E8   0x4306             ORRS     R6,R6,R0
   2189                  xHWREGB(MCG_C6) = ucTempReg;
   \   000004EA   0x....             LDR      R0,??DataTable37  ;; 0x40064005
   \   000004EC   0x0031             MOVS     R1,R6
   \   000004EE   0x7001             STRB     R1,[R0, #+0]
   2190                      
   2191                  //
   2192                  // wait for PLLST status bit to set
   2193                  //
   2194                  for(i = 0 ; i < 2000 ; i++)
   \   000004F0   0x2000             MOVS     R0,#+0
   \   000004F2   0x0004             MOVS     R4,R0
   \                     ??SysCtlHClockSet_54:
   \   000004F4   0x20FA             MOVS     R0,#+250
   \   000004F6   0x00C0             LSLS     R0,R0,#+3        ;; #+2000
   \   000004F8   0x4284             CMP      R4,R0
   \   000004FA   0xD205             BCS      ??SysCtlHClockSet_55
   2195                  {
   2196                      if(xHWREGB(MCG_S) & MCG_S_PLLST)
   \   000004FC   0x....             LDR      R0,??DataTable40_2  ;; 0x40064006
   \   000004FE   0x7800             LDRB     R0,[R0, #+0]
   \   00000500   0x0680             LSLS     R0,R0,#+26
   \   00000502   0xD401             BMI      ??SysCtlHClockSet_55
   2197                      {
   2198                          //
   2199                          // jump out early if PLLST sets before loop finishes
   2200                          //
   2201                          break; 
   2202                      }
   2203                  }
   \                     ??SysCtlHClockSet_56:
   \   00000504   0x1C64             ADDS     R4,R4,#+1
   \   00000506   0xE7F5             B        ??SysCtlHClockSet_54
   2204                  //
   2205                  // Wait for LOCK bit to set
   2206                  //
   2207                  for(i = 0 ; i < 4000 ; i++)
   \                     ??SysCtlHClockSet_55:
   \   00000508   0x2000             MOVS     R0,#+0
   \   0000050A   0x0004             MOVS     R4,R0
   \                     ??SysCtlHClockSet_57:
   \   0000050C   0x20FA             MOVS     R0,#+250
   \   0000050E   0x0100             LSLS     R0,R0,#+4        ;; #+4000
   \   00000510   0x4284             CMP      R4,R0
   \   00000512   0xD205             BCS      ??SysCtlHClockSet_58
   2208                  {
   2209                      if(xHWREGB(MCG_S)&MCG_S_LOCK0)
   \   00000514   0x....             LDR      R0,??DataTable40_2  ;; 0x40064006
   \   00000516   0x7800             LDRB     R0,[R0, #+0]
   \   00000518   0x0640             LSLS     R0,R0,#+25
   \   0000051A   0xD401             BMI      ??SysCtlHClockSet_58
   2210                      {
   2211                          //
   2212                          // jump out early if LOCK sets before loop finishes
   2213                          //
   2214                          break;
   2215                      }
   2216                  }
   \                     ??SysCtlHClockSet_59:
   \   0000051C   0x1C64             ADDS     R4,R4,#+1
   \   0000051E   0xE7F5             B        ??SysCtlHClockSet_57
   2217          
   2218                  SysCtlHClockSourceSet(SYSCTL_HLCK_S_PLL);
   \                     ??SysCtlHClockSet_58:
   \   00000520   0x2000             MOVS     R0,#+0
   \   00000522   0x.... 0x....      BL       SysCtlHClockSourceSet
   2219          
   2220                  //
   2221                  // Wait for clock status bits to update
   2222                  //
   2223                  for (i = 0 ; i < 2000 ; i++)
   \   00000526   0x2000             MOVS     R0,#+0
   \   00000528   0x0004             MOVS     R4,R0
   \                     ??SysCtlHClockSet_60:
   \   0000052A   0x20FA             MOVS     R0,#+250
   \   0000052C   0x00C0             LSLS     R0,R0,#+3        ;; #+2000
   \   0000052E   0x4284             CMP      R4,R0
   \   00000530   0xD208             BCS      ??SysCtlHClockSet_61
   2224                  {
   2225                      if((xHWREGB(MCG_S) & MCG_S_CLKST_PLL) == MCG_S_CLKST_PLL)
   \   00000532   0x....             LDR      R0,??DataTable40_2  ;; 0x40064006
   \   00000534   0x7800             LDRB     R0,[R0, #+0]
   \   00000536   0xB2C0             UXTB     R0,R0
   \   00000538   0x210C             MOVS     R1,#+12
   \   0000053A   0x4001             ANDS     R1,R1,R0
   \   0000053C   0x290C             CMP      R1,#+12
   \   0000053E   0xD001             BEQ      ??SysCtlHClockSet_61
   2226                      {
   2227                          break; // jump out early if CLKST = 3 before loop finishes            
   2228                      }
   2229          
   2230                  }
   \                     ??SysCtlHClockSet_62:
   \   00000540   0x1C64             ADDS     R4,R4,#+1
   \   00000542   0xE7F2             B        ??SysCtlHClockSet_60
   2231                  //
   2232                  // set PLLFLLSEL to select the PLL for this clock source
   2233                  //
   2234                  xHWREG(SIM_SOPT2) |= SIM_SOPT2_PLLFLLSEL;
   \                     ??SysCtlHClockSet_61:
   \   00000544   0x....             LDR      R0,??DataTable41_3  ;; 0x40048004
   \   00000546   0x6800             LDR      R0,[R0, #+0]
   \   00000548   0x2180             MOVS     R1,#+128
   \   0000054A   0x0249             LSLS     R1,R1,#+9        ;; #+65536
   \   0000054C   0x4301             ORRS     R1,R1,R0
   \   0000054E   0x....             LDR      R0,??DataTable41_3  ;; 0x40048004
   \   00000550   0x6001             STR      R1,[R0, #+0]
   2235          
   2236                  if (ulSysClk <= ulOscFreq)
   \   00000552   0x9803             LDR      R0,[SP, #+12]
   \   00000554   0x4287             CMP      R7,R0
   \   00000556   0xD319             BCC      ??SysCtlHClockSet_7
   2237                  {
   2238                      //
   2239                      // Calc the SysDiv
   2240                      //    
   2241                      xASSERT(ulSysClk <= ulOscFreq);
   2242                      
   2243                      for(ulSysDiv = 1; ulSysDiv < 16; ulSysDiv++)
   \   00000558   0x2001             MOVS     R0,#+1
   \   0000055A   0x0005             MOVS     R5,R0
   \                     ??SysCtlHClockSet_63:
   \   0000055C   0x2D10             CMP      R5,#+16
   \   0000055E   0xD209             BCS      ??SysCtlHClockSet_64
   2244                      {
   2245                          if((ulOscFreq / (ulSysDiv + 1)) <= ulSysClk)
   \   00000560   0x0038             MOVS     R0,R7
   \   00000562   0x0029             MOVS     R1,R5
   \   00000564   0x1C49             ADDS     R1,R1,#+1
   \   00000566   0x.... 0x....      BL       __aeabi_uidiv
   \   0000056A   0x9903             LDR      R1,[SP, #+12]
   \   0000056C   0x4281             CMP      R1,R0
   \   0000056E   0xD201             BCS      ??SysCtlHClockSet_64
   2246                          {
   2247                              break;
   2248                          }
   2249                      }
   \                     ??SysCtlHClockSet_65:
   \   00000570   0x1C6D             ADDS     R5,R5,#+1
   \   00000572   0xE7F3             B        ??SysCtlHClockSet_63
   2250                      xHWREG(SIM_CLKDIV1) &= ~SIM_CLKDIV1_OUTDIV1_M;
   \                     ??SysCtlHClockSet_64:
   \   00000574   0x....             LDR      R0,??DataTable40  ;; 0x40048044
   \   00000576   0x6800             LDR      R0,[R0, #+0]
   \   00000578   0x0100             LSLS     R0,R0,#+4        ;; ZeroExtS R0,R0,#+4,#+4
   \   0000057A   0x0900             LSRS     R0,R0,#+4
   \   0000057C   0x....             LDR      R1,??DataTable40  ;; 0x40048044
   \   0000057E   0x6008             STR      R0,[R1, #+0]
   2251                      xHWREG(SIM_CLKDIV1) |= (ulSysDiv << SIM_CLKDIV1_OUTDIV1_S);
   \   00000580   0x....             LDR      R0,??DataTable40  ;; 0x40048044
   \   00000582   0x6800             LDR      R0,[R0, #+0]
   \   00000584   0x0729             LSLS     R1,R5,#+28
   \   00000586   0x4301             ORRS     R1,R1,R0
   \   00000588   0x....             LDR      R0,??DataTable40  ;; 0x40048044
   \   0000058A   0x6001             STR      R1,[R0, #+0]
   2252                  }
   2253              }
   2254          }
   \                     ??SysCtlHClockSet_7:
   \   0000058C   0xB005             ADD      SP,SP,#+20
   \   0000058E   0xBDF0             POP      {R4-R7,PC}       ;; return
   2255          
   2256          //*****************************************************************************
   2257          //
   2258          //! \brief The function is used to Set Clock Output source. 
   2259          //!
   2260          //! \param ulClkOutSrc is the clock source of Clock Output.
   2261          //!
   2262          //! The function is used to Set Clock Output source.
   2263          //!
   2264          //! \return None.
   2265          //
   2266          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   2267          void SysCtlClkOututSrcSet(unsigned long ulClkOutSrc)
   2268          {
   2269              //
   2270              // Check the arguments.
   2271              //
   2272              xASSERT((ulClkOutSrc == SYSCTL_OUTPUT_CLKSRC_BUS)||
   2273                      (ulClkOutSrc == SYSCTL_OUTPUT_CLKSRC_LPO)||
   2274                      (ulClkOutSrc == SYSCTL_OUTPUT_CLKSRC_MCGIRCLK)||
   2275                      (ulClkOutSrc == SYSCTL_OUTPUT_CLKSRC_OSCERCLK));
   2276              //
   2277              // Select Output Clock Source.
   2278              //
   2279              xHWREG(SIM_SOPT2) &= ~SIM_SOPT2_CLKOUTSEL_M;
   \                     SysCtlClkOututSrcSet:
   \   00000000   0x....             LDR      R1,??DataTable41_3  ;; 0x40048004
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0x22E0             MOVS     R2,#+224
   \   00000006   0x4391             BICS     R1,R1,R2
   \   00000008   0x....             LDR      R2,??DataTable41_3  ;; 0x40048004
   \   0000000A   0x6011             STR      R1,[R2, #+0]
   2280              xHWREG(SIM_SOPT2) |= ulClkOutSrc;
   \   0000000C   0x....             LDR      R1,??DataTable41_3  ;; 0x40048004
   \   0000000E   0x6809             LDR      R1,[R1, #+0]
   \   00000010   0x4301             ORRS     R1,R1,R0
   \   00000012   0x....             LDR      R2,??DataTable41_3  ;; 0x40048004
   \   00000014   0x6011             STR      R1,[R2, #+0]
   2281          }
   \   00000016   0x4770             BX       LR               ;; return
   2282          
   2283          //*****************************************************************************
   2284          //
   2285          //! \brief The function is used to Set Bus Clock. 
   2286          //!
   2287          //! \param ulBusClk is the bus clock you will set.
   2288          //!
   2289          //! The function is used to Set Bus Clock.
   2290          //!
   2291          //! \return None.
   2292          //
   2293          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   2294          void SysCtlBusClkSet(unsigned long ulBusClk)
   2295          {
   \                     SysCtlBusClkSet:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0006             MOVS     R6,R0
   2296              unsigned long ulHclk = 0, ulSysDiv;
   \   00000004   0x2500             MOVS     R5,#+0
   2297          
   2298              //
   2299              // Check the arguments.
   2300              //
   2301              xASSERT((ulBusClk > 0 && ulBusClk <= 24000000));
   2302          
   2303              //
   2304              // Get the Hclk.
   2305              //
   2306              ulHclk = SysCtlHClockGet();
   \   00000006   0x.... 0x....      BL       SysCtlHClockGet
   \   0000000A   0x0005             MOVS     R5,R0
   2307              
   2308              if (ulBusClk <= ulHclk)
   \   0000000C   0x42B5             CMP      R5,R6
   \   0000000E   0xD318             BCC      ??SysCtlBusClkSet_0
   2309              {
   2310                  //
   2311                  // Calc the SysDiv
   2312                  //    
   2313                  xASSERT(ulBusClk <= ulHclk);
   2314                  
   2315                  for(ulSysDiv = 1; ulSysDiv < 8; ulSysDiv++)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x0004             MOVS     R4,R0
   \                     ??SysCtlBusClkSet_1:
   \   00000014   0x2C08             CMP      R4,#+8
   \   00000016   0xD208             BCS      ??SysCtlBusClkSet_2
   2316                  {
   2317                      if((ulHclk / (ulSysDiv + 1)) <= ulBusClk)
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0x0021             MOVS     R1,R4
   \   0000001C   0x1C49             ADDS     R1,R1,#+1
   \   0000001E   0x.... 0x....      BL       __aeabi_uidiv
   \   00000022   0x4286             CMP      R6,R0
   \   00000024   0xD201             BCS      ??SysCtlBusClkSet_2
   2318                      {
   2319                          break;
   2320                      }
   2321                  }
   \                     ??SysCtlBusClkSet_3:
   \   00000026   0x1C64             ADDS     R4,R4,#+1
   \   00000028   0xE7F4             B        ??SysCtlBusClkSet_1
   2322                  xHWREG(SIM_CLKDIV1) &= ~SIM_CLKDIV1_OUTDIV4_M;
   \                     ??SysCtlBusClkSet_2:
   \   0000002A   0x....             LDR      R0,??DataTable40  ;; 0x40048044
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x....             LDR      R1,??DataTable40_1  ;; 0xfff8ffff
   \   00000030   0x4001             ANDS     R1,R1,R0
   \   00000032   0x....             LDR      R0,??DataTable40  ;; 0x40048044
   \   00000034   0x6001             STR      R1,[R0, #+0]
   2323                  xHWREG(SIM_CLKDIV1) |= (ulSysDiv << SIM_CLKDIV1_OUTDIV4_S);
   \   00000036   0x....             LDR      R0,??DataTable40  ;; 0x40048044
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x0421             LSLS     R1,R4,#+16
   \   0000003C   0x4301             ORRS     R1,R1,R0
   \   0000003E   0x....             LDR      R0,??DataTable40  ;; 0x40048044
   \   00000040   0x6001             STR      R1,[R0, #+0]
   2324              }
   2325          }
   \                     ??SysCtlBusClkSet_0:
   \   00000042   0xBD70             POP      {R4-R6,PC}       ;; return
   2326          //*****************************************************************************
   2327          //
   2328          //! \brief The function is used to Get Bus Clock. 
   2329          //!
   2330          //! \param None.
   2331          //!
   2332          //! The function is used to Get Bus Clock.
   2333          //!
   2334          //! \return the Bus clock.
   2335          //
   2336          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   2337          unsigned long SysCtlBusClkGet(void)
   2338          {
   \                     SysCtlBusClkGet:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   2339              unsigned long ulHclk = 0, ulBusClk = 0, ulSysDiv;
   \   00000002   0x2600             MOVS     R6,#+0
   \   00000004   0x2500             MOVS     R5,#+0
   2340          
   2341              //
   2342              // Get the Hclk.
   2343              //
   2344              ulHclk = SysCtlHClockGet();
   \   00000006   0x.... 0x....      BL       SysCtlHClockGet
   \   0000000A   0x0006             MOVS     R6,R0
   2345              
   2346              //
   2347              // Calc the SysDiv
   2348              //    
   2349              ulSysDiv = (xHWREG(SIM_CLKDIV1) & SIM_CLKDIV1_OUTDIV4_M) >> SIM_CLKDIV1_OUTDIV4_S;
   \   0000000C   0x....             LDR      R0,??DataTable40  ;; 0x40048044
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x0C00             LSRS     R0,R0,#+16
   \   00000012   0x0740             LSLS     R0,R0,#+29       ;; ZeroExtS R0,R0,#+29,#+29
   \   00000014   0x0F40             LSRS     R0,R0,#+29
   \   00000016   0x0004             MOVS     R4,R0
   2350              
   2351              ulBusClk = ulHclk/(ulSysDiv+1);
   \   00000018   0x0030             MOVS     R0,R6
   \   0000001A   0x0021             MOVS     R1,R4
   \   0000001C   0x1C49             ADDS     R1,R1,#+1
   \   0000001E   0x.... 0x....      BL       __aeabi_uidiv
   \   00000022   0x0005             MOVS     R5,R0
   2352              
   2353              return ulBusClk;
   \   00000024   0x0028             MOVS     R0,R5
   \   00000026   0xBD70             POP      {R4-R6,PC}       ;; return
   2354          }
   2355          
   2356          //*****************************************************************************
   2357          //
   2358          //! \brief The function is to Enable Bandgap In VLPx Operation or not
   2359          //!
   2360          //! \param bEnable is a boolean that is \b true if Enable Bandgap In VLPx 
   2361          //! Operation and \b false if Disable it.
   2362          //!
   2363          //! The function is used to Enable Bandgap In VLPx Operation or not
   2364          //!
   2365          //! \return None.
   2366          //
   2367          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   2368          void 
   2369          SysCtlBandgapEnable(xtBoolean bEnable)
   2370          {
   \                     SysCtlBandgapEnable:
   \   00000000   0xB500             PUSH     {LR}
   2371              //
   2372              // Enable Bandgap In VLPx Operation.
   2373              //
   2374              if(bEnable)
   \   00000002   0xB2C0             UXTB     R0,R0
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD006             BEQ      ??SysCtlBandgapEnable_0
   2375              {
   2376                  xHWREGB(PMC_REGSC) |= PMC_REGSC_BGEN;
   \   00000008   0x....             LDR      R1,??DataTable41_4  ;; 0x4007d002
   \   0000000A   0x7809             LDRB     R1,[R1, #+0]
   \   0000000C   0x2210             MOVS     R2,#+16
   \   0000000E   0x430A             ORRS     R2,R2,R1
   \   00000010   0x....             LDR      R1,??DataTable41_4  ;; 0x4007d002
   \   00000012   0x700A             STRB     R2,[R1, #+0]
   \   00000014   0xE005             B        ??SysCtlBandgapEnable_1
   2377              }
   2378              //
   2379              // Disable Bandgap In VLPx Operation.
   2380              //
   2381              else
   2382              {
   2383                  xHWREGB(PMC_REGSC) &= ~PMC_REGSC_BGEN;
   \                     ??SysCtlBandgapEnable_0:
   \   00000016   0x....             LDR      R1,??DataTable41_4  ;; 0x4007d002
   \   00000018   0x7809             LDRB     R1,[R1, #+0]
   \   0000001A   0x22EF             MOVS     R2,#+239
   \   0000001C   0x400A             ANDS     R2,R2,R1
   \   0000001E   0x....             LDR      R1,??DataTable41_4  ;; 0x4007d002
   \   00000020   0x700A             STRB     R2,[R1, #+0]
   2384              }
   2385          }
   \                     ??SysCtlBandgapEnable_1:
   \   00000022   0xBD00             POP      {PC}             ;; return
   2386          
   2387          //*****************************************************************************
   2388          //
   2389          //! \brief The function is to Enable Bandgap Buffer or not
   2390          //!
   2391          //! \param bEnable is a boolean that is \b true if Enable Bandgap Buffer 
   2392          //! and \b false if Disable it.
   2393          //!
   2394          //! The function is used to Enable Bandgap Buffer or not
   2395          //!
   2396          //! \return None.
   2397          //
   2398          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   2399          void 
   2400          SysCtlBandgapBufferEnable(xtBoolean bEnable)
   2401          {
   \                     SysCtlBandgapBufferEnable:
   \   00000000   0xB500             PUSH     {LR}
   2402              //
   2403              // Enable Bandgap Buffer.
   2404              //
   2405              if(bEnable)
   \   00000002   0xB2C0             UXTB     R0,R0
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD006             BEQ      ??SysCtlBandgapBufferEnable_0
   2406              {
   2407                  xHWREGB(PMC_REGSC) |= PMC_REGSC_BGBE;
   \   00000008   0x....             LDR      R1,??DataTable41_4  ;; 0x4007d002
   \   0000000A   0x7809             LDRB     R1,[R1, #+0]
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0x430A             ORRS     R2,R2,R1
   \   00000010   0x....             LDR      R1,??DataTable41_4  ;; 0x4007d002
   \   00000012   0x700A             STRB     R2,[R1, #+0]
   \   00000014   0xE005             B        ??SysCtlBandgapBufferEnable_1
   2408              }
   2409              //
   2410              // Disable Bandgap Buffer.
   2411              //
   2412              else
   2413              {
   2414                  xHWREGB(PMC_REGSC) &= ~PMC_REGSC_BGBE;
   \                     ??SysCtlBandgapBufferEnable_0:
   \   00000016   0x....             LDR      R1,??DataTable41_4  ;; 0x4007d002
   \   00000018   0x7809             LDRB     R1,[R1, #+0]
   \   0000001A   0x22FE             MOVS     R2,#+254
   \   0000001C   0x400A             ANDS     R2,R2,R1
   \   0000001E   0x....             LDR      R1,??DataTable41_4  ;; 0x4007d002
   \   00000020   0x700A             STRB     R2,[R1, #+0]
   2415              }
   2416          }
   \                     ??SysCtlBandgapBufferEnable_1:
   \   00000022   0xBD00             POP      {PC}             ;; return
   2417          
   2418          //*****************************************************************************
   2419          //
   2420          //! \brief Get Status of Regulator In Run Regulation.
   2421          //!
   2422          //! \param None.
   2423          //!
   2424          //! This function is to Get Status of Regulator In Run Regulation.
   2425          //!
   2426          //! \return This function return Status of Regulator In Run Regulation,if Regulator
   2427          //! is in run regulation, it returns xtrue, xfalse if not.
   2428          //
   2429          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   2430          xtBoolean
   2431          SysCtlRegulatorStatusGet(void)
   2432          {
   \                     SysCtlRegulatorStatusGet:
   \   00000000   0xB500             PUSH     {LR}
   2433              xtBoolean xtFlag = 0;
   \   00000002   0x2100             MOVS     R1,#+0
   2434          
   2435              xtFlag = xHWREGB(PMC_REGSC) & PMC_REGSC_REGONS;
   \   00000004   0x....             LDR      R0,??DataTable41_4  ;; 0x4007d002
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2204             MOVS     R2,#+4
   \   0000000A   0x4010             ANDS     R0,R0,R2
   \   0000000C   0x0001             MOVS     R1,R0
   2436              if(xtFlag)
   \   0000000E   0xB2C9             UXTB     R1,R1
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD001             BEQ      ??SysCtlRegulatorStatusGet_0
   2437              {
   2438                  return xtrue;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xE000             B        ??SysCtlRegulatorStatusGet_1
   2439              }
   2440              else
   2441              {
   2442                  return xfalse;
   \                     ??SysCtlRegulatorStatusGet_0:
   \   00000018   0x2000             MOVS     R0,#+0
   \                     ??SysCtlRegulatorStatusGet_1:
   \   0000001A   0xBD00             POP      {PC}             ;; return
   2443              }
   2444          }
   2445          
   2446          //*****************************************************************************
   2447          //
   2448          //! \brief The function is used to Get PWM and UART0 Clock Rate. 
   2449          //!
   2450          //! \param None.
   2451          //!
   2452          //! The function is used to Get PWM and UART0 Clock Rate.
   2453          //!
   2454          //! \return the PWM and UART0 Clock Rate clock.
   2455          //
   2456          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   2457          unsigned long SysCtlPWMAndUART0ClkGet(void)
   2458          {
   \                     SysCtlPWMAndUART0ClkGet:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   2459              unsigned long ulHclk = 0, ulPWMClk = 0;
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0x2500             MOVS     R5,#+0
   2460          
   2461              //
   2462              // Check the PWM Clock Source.
   2463              //
   2464              if((xHWREG(SIM_SOPT2) & SIM_SOPT2_TPMSRC_MCGXLL)
   2465                                   == SIM_SOPT2_TPMSRC_MCGXLL)
   \   00000006   0x....             LDR      R0,??DataTable41_3  ;; 0x40048004
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x01C0             LSLS     R0,R0,#+7
   \   0000000C   0xD507             BPL      ??SysCtlPWMAndUART0ClkGet_0
   2466              {
   2467                  ulHclk = SysCtlHClockGet();
   \   0000000E   0x.... 0x....      BL       SysCtlHClockGet
   \   00000012   0x0004             MOVS     R4,R0
   2468                  ulPWMClk = ulHclk/2;
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x0840             LSRS     R0,R0,#+1
   \   00000018   0x0005             MOVS     R5,R0
   2469                  return ulPWMClk;
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0xE025             B        ??SysCtlPWMAndUART0ClkGet_1
   2470              }
   2471              else if((xHWREG(SIM_SOPT2) & SIM_SOPT2_TPMSRC_OSCERCLK)
   2472                                   == SIM_SOPT2_TPMSRC_OSCERCLK)
   \                     ??SysCtlPWMAndUART0ClkGet_0:
   \   0000001E   0x....             LDR      R0,??DataTable41_3  ;; 0x40048004
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x0180             LSLS     R0,R0,#+6
   \   00000024   0xD512             BPL      ??SysCtlPWMAndUART0ClkGet_2
   2473              {
   2474                  xHWREGB(OSC0_CR) |= OSC0_CR_ERCLKEN;
   \   00000026   0x....             LDR      R0,??DataTable41_5  ;; 0x40065000
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0x2180             MOVS     R1,#+128
   \   0000002C   0x4301             ORRS     R1,R1,R0
   \   0000002E   0x....             LDR      R0,??DataTable41_5  ;; 0x40065000
   \   00000030   0x7001             STRB     R1,[R0, #+0]
   2475                  xHWREGB(MCG_C2) |= MCG_C2_EREFS0;
   \   00000032   0x....             LDR      R0,??DataTable41_6  ;; 0x40064001
   \   00000034   0x7800             LDRB     R0,[R0, #+0]
   \   00000036   0x2104             MOVS     R1,#+4
   \   00000038   0x4301             ORRS     R1,R1,R0
   \   0000003A   0x....             LDR      R0,??DataTable41_6  ;; 0x40064001
   \   0000003C   0x7001             STRB     R1,[R0, #+0]
   2476                  ulPWMClk = s_ulExtClockMHz*1000000;
   \   0000003E   0x....             LDR      R0,??DataTable41_7
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x....             LDR      R1,??DataTable41_2  ;; 0xf4240
   \   00000044   0x4348             MULS     R0,R1,R0
   \   00000046   0x0005             MOVS     R5,R0
   2477                  return ulPWMClk;    
   \   00000048   0x0028             MOVS     R0,R5
   \   0000004A   0xE00E             B        ??SysCtlPWMAndUART0ClkGet_1
   2478              }
   2479              else
   2480              {
   2481                  xHWREGB(MCG_C1) |= MCG_C1_IRCLKEN;
   \                     ??SysCtlPWMAndUART0ClkGet_2:
   \   0000004C   0x....             LDR      R0,??DataTable41_8  ;; 0x40064000
   \   0000004E   0x7800             LDRB     R0,[R0, #+0]
   \   00000050   0x2102             MOVS     R1,#+2
   \   00000052   0x4301             ORRS     R1,R1,R0
   \   00000054   0x....             LDR      R0,??DataTable41_8  ;; 0x40064000
   \   00000056   0x7001             STRB     R1,[R0, #+0]
   2482                  xHWREGB(MCG_C2) |= MCG_C2_IRCS;
   \   00000058   0x....             LDR      R0,??DataTable41_6  ;; 0x40064001
   \   0000005A   0x7800             LDRB     R0,[R0, #+0]
   \   0000005C   0x2101             MOVS     R1,#+1
   \   0000005E   0x4301             ORRS     R1,R1,R0
   \   00000060   0x....             LDR      R0,??DataTable41_6  ;; 0x40064001
   \   00000062   0x7001             STRB     R1,[R0, #+0]
   2483                  ulPWMClk = 4000000;
   \   00000064   0x....             LDR      R0,??DataTable41_9  ;; 0x3d0900
   \   00000066   0x0005             MOVS     R5,R0
   2484                  return ulPWMClk;    
   \   00000068   0x0028             MOVS     R0,R5
   \                     ??SysCtlPWMAndUART0ClkGet_1:
   \   0000006A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2485              }
   2486          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     s_ulExtClockMHz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x40048044         DC32     0x40048044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0xFFF8FFFF         DC32     0xfff8ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x40064006         DC32     0x40064006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x40064001         DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x40064000         DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x00004E20         DC32     0x4e20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   0x40064005         DC32     0x40064005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \   00000000   0x40064004         DC32     0x40064004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_9:
   \   00000000   0x40048004         DC32     0x40048004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     g_pPeripherals

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x40047000         DC32     0x40047000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0xFFF3FFFF         DC32     0xfff3ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x4003B008         DC32     0x4003b008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0xF3FFFFFF         DC32     0xf3ffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x40048004         DC32     0x40048004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0xFFFEFFFF         DC32     0xfffeffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0xFCFFFFFF         DC32     0xfcffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0xFFFBFFFF         DC32     0xfffbffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x00080704         DC32     0x80704

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x000C0700         DC32     0xc0700

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0x000C0701         DC32     0xc0701

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \   00000000   0x40048100         DC32     0x40048100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \   00000000   0x........         DC32     g_pulAXBCLKRegs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \   00000000   0x4007C000         DC32     0x4007c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \   00000000   0x4007C008         DC32     0x4007c008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_8:
   \   00000000   0x4007C005         DC32     0x4007c005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_9:
   \   00000000   0x4007C007         DC32     0x4007c007

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x4007C004         DC32     0x4007c004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0xE000E000         DC32     0xe000e000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x40047000         DC32     0x40047000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0xFFF3FFFF         DC32     0xfff3ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x4003B008         DC32     0x4003b008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   0xF3FFFFFF         DC32     0xf3ffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0xFFFEFFFF         DC32     0xfffeffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   0x40048004         DC32     0x40048004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   0xFCFFFFFF         DC32     0xfcffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31:
   \   00000000   0xFFFBFFFF         DC32     0xfffbffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_1:
   \   00000000   0x000C0700         DC32     0xc0700

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_2:
   \   00000000   0x00080704         DC32     0x80704

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_3:
   \   00000000   0x000C0701         DC32     0xc0701

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_4:
   \   00000000   0x40048100         DC32     0x40048100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_5:
   \   00000000   0x40064000         DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_6:
   \   00000000   0x4007F000         DC32     0x4007f000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_7:
   \   00000000   0x4007F001         DC32     0x4007f001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_8:
   \   00000000   0x4007E003         DC32     0x4007e003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_9:
   \   00000000   0x4007F004         DC32     0x4007f004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32:
   \   00000000   0x4007F005         DC32     0x4007f005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_1:
   \   00000000   0x4007D000         DC32     0x4007d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_2:
   \   00000000   0x4007D001         DC32     0x4007d001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_3:
   \   00000000   0x4007E000         DC32     0x4007e000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33:
   \   00000000   0x4007E001         DC32     0x4007e001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33_1:
   \   00000000   0xE000E000         DC32     0xe000e000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33_2:
   \   00000000   0x4007E002         DC32     0x4007e002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33_3:
   \   00000000   0x40064000         DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33_4:
   \   00000000   0x........         DC32     s_ulExtClockMHz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33_5:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33_6:
   \   00000000   0x40048044         DC32     0x40048044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33_7:
   \   00000000   0x40064001         DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33_8:
   \   00000000   0x003D0900         DC32     0x3d0900

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33_9:
   \   00000000   0x40064005         DC32     0x40064005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33_10:
   \   00000000   0x40064004         DC32     0x40064004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33_11:
   \   00000000   0x05B8D800         DC32     0x5b8d800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37:
   \   00000000   0x40064005         DC32     0x40064005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40:
   \   00000000   0x40048044         DC32     0x40048044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_1:
   \   00000000   0xFFF8FFFF         DC32     0xfff8ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_2:
   \   00000000   0x40064006         DC32     0x40064006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_3:
   \   00000000   0x40064001         DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_4:
   \   00000000   0x40064000         DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable41:
   \   00000000   0x00004E20         DC32     0x4e20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable41_1:
   \   00000000   0x40064004         DC32     0x40064004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable41_2:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable41_3:
   \   00000000   0x40048004         DC32     0x40048004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable41_4:
   \   00000000   0x4007D002         DC32     0x4007d002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable41_5:
   \   00000000   0x40065000         DC32     0x40065000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable41_6:
   \   00000000   0x40064001         DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable41_7:
   \   00000000   0x........         DC32     s_ulExtClockMHz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable41_8:
   \   00000000   0x40064000         DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable41_9:
   \   00000000   0x003D0900         DC32     0x3d0900

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        4  SysCtlBandgapBufferEnable
        4  SysCtlBandgapEnable
       16  SysCtlBusClkGet
             16 -> SysCtlHClockGet
             16 -> __aeabi_uidiv
       16  SysCtlBusClkSet
             16 -> SysCtlHClockGet
             16 -> __aeabi_uidiv
        0  SysCtlClkOututSrcSet
        8  SysCtlDeepSleep
              8 -> xCPUwfi
        0  SysCtlDelay
       16  SysCtlHClockGet
             16 -> __aeabi_uidiv
       40  SysCtlHClockSet
             40 -> SysCtlDelay
             40 -> SysCtlHClockSourceSet
             40 -> __aeabi_uidiv
        0  SysCtlHClockSourceSet
        0  SysCtlLVDEventFlagClear
        4  SysCtlLVDEventFlagGet
        4  SysCtlLVDIntEnable
        4  SysCtlLVDResetEnable
        0  SysCtlLVDVolSet
        4  SysCtlLVDWaringFlagGet
        0  SysCtlLVDWarningFlagClear
        4  SysCtlLVDWarningIntEnable
        0  SysCtlLVDWarningVolSet
       16  SysCtlPWMAndUART0ClkGet
             16 -> SysCtlHClockGet
        4  SysCtlPeripheralClockSourceSet
        0  SysCtlPeripheralDisable
        8  SysCtlPeripheralEnable
        0  SysCtlPowerModeGet
        4  SysCtlRegulatorStatusGet
        0  SysCtlResetPinFilterBusClkWidthSet
        0  SysCtlResetPinFilterRunModeSelect
        4  SysCtlResetPinFilterStopModeEnable
        4  SysCtlResetSrcGet
        8  SysCtlSleep
              8 -> xCPUwfi
        8  SysCtlStopModeSet
              8 -> xCPUwfi
        4  SysCtlVeryLowPowerRunModeEnable
        8  SysCtlWakeupFilterConfig
        8  SysCtlWakeupModuleEnable
        4  SysCtlWakeupModuleFlagGet
       24  SysCtlWakeupPinConfig
             24 -> __aeabi_uidivmod
        4  SysCtlWakeupPinFilterFlagGet
        4  SysCtlWakeupPinFlagGet
       32  xSysCtlClockSet
             32 -> SysCtlHClockSourceSet
             32 -> __aeabi_uidiv
        4  xSysCtlPeripheraIntNumGet
        4  xSysCtlPeripheralClockSourceSet
       16  xSysCtlPeripheralDisable2
             16 -> SysCtlPeripheralDisable
       16  xSysCtlPeripheralEnable2
             16 -> SysCtlPeripheralEnable


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
       4  ??DataTable15
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable18
       4  ??DataTable2
       4  ??DataTable23
       4  ??DataTable24
       4  ??DataTable25
       4  ??DataTable28
       4  ??DataTable3
       4  ??DataTable31
       4  ??DataTable31_1
       4  ??DataTable31_2
       4  ??DataTable31_3
       4  ??DataTable31_4
       4  ??DataTable31_5
       4  ??DataTable31_6
       4  ??DataTable31_7
       4  ??DataTable31_8
       4  ??DataTable31_9
       4  ??DataTable32
       4  ??DataTable32_1
       4  ??DataTable32_2
       4  ??DataTable32_3
       4  ??DataTable33
       4  ??DataTable33_1
       4  ??DataTable33_10
       4  ??DataTable33_11
       4  ??DataTable33_2
       4  ??DataTable33_3
       4  ??DataTable33_4
       4  ??DataTable33_5
       4  ??DataTable33_6
       4  ??DataTable33_7
       4  ??DataTable33_8
       4  ??DataTable33_9
       4  ??DataTable37
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
       4  ??DataTable4
       4  ??DataTable40
       4  ??DataTable40_1
       4  ??DataTable40_2
       4  ??DataTable40_3
       4  ??DataTable40_4
       4  ??DataTable41
       4  ??DataTable41_1
       4  ??DataTable41_2
       4  ??DataTable41_3
       4  ??DataTable41_4
       4  ??DataTable41_5
       4  ??DataTable41_6
       4  ??DataTable41_7
       4  ??DataTable41_8
       4  ??DataTable41_9
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable8
       4  ??DataTable9
       4  ??DataTable9_1
      36  SysCtlBandgapBufferEnable
      36  SysCtlBandgapEnable
      40  SysCtlBusClkGet
      68  SysCtlBusClkSet
      24  SysCtlClkOututSrcSet
      20  SysCtlDeepSleep
       8  SysCtlDelay
     238  SysCtlHClockGet
    1424  SysCtlHClockSet
      24  SysCtlHClockSourceSet
      14  SysCtlLVDEventFlagClear
      28  SysCtlLVDEventFlagGet
      36  SysCtlLVDIntEnable
      36  SysCtlLVDResetEnable
      26  SysCtlLVDVolSet
      28  SysCtlLVDWaringFlagGet
      14  SysCtlLVDWarningFlagClear
      36  SysCtlLVDWarningIntEnable
      26  SysCtlLVDWarningVolSet
     108  SysCtlPWMAndUART0ClkGet
     690  SysCtlPeripheralClockSourceSet
      52  SysCtlPeripheralDisable
      56  SysCtlPeripheralEnable
      12  SysCtlPowerModeGet
      28  SysCtlRegulatorStatusGet
      24  SysCtlResetPinFilterBusClkWidthSet
      26  SysCtlResetPinFilterRunModeSelect
      36  SysCtlResetPinFilterStopModeEnable
      74  SysCtlResetSrcGet
      20  SysCtlSleep
     390  SysCtlStopModeSet
      72  SysCtlVeryLowPowerRunModeEnable
      86  SysCtlWakeupFilterConfig
      50  SysCtlWakeupModuleEnable
      32  SysCtlWakeupModuleFlagGet
     128  SysCtlWakeupPinConfig
      34  SysCtlWakeupPinFilterFlagGet
      36  SysCtlWakeupPinFlagGet
     216  g_pPeripherals
      16  g_pulAXBCLKRegs
       4  s_ulExtClockMHz
     588  xSysCtlClockSet
      48  xSysCtlPeripheraIntNumGet
     614  xSysCtlPeripheralClockSourceSet
      54  xSysCtlPeripheralDisable2
      54  xSysCtlPeripheralEnable2

 
     4 bytes in section .data
   232 bytes in section .rodata
 5 794 bytes in section .text
 
 5 794 bytes of CODE  memory
   232 bytes of CONST memory
     4 bytes of DATA  memory

Errors: none
Warnings: none
