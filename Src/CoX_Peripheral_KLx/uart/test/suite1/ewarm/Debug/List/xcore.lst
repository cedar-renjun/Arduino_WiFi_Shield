###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.1.53790/W32 for ARM     24/Feb/2013  09:52:13 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\renjun\Desktop\Cox\CoX_Peripheral\CoX_Periphera #
#                    l_KLx\libcox\xcore.c                                     #
#    Command line =  C:\Users\renjun\Desktop\Cox\CoX_Peripheral\CoX_Periphera #
#                    l_KLx\libcox\xcore.c -D ewarm -lCN                       #
#                    C:\Users\renjun\Desktop\Cox\CoX_Peripheral\CoX_Periphera #
#                    l_KLx\uart\test\suite1\ewarm\Debug\List\ -lB             #
#                    C:\Users\renjun\Desktop\Cox\CoX_Peripheral\CoX_Periphera #
#                    l_KLx\uart\test\suite1\ewarm\Debug\List\ -o              #
#                    C:\Users\renjun\Desktop\Cox\CoX_Peripheral\CoX_Periphera #
#                    l_KLx\uart\test\suite1\ewarm\Debug\Obj\ --no_cse         #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M0+ -e --fpu=None --dlib_config             #
#                    "C:\Program Files\IAR Systems\Embedded Workbench         #
#                    6.4\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\Users\renjun\Desktop\Cox\CoX_Peripheral\CoX_Periphera #
#                    l_KLx\uart\test\suite1\ewarm\..\..\..\..\libcox\ -I      #
#                    C:\Users\renjun\Desktop\Cox\CoX_Peripheral\CoX_Periphera #
#                    l_KLx\uart\test\suite1\ewarm\..\..\..\..\testframe\ -I   #
#                    C:\Users\renjun\Desktop\Cox\CoX_Peripheral\CoX_Periphera #
#                    l_KLx\uart\test\suite1\ewarm\..\..\..\..\uart\test\suite #
#                    1\src\ -On                                               #
#    List file    =  C:\Users\renjun\Desktop\Cox\CoX_Peripheral\CoX_Periphera #
#                    l_KLx\uart\test\suite1\ewarm\Debug\List\xcore.lst        #
#    Object file  =  C:\Users\renjun\Desktop\Cox\CoX_Peripheral\CoX_Periphera #
#                    l_KLx\uart\test\suite1\ewarm\Debug\Obj\xcore.o           #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\renjun\Desktop\Cox\CoX_Peripheral\CoX_Peripheral_KLx\libcox\xcore.c
      1          //*****************************************************************************
      2          //
      3          //! \file xcore.c
      4          //! \brief Instruction wrappers for special CPU instructions.
      5          //! Driver for the NVIC Interrupt Controller.
      6          //! Driver for the SysTick driver.
      7          //! \version V2.2.1.0
      8          //! \date 7/31/2012
      9          //! \author CooCox
     10          //! \copy
     11          //!
     12          //! Copyright (c)  2011, CooCox 
     13          //! All rights reserved.
     14          //! 
     15          //! Redistribution and use in source and binary forms, with or without 
     16          //! modification, are permitted provided that the following conditions 
     17          //! are met: 
     18          //! 
     19          //!     * Redistributions of source code must retain the above copyright 
     20          //! notice, this list of conditions and the following disclaimer. 
     21          //!     * Redistributions in binary form must reproduce the above copyright
     22          //! notice, this list of conditions and the following disclaimer in the
     23          //! documentation and/or other materials provided with the distribution. 
     24          //!     * Neither the name of the <ORGANIZATION> nor the names of its 
     25          //! contributors may be used to endorse or promote products derived 
     26          //! from this software without specific prior written permission. 
     27          //! 
     28          //! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     29          //! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
     30          //! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     31          //! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
     32          //! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
     33          //! CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
     34          //! SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     35          //! INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
     36          //! CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
     37          //! ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF 
     38          //! THE POSSIBILITY OF SUCH DAMAGE.
     39          //
     40          //*****************************************************************************
     41          
     42          #include "xhw_types.h"
     43          #include "xhw_ints.h"
     44          #include "xhw_memmap.h"
     45          #include "xhw_nvic.h"
     46          #include "xdebug.h"
     47          #include "xcore.h"
     48          
     49          //*****************************************************************************
     50          //
     51          // This is a mapping between interrupt number and the register that contains
     52          // the priority encoding for that interrupt.
     53          //
     54          //*****************************************************************************

   \                                 In section .rodata, align 4
     55          static const unsigned long g_pulRegs[] =
   \                     g_pulRegs:
   \   00000000   0x00000000         DC32 0, 0, 3758157084, 3758157088, 3758154752, 3758154756, 3758154760
   \              0x00000000   
   \              0xE000ED1C   
   \              0xE000ED20   
   \              0xE000E400   
   \              0xE000E404   
   \              0xE000E408   
   \   0000001C   0xE000E40C         DC32 3758154764, 3758154768, 3758154772, 3758154776, 3758154780
   \              0xE000E410   
   \              0xE000E414   
   \              0xE000E418   
   \              0xE000E41C   
   \   00000030   0xE000E420         DC32 3758154784, 3758154788, 3758154792, 3758154796
   \              0xE000E424   
   \              0xE000E428   
   \              0xE000E42C   
     56          {
     57              0, 0, NVIC_SYS_PRI2, NVIC_SYS_PRI3, NVIC_PRI0, NVIC_PRI1,
     58              NVIC_PRI2, NVIC_PRI3, NVIC_PRI4, NVIC_PRI5, NVIC_PRI6, NVIC_PRI7, 
     59              NVIC_PRI8, NVIC_PRI9, NVIC_PRI10, NVIC_PRI11 
     60             
     61          };
     62          
     63          //*****************************************************************************
     64          //
     65          //! \brief The default interrupt handler.
     66          //!
     67          //! This is the default interrupt handler for all interrupts.  It simply loops
     68          //! forever so that the system state is preserved for observation by a
     69          //! debugger.  Since interrupts should be disabled before unregistering the
     70          //! corresponding handler, this should never be called.
     71          //!
     72          //! \return None.
     73          //
     74          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
     75          void
     76          IntDefaultHandler(void)
     77          {
     78              //
     79              // Go into an infinite loop.
     80              //
     81              while(1)
   \                     IntDefaultHandler:
   \                     ??IntDefaultHandler_0:
   \   00000000   0xE7FE             B        ??IntDefaultHandler_0
     82              {
     83              }
     84          }
     85          
     86          //*****************************************************************************
     87          //
     88          // Wrapper function for the CPSID instruction. Returns the state of 
     89          // PRIMASK on entry. 
     90          //
     91          //*****************************************************************************
     92          #if defined(gcc) || defined(__GNUC__)
     93          unsigned long __attribute__((naked))
     94          xCPUcpsid(void)
     95          {
     96              unsigned long ulRet;
     97          
     98              //
     99              // Read PRIMASK and disable interrupts.
    100              //
    101              __asm("    mrs     r0, PRIMASK\n"
    102                    "    cpsid   i\n"
    103                    "    bx      lr\n"
    104                    : "=r" (ulRet));
    105          
    106              //
    107              // The return is handled in the inline assembly, but the compiler will
    108              // still complain if there is not an explicit return here (despite the fact
    109              // that this does not result in any code being produced because of the
    110              // naked attribute).
    111              //
    112              return(ulRet);
    113          }
    114          #endif
    115          #if defined(ewarm) || defined(__ICCARM__)

   \                                 In section .text, align 4, keep-with-next
    116          unsigned long
    117          xCPUcpsid(void)
    118          {
    119              //
    120              // Read PRIMASK and disable interrupts.
    121              //
    122              __asm("    mrs     r0, PRIMASK\n"
    123                    "    cpsid   i\n");
   \                     xCPUcpsid:
   \   00000000   0xF3EF 0x8010      mrs     r0, PRIMASK
   \   00000004   0xB672             cpsid   i
    124          
    125              //
    126              // "Warning[Pe940]: missing return statement at end of non-void function"
    127              // is suppressed here to avoid putting a "bx lr" in the inline assembly
    128              // above and a superfluous return statement here.
    129              //
    130          #pragma diag_suppress=Pe940
    131          }
   \   00000006   0x4770             BX       LR               ;; return
    132          #pragma diag_default=Pe940
    133          #endif
    134          #if defined(rvmdk) || defined(__CC_ARM)
    135          __asm unsigned long
    136          xCPUcpsid(void)
    137          {
    138              //
    139              // Read PRIMASK and disable interrupts.
    140              //
    141              mrs     r0, PRIMASK;
    142              cpsid   i;
    143              bx      lr
    144          }
    145          #endif
    146          
    147          //*****************************************************************************
    148          //
    149          // Wrapper function returning the state of PRIMASK (indicating whether
    150          // interrupts are enabled or disabled).
    151          //
    152          //*****************************************************************************
    153          #if defined(gcc) || defined(__GNUC__)
    154          unsigned long __attribute__((naked))
    155          xCPUprimask(void)
    156          {
    157              unsigned long ulRet;
    158          
    159              //
    160              // Read PRIMASK and disable interrupts.
    161              //
    162              __asm("    mrs     r0, PRIMASK\n"
    163                    "    bx      lr\n"
    164                    : "=r" (ulRet));
    165          
    166              //
    167              // The return is handled in the inline assembly, but the compiler will
    168              // still complain if there is not an explicit return here (despite the fact
    169              // that this does not result in any code being produced because of the
    170              // naked attribute).
    171              //
    172              return(ulRet);
    173          }
    174          #endif
    175          #if defined(ewarm) || defined(__ICCARM__)

   \                                 In section .text, align 4, keep-with-next
    176          unsigned long
    177          xCPUprimask(void)
    178          {
    179              //
    180              // Read PRIMASK and disable interrupts.
    181              //
    182              __asm("    mrs     r0, PRIMASK\n");
   \                     xCPUprimask:
   \   00000000   0xF3EF 0x8010      mrs     r0, PRIMASK
    183          
    184              //
    185              // "Warning[Pe940]: missing return statement at end of non-void function"
    186              // is suppressed here to avoid putting a "bx lr" in the inline assembly
    187              // above and a superfluous return statement here.
    188              //
    189          #pragma diag_suppress=Pe940
    190          }
   \   00000004   0x4770             BX       LR               ;; return
    191          #pragma diag_default=Pe940
    192          #endif
    193          #if defined(rvmdk) || defined(__CC_ARM)
    194          __asm unsigned long
    195          xCPUprimask(void)
    196          {
    197              //
    198              // Read PRIMASK and disable interrupts.
    199              //
    200              mrs     r0, PRIMASK;
    201              bx      lr
    202          }
    203          #endif
    204          
    205          //*****************************************************************************
    206          //
    207          // Wrapper function for the CPSIE instruction.  Returns the state of PRIMASK
    208          // on entry.
    209          //
    210          //*****************************************************************************
    211          #if defined(gcc) || defined(__GNUC__)
    212          unsigned long __attribute__((naked))
    213          xCPUcpsie(void)
    214          {
    215              unsigned long ulRet;
    216          
    217              //
    218              // Read PRIMASK and enable interrupts.
    219              //
    220              __asm("    mrs     r0, PRIMASK\n"
    221                    "    cpsie   i\n"
    222                    "    bx      lr\n"
    223                    : "=r" (ulRet));
    224          
    225              //
    226              // The return is handled in the inline assembly, but the compiler will
    227              // still complain if there is not an explicit return here (despite the fact
    228              // that this does not result in any code being produced because of the
    229              // naked attribute).
    230              //
    231              return(ulRet);
    232          }
    233          #endif
    234          #if defined(ewarm) || defined(__ICCARM__)

   \                                 In section .text, align 4, keep-with-next
    235          unsigned long
    236          xCPUcpsie(void)
    237          {
    238              //
    239              // Read PRIMASK and enable interrupts.
    240              //
    241              __asm("    mrs     r0, PRIMASK\n"
    242                    "    cpsie   i\n");
   \                     xCPUcpsie:
   \   00000000   0xF3EF 0x8010      mrs     r0, PRIMASK
   \   00000004   0xB662             cpsie   i
    243          
    244              //
    245              // "Warning[Pe940]: missing return statement at end of non-void function"
    246              // is suppressed here to avoid putting a "bx lr" in the inline assembly
    247              // above and a superfluous return statement here.
    248              //
    249          #pragma diag_suppress=Pe940
    250          }
   \   00000006   0x4770             BX       LR               ;; return
    251          #pragma diag_default=Pe940
    252          #endif
    253          #if defined(rvmdk) || defined(__CC_ARM)
    254          __asm unsigned long
    255          xCPUcpsie(void)
    256          {
    257              //
    258              // Read PRIMASK and enable interrupts.
    259              //
    260              mrs     r0, PRIMASK;
    261              cpsie   i;
    262              bx      lr
    263          }
    264          #endif
    265          
    266          //*****************************************************************************
    267          //
    268          // Wrapper function for the WFI instruction.
    269          //
    270          //*****************************************************************************
    271          #if defined(gcc) || defined(__GNUC__)
    272          void __attribute__((naked))
    273          xCPUwfi(void)
    274          {
    275              //
    276              // Wait for the next interrupt.
    277              //
    278              __asm("    wfi\n"
    279                    "    bx      lr\n");
    280          }
    281          #endif
    282          #if defined(ewarm) || defined(__ICCARM__)

   \                                 In section .text, align 4, keep-with-next
    283          void
    284          xCPUwfi(void)
    285          {
    286              //
    287              // Wait for the next interrupt.
    288              //
    289              __asm("    wfi\n");
   \                     xCPUwfi:
   \   00000000   0xBF30             wfi
    290          }
   \   00000002   0x4770             BX       LR               ;; return
    291          #endif
    292          #if defined(rvmdk) || defined(__CC_ARM)
    293          __asm void
    294          xCPUwfi(void)
    295          {
    296              //
    297              // Wait for the next interrupt.
    298              //
    299              wfi;
    300              bx      lr
    301          }
    302          #endif
    303          
    304          //*****************************************************************************
    305          //
    306          // Wrapper function for writing the BASEPRI register.
    307          //
    308          //*****************************************************************************
    309          #if defined(gcc) || defined(__GNUC__)
    310          void __attribute__((naked))
    311          xCPUbasepriSet(unsigned long ulNewBasepri)
    312          {
    313          
    314              //
    315              // Set the BASEPRI register
    316              //
    317              __asm("    msr     BASEPRI, r0\n"
    318                    "    bx      lr\n");
    319          }
    320          #endif
    321          #if defined(ewarm) || defined(__ICCARM__)

   \                                 In section .text, align 2, keep-with-next
    322          void
    323          xCPUbasepriSet(unsigned long ulNewBasepri)
    324          {
    325              //
    326              // Set the BASEPRI register
    327              //
    328          //    __asm("    msr     BASEPRI, r0\n");
    329          }
   \                     xCPUbasepriSet:
   \   00000000   0x4770             BX       LR               ;; return
    330          #endif
    331          #if defined(rvmdk) || defined(__CC_ARM)
    332          __asm void
    333          xCPUbasepriSet(unsigned long ulNewBasepri)
    334          {
    335              //
    336              // Set the BASEPRI register
    337              //
    338          //    msr     BASEPRI, r0;
    339          //    bx      lr
    340          }
    341          #endif
    342          
    343          //*****************************************************************************
    344          //
    345          // Wrapper function for reading the BASEPRI register.
    346          //
    347          //*****************************************************************************
    348          #if defined(gcc) || defined(__GNUC__)
    349          unsigned long __attribute__((naked))
    350          xCPUbasepriGet(void)
    351          {
    352              unsigned long ulRet;
    353          
    354              //
    355              // Read BASEPRI
    356              //
    357              __asm("    mrs     r0, BASEPRI\n"
    358                    "    bx      lr\n"
    359                    : "=r" (ulRet));
    360          
    361              //
    362              // The return is handled in the inline assembly, but the compiler will
    363              // still complain if there is not an explicit return here (despite the fact
    364              // that this does not result in any code being produced because of the
    365              // naked attribute).
    366              //
    367              return(ulRet);
    368          }
    369          #endif
    370          #if defined(ewarm) || defined(__ICCARM__)

   \                                 In section .text, align 2, keep-with-next
    371          unsigned long
    372          xCPUbasepriGet(void)
    373          {
    374              //
    375              // Read BASEPRI
    376              //
    377           //   __asm("    mrs     r0, BASEPRI\n");
    378          
    379              //
    380              // "Warning[Pe940]: missing return statement at end of non-void function"
    381              // is suppressed here to avoid putting a "bx lr" in the inline assembly
    382              // above and a superfluous return statement here.
    383              //
    384          #pragma diag_suppress=Pe940
    385          }
   \                     xCPUbasepriGet:
   \   00000000   0x4770             BX       LR               ;; return
    386          #pragma diag_default=Pe940
    387          #endif
    388          #if defined(rvmdk) || defined(__CC_ARM)
    389          __asm unsigned long
    390          xCPUbasepriGet(void)
    391          {
    392              //
    393              // Read BASEPRI
    394              //
    395          //    mrs     r0, BASEPRI;
    396          //    bx      lr
    397          }
    398          #endif
    399          
    400          //*****************************************************************************
    401          //
    402          // Wrapper function for writing the PSP register.
    403          //
    404          //*****************************************************************************
    405          #if defined(gcc) || defined(__GNUC__)
    406          void __attribute__((naked))
    407          xCPUpspSet(unsigned long ulNewPspStack)
    408          {
    409          
    410              //
    411              // Set the psp register
    412              //
    413              __asm("    msr     psp, r0\n"
    414                    "    bx      lr\n");
    415          }
    416          #endif
    417          #if defined(ewarm) || defined(__ICCARM__)

   \                                 In section .text, align 4, keep-with-next
    418          void
    419          xCPUpspSet(unsigned long ulNewPspStack)
    420          {
    421              //
    422              // Set the psp register
    423              //
    424              __asm("    msr     psp, r0\n");
   \                     xCPUpspSet:
   \   00000000   0xF380 0x8809      msr     psp, r0
    425          }
   \   00000004   0x4770             BX       LR               ;; return
    426          #endif
    427          #if defined(rvmdk) || defined(__CC_ARM)
    428          __asm void
    429          xCPUpspSet(unsigned long ulNewPspStack)
    430          {
    431              //
    432              // Set the psp register
    433              //
    434              msr psp, r0
    435              bx lr
    436          }
    437          #endif
    438          
    439          //*****************************************************************************
    440          //
    441          // Wrapper function for reading the psp register.
    442          //
    443          //*****************************************************************************
    444          #if defined(gcc) || defined(__GNUC__)
    445          unsigned long __attribute__((naked))
    446          xCPUpspGet(void)
    447          {
    448              unsigned long ulRet;
    449          
    450              //
    451              // Read psp
    452              //
    453              __asm("    mrs     r0, psp\n"
    454                    "    bx      lr\n"
    455                    : "=r" (ulRet));
    456          
    457              //
    458              // The return is handled in the inline assembly, but the compiler will
    459              // still complain if there is not an explicit return here (despite the fact
    460              // that this does not result in any code being produced because of the
    461              // naked attribute).
    462              //
    463              return(ulRet);
    464          }
    465          #endif
    466          #if defined(ewarm) || defined(__ICCARM__)

   \                                 In section .text, align 4, keep-with-next
    467          unsigned long
    468          xCPUpspGet(void)
    469          {
    470              //
    471              // Read psp
    472              //
    473              __asm("    mrs     r0, psp\n");
   \                     xCPUpspGet:
   \   00000000   0xF3EF 0x8009      mrs     r0, psp
    474          
    475              //
    476              // "Warning[Pe940]: missing return statement at end of non-void function"
    477              // is suppressed here to avoid putting a "bx lr" in the inline assembly
    478              // above and a superfluous return statement here.
    479              //
    480          #pragma diag_suppress=Pe940
    481          }
   \   00000004   0x4770             BX       LR               ;; return
    482          #pragma diag_default=Pe940
    483          #endif
    484          #if defined(rvmdk) || defined(__CC_ARM)
    485          __asm unsigned long
    486          xCPUpspGet(void)
    487          {
    488              //
    489              // Read psp
    490              //
    491              mrs     r0, psp;
    492              bx      lr
    493          }
    494          #endif
    495          
    496          //*****************************************************************************
    497          //
    498          // Wrapper function for writing the msp register.
    499          //
    500          //*****************************************************************************
    501          #if defined(gcc) || defined(__GNUC__)
    502          void __attribute__((naked))
    503          xCPUmspSet(unsigned long ulNewmspStack)
    504          {
    505          
    506              //
    507              // Set the msp register
    508              //
    509              __asm("    msr     msp, r0\n"
    510                    "    bx      lr\n");
    511          }
    512          #endif
    513          #if defined(ewarm) || defined(__ICCARM__)

   \                                 In section .text, align 4, keep-with-next
    514          void
    515          xCPUmspSet(unsigned long ulNewmspStack)
    516          {
    517              //
    518              // Set the msp register
    519              //
    520              __asm("    msr     msp, r0\n");
   \                     xCPUmspSet:
   \   00000000   0xF380 0x8808      msr     msp, r0
    521          }
   \   00000004   0x4770             BX       LR               ;; return
    522          #endif
    523          #if defined(rvmdk) || defined(__CC_ARM)
    524          __asm void
    525          xCPUmspSet(unsigned long ulNewmspStack)
    526          {
    527              //
    528              // Set the msp register
    529              //
    530              msr msp, r0
    531              bx lr
    532          }
    533          #endif
    534          
    535          //*****************************************************************************
    536          //
    537          // Wrapper function for reading the msp register.
    538          //
    539          //*****************************************************************************
    540          #if defined(gcc) || defined(__GNUC__)
    541          unsigned long __attribute__((naked))
    542          xCPUmspGet(void)
    543          {
    544              unsigned long ulRet;
    545          
    546              //
    547              // Read msp
    548              //
    549              __asm("    mrs     r0, msp\n"
    550                    "    bx      lr\n"
    551                    : "=r" (ulRet));
    552          
    553              //
    554              // The return is handled in the inline assembly, but the compiler will
    555              // still complain if there is not an explicit return here (despite the fact
    556              // that this does not result in any code being produced because of the
    557              // naked attribute).
    558              //
    559              return(ulRet);
    560          }
    561          #endif
    562          #if defined(ewarm) || defined(__ICCARM__)

   \                                 In section .text, align 4, keep-with-next
    563          unsigned long
    564          xCPUmspGet(void)
    565          {
    566              //
    567              // Read msp
    568              //
    569              __asm("    mrs     r0, msp\n");
   \                     xCPUmspGet:
   \   00000000   0xF3EF 0x8008      mrs     r0, msp
    570          
    571              //
    572              // "Warning[Pe940]: missing return statement at end of non-void function"
    573              // is suppressed here to avoid putting a "bx lr" in the inline assembly
    574              // above and a superfluous return statement here.
    575              //
    576          #pragma diag_suppress=Pe940
    577          }
   \   00000004   0x4770             BX       LR               ;; return
    578          #pragma diag_default=Pe940
    579          #endif
    580          #if defined(rvmdk) || defined(__CC_ARM)
    581          __asm unsigned long
    582          xCPUmspGet(void)
    583          {
    584              //
    585              // Read msp
    586              //
    587              mrs     r0, msp;
    588              bx      lr
    589          }
    590          #endif
    591          
    592          
    593          //*****************************************************************************
    594          //
    595          //! \brief Enables the processor interrupt.
    596          //!
    597          //! Allows the processor to respond to interrupts.  This does not affect the
    598          //! set of interrupts enabled in the interrupt controller; it just gates the
    599          //! single interrupt from the controller to the processor.
    600          //!
    601          //! \return Returns \b true if interrupts were disabled when the function was
    602          //! called or \b false if they were initially enabled.
    603          //
    604          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
    605          xtBoolean
    606          xIntMasterEnable(void)
    607          {
   \                     xIntMasterEnable:
   \   00000000   0xB580             PUSH     {R7,LR}
    608              //
    609              // Enable processor interrupts.
    610              //
    611              return(xCPUcpsie());
   \   00000002   0x.... 0x....      BL       xCPUcpsie
   \   00000006   0xB2C0             UXTB     R0,R0
   \   00000008   0xBD02             POP      {R1,PC}          ;; return
    612          }
    613          
    614          //*****************************************************************************
    615          //
    616          //! \brief Disables the processor interrupt.
    617          //!
    618          //! Prevents the processor from receiving interrupts.  This does not affect the
    619          //! set of interrupts enabled in the interrupt controller; it just gates the
    620          //! single interrupt from the controller to the processor.
    621          //!
    622          //! \return Returns \b true if interrupts were already disabled when the
    623          //! function was called or \b false if they were initially enabled.
    624          //
    625          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
    626          xtBoolean
    627          xIntMasterDisable(void)
    628          {
   \                     xIntMasterDisable:
   \   00000000   0xB580             PUSH     {R7,LR}
    629              //
    630              // Disable processor interrupts.
    631              //
    632              return(xCPUcpsid());
   \   00000002   0x.... 0x....      BL       xCPUcpsid
   \   00000006   0xB2C0             UXTB     R0,R0
   \   00000008   0xBD02             POP      {R1,PC}          ;; return
    633          }
    634          
    635          //*****************************************************************************
    636          //
    637          //! \brief Sets the priority of an interrupt.
    638          //!
    639          //! \param ulInterrupt specifies the interrupt in question.
    640          //! \param ucPriority specifies the priority of the interrupt.
    641          //!
    642          //! This function is used to set the priority of an interrupt.  When multiple
    643          //! interrupts are asserted simultaneously, the ones with the highest priority
    644          //! are processed before the lower priority interrupts.  Smaller numbers
    645          //! correspond to higher interrupt priorities; priority 0 is the highest
    646          //! interrupt priority.
    647          //!
    648          //! The hardware priority mechanism will only look at the upper N bits of the
    649          //! priority level (where N is 2 for the NUC1xx family), so any
    650          //! prioritization must be performed in those bits.  The remaining bits can be
    651          //! used to sub-prioritize the interrupt sources, and may be used by the
    652          //! hardware priority mechanism on a future part.  This arrangement allows
    653          //! priorities to migrate to different NVIC implementations without changing
    654          //! the gross prioritization of the interrupts.
    655          //!
    656          //! \return None.
    657          //
    658          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
    659          void
    660          xIntPrioritySet(unsigned long ulInterrupt, unsigned char ucPriority)
    661          {
   \                     xIntPrioritySet:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    662              unsigned long ulTemp;
    663          
    664              //
    665              // Check the arguments.
    666              //
    667              xASSERT(((ulInterrupt >= 4) && (ulInterrupt < NUM_INTERRUPTS)) || 
    668          	         (ulInterrupt == xINT_SYSCTL) || (ulInterrupt == xINT_RTC));
    669          
    670              //
    671              // Set the interrupt priority.
    672              //
    673              if((ulInterrupt >= 4) && (ulInterrupt < NUM_INTERRUPTS))
   \   00000002   0x2804             CMP      R0,#+4
   \   00000004   0xD323             BCC      ??xIntPrioritySet_0
   \   00000006   0x282F             CMP      R0,#+47
   \   00000008   0xD221             BCS      ??xIntPrioritySet_0
    674              {
    675                  ulTemp = xHWREG(g_pulRegs[ulInterrupt >> 2]);
   \   0000000A   0x0003             MOVS     R3,R0
   \   0000000C   0x089B             LSRS     R3,R3,#+2
   \   0000000E   0x2404             MOVS     R4,#+4
   \   00000010   0x4363             MULS     R3,R4,R3
   \   00000012   0x....             LDR      R4,??DataTable4
   \   00000014   0x58E3             LDR      R3,[R4, R3]
   \   00000016   0x681B             LDR      R3,[R3, #+0]
   \   00000018   0x001A             MOVS     R2,R3
    676                  ulTemp &= ~(0xFF << (8 * (ulInterrupt & 3)));
   \   0000001A   0x23FF             MOVS     R3,#+255
   \   0000001C   0x0004             MOVS     R4,R0
   \   0000001E   0x07A4             LSLS     R4,R4,#+30       ;; ZeroExtS R4,R4,#+30,#+30
   \   00000020   0x0FA4             LSRS     R4,R4,#+30
   \   00000022   0x2508             MOVS     R5,#+8
   \   00000024   0x436C             MULS     R4,R5,R4
   \   00000026   0x40A3             LSLS     R3,R3,R4
   \   00000028   0x439A             BICS     R2,R2,R3
    677                  ulTemp |= ucPriority << (8 * (ulInterrupt & 3) + 6);
   \   0000002A   0x0014             MOVS     R4,R2
   \   0000002C   0xB2C9             UXTB     R1,R1
   \   0000002E   0x0783             LSLS     R3,R0,#+30       ;; ZeroExtS R3,R0,#+30,#+30
   \   00000030   0x0F9B             LSRS     R3,R3,#+30
   \   00000032   0x2208             MOVS     R2,#+8
   \   00000034   0x4353             MULS     R3,R2,R3
   \   00000036   0x1D9B             ADDS     R3,R3,#+6
   \   00000038   0x000A             MOVS     R2,R1
   \   0000003A   0x409A             LSLS     R2,R2,R3
   \   0000003C   0x4322             ORRS     R2,R2,R4
    678                  xHWREG(g_pulRegs[ulInterrupt >> 2]) = ulTemp;
   \   0000003E   0x0003             MOVS     R3,R0
   \   00000040   0x089B             LSRS     R3,R3,#+2
   \   00000042   0x2404             MOVS     R4,#+4
   \   00000044   0x4363             MULS     R3,R4,R3
   \   00000046   0x....             LDR      R4,??DataTable4
   \   00000048   0x58E3             LDR      R3,[R4, R3]
   \   0000004A   0x601A             STR      R2,[R3, #+0]
   \   0000004C   0xE021             B        ??xIntPrioritySet_1
    679              }
    680              else if(ulInterrupt == xINT_SYSCTL)
   \                     ??xIntPrioritySet_0:
   \   0000004E   0x....             LDR      R3,??DataTable4_1  ;; 0x1716
   \   00000050   0x4298             CMP      R0,R3
   \   00000052   0xD10D             BNE      ??xIntPrioritySet_2
    681              {
    682                  ulTemp = xHWREG(NVIC_PRI1);
   \   00000054   0x....             LDR      R3,??DataTable4_2  ;; 0xe000e404
   \   00000056   0x681B             LDR      R3,[R3, #+0]
   \   00000058   0x001A             MOVS     R2,R3
    683          	ulTemp &= ~0xFFFF0000;
   \   0000005A   0xB292             UXTH     R2,R2
    684          	ulTemp |= ((ucPriority << (16 + 6)) | (ucPriority << (24 + 6)));
   \   0000005C   0x0014             MOVS     R4,R2
   \   0000005E   0xB2C9             UXTB     R1,R1
   \   00000060   0x058B             LSLS     R3,R1,#+22
   \   00000062   0xB2C9             UXTB     R1,R1
   \   00000064   0x078A             LSLS     R2,R1,#+30
   \   00000066   0x431A             ORRS     R2,R2,R3
   \   00000068   0x4322             ORRS     R2,R2,R4
    685          	xHWREG(NVIC_PRI1) = ulTemp; 
   \   0000006A   0x....             LDR      R3,??DataTable4_2  ;; 0xe000e404
   \   0000006C   0x601A             STR      R2,[R3, #+0]
   \   0000006E   0xE010             B        ??xIntPrioritySet_1
    686              }
    687              else if(ulInterrupt == xINT_RTC)
   \                     ??xIntPrioritySet_2:
   \   00000070   0x....             LDR      R3,??DataTable5  ;; 0x2524
   \   00000072   0x4298             CMP      R0,R3
   \   00000074   0xD10D             BNE      ??xIntPrioritySet_1
    688              {
    689          	ulTemp = xHWREG(NVIC_PRI5);
   \   00000076   0x....             LDR      R3,??DataTable12  ;; 0xe000e414
   \   00000078   0x681B             LDR      R3,[R3, #+0]
   \   0000007A   0x001A             MOVS     R2,R3
    690          	ulTemp &= ~0x0000FFFF;
   \   0000007C   0x0C12             LSRS     R2,R2,#+16
   \   0000007E   0x0412             LSLS     R2,R2,#+16
    691          	ulTemp |= (ucPriority <<  6) | (ucPriority << (8 + 6));
   \   00000080   0x0014             MOVS     R4,R2
   \   00000082   0xB2C9             UXTB     R1,R1
   \   00000084   0x018B             LSLS     R3,R1,#+6
   \   00000086   0xB2C9             UXTB     R1,R1
   \   00000088   0x038A             LSLS     R2,R1,#+14
   \   0000008A   0x431A             ORRS     R2,R2,R3
   \   0000008C   0x4322             ORRS     R2,R2,R4
    692          	xHWREG(NVIC_PRI5) = ulTemp; 
   \   0000008E   0x....             LDR      R3,??DataTable12  ;; 0xe000e414
   \   00000090   0x601A             STR      R2,[R3, #+0]
    693               }
    694          
    695          }
   \                     ??xIntPrioritySet_1:
   \   00000092   0xBD30             POP      {R4,R5,PC}       ;; return
    696          
    697          //*****************************************************************************
    698          //
    699          //! \brief Gets the priority of an interrupt.
    700          //!
    701          //! \param ulInterrupt specifies the interrupt in question.
    702          //!
    703          //! This function gets the priority of an interrupt.  See xIntPrioritySet() for
    704          //! a definition of the priority value.
    705          //!
    706          //! \return Returns the interrupt priority, or -1 if an invalid interrupt was
    707          //! specified.
    708          //
    709          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
    710          long
    711          xIntPriorityGet(unsigned long ulInterrupt)
    712          {
   \                     xIntPriorityGet:
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0x0001             MOVS     R1,R0
    713              //
    714              // Check the arguments.
    715              //
    716              xASSERT(((ulInterrupt >= 4) && (ulInterrupt <= NUM_INTERRUPTS)) || 
    717          	         (ulInterrupt == xINT_SYSCTL) || (ulInterrupt == xINT_RTC));
    718          
    719              //
    720              // Return the interrupt priority.
    721              //
    722              if((ulInterrupt >= 4) && (ulInterrupt < NUM_INTERRUPTS))
   \   00000004   0x2904             CMP      R1,#+4
   \   00000006   0xD310             BCC      ??xIntPriorityGet_0
   \   00000008   0x292F             CMP      R1,#+47
   \   0000000A   0xD20E             BCS      ??xIntPriorityGet_0
    723              {
    724                  return((xHWREG(g_pulRegs[ulInterrupt >> 2]) >> (8 * (ulInterrupt & 3) + 6)) &
    725                         0xFF);
   \   0000000C   0x0008             MOVS     R0,R1
   \   0000000E   0x0880             LSRS     R0,R0,#+2
   \   00000010   0x2204             MOVS     R2,#+4
   \   00000012   0x4350             MULS     R0,R2,R0
   \   00000014   0x....             LDR      R2,??DataTable4
   \   00000016   0x5810             LDR      R0,[R2, R0]
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   0000001C   0x0F89             LSRS     R1,R1,#+30
   \   0000001E   0x2208             MOVS     R2,#+8
   \   00000020   0x4351             MULS     R1,R2,R1
   \   00000022   0x1D89             ADDS     R1,R1,#+6
   \   00000024   0x40C8             LSRS     R0,R0,R1
   \   00000026   0xB2C0             UXTB     R0,R0
   \   00000028   0xE010             B        ??xIntPriorityGet_1
    726              }
    727              else if(ulInterrupt == xINT_SYSCTL)
   \                     ??xIntPriorityGet_0:
   \   0000002A   0x....             LDR      R0,??DataTable4_1  ;; 0x1716
   \   0000002C   0x4281             CMP      R1,R0
   \   0000002E   0xD104             BNE      ??xIntPriorityGet_2
    728              {
    729                  return ((xHWREG(NVIC_PRI1) >> (16 + 6)) & 0xff);
   \   00000030   0x....             LDR      R0,??DataTable4_2  ;; 0xe000e404
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x0D80             LSRS     R0,R0,#+22
   \   00000036   0xB2C0             UXTB     R0,R0
   \   00000038   0xE008             B        ??xIntPriorityGet_1
    730              }
    731              else if(ulInterrupt == xINT_RTC)
   \                     ??xIntPriorityGet_2:
   \   0000003A   0x....             LDR      R0,??DataTable5  ;; 0x2524
   \   0000003C   0x4281             CMP      R1,R0
   \   0000003E   0xD104             BNE      ??xIntPriorityGet_3
    732              {
    733                  return ((xHWREG(NVIC_PRI5) >> 6 )& 0xff);
   \   00000040   0x....             LDR      R0,??DataTable12  ;; 0xe000e414
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x0980             LSRS     R0,R0,#+6
   \   00000046   0xB2C0             UXTB     R0,R0
   \   00000048   0xE000             B        ??xIntPriorityGet_1
    734              }
    735                  
    736              return 0;
   \                     ??xIntPriorityGet_3:
   \   0000004A   0x2000             MOVS     R0,#+0
   \                     ??xIntPriorityGet_1:
   \   0000004C   0xBD00             POP      {PC}             ;; return
    737          
    738          }
    739          
    740          //*****************************************************************************
    741          //
    742          //! \brief Enables an interrupt.
    743          //!
    744          //! \param ulInterrupt specifies the interrupt to be enabled.
    745          //!
    746          //! The specified interrupt is enabled in the interrupt controller.  Other
    747          //! enables for the interrupt (such as at the peripheral level) are unaffected
    748          //! by this function.
    749          //!
    750          //! \return None.
    751          //
    752          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
    753          void
    754          xIntEnable(unsigned long ulInterrupt)
    755          {
   \                     xIntEnable:
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    756              //
    757              // Check the arguments.
    758              //
    759              xASSERT(((ulInterrupt >= 4) && (ulInterrupt <= NUM_INTERRUPTS)) || 
    760          	    (ulInterrupt == xINT_SYSCTL) || (ulInterrupt == xINT_RTC));
    761           
    762              if(ulInterrupt == FAULT_SVCALL)
   \   00000004   0x2C0B             CMP      R4,#+11
   \   00000006   0xD106             BNE      ??xIntEnable_0
    763              {
    764                  //
    765                  //   SVC Call Active
    766                  //
    767                  xHWREG(NVIC_SYS_HND_CTRL) |= NVIC_SYS_HND_CTRL_SVCA;
   \   00000008   0x....             LDR      R0,??DataTable14  ;; 0xe000ed24
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x2180             MOVS     R1,#+128
   \   0000000E   0x4301             ORRS     R1,R1,R0
   \   00000010   0x....             LDR      R0,??DataTable14  ;; 0xe000ed24
   \   00000012   0x6001             STR      R1,[R0, #+0]
   \   00000014   0xE034             B        ??xIntEnable_1
    768              }
    769              else if(ulInterrupt == FAULT_PENDSV)
   \                     ??xIntEnable_0:
   \   00000016   0x2C0E             CMP      R4,#+14
   \   00000018   0xD107             BNE      ??xIntEnable_2
    770              {
    771                  //
    772                  //  SVC Call Pending
    773                  //
    774                  xHWREG(NVIC_SYS_HND_CTRL) |= NVIC_SYS_HND_CTRL_SVC;
   \   0000001A   0x....             LDR      R0,??DataTable14  ;; 0xe000ed24
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x2180             MOVS     R1,#+128
   \   00000020   0x0209             LSLS     R1,R1,#+8        ;; #+32768
   \   00000022   0x4301             ORRS     R1,R1,R0
   \   00000024   0x....             LDR      R0,??DataTable14  ;; 0xe000ed24
   \   00000026   0x6001             STR      R1,[R0, #+0]
   \   00000028   0xE02A             B        ??xIntEnable_1
    775              }
    776              else if(ulInterrupt == FAULT_SYSTICK)
   \                     ??xIntEnable_2:
   \   0000002A   0x2C0F             CMP      R4,#+15
   \   0000002C   0xD106             BNE      ??xIntEnable_3
    777              {
    778                  //
    779                  // Enable the System Tick interrupt.
    780                  //
    781                  xHWREG(NVIC_ST_CTRL) |= NVIC_ST_CTRL_INTEN;
   \   0000002E   0x....             LDR      R0,??DataTable16  ;; 0xe000e010
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x2102             MOVS     R1,#+2
   \   00000034   0x4301             ORRS     R1,R1,R0
   \   00000036   0x....             LDR      R0,??DataTable16  ;; 0xe000e010
   \   00000038   0x6001             STR      R1,[R0, #+0]
   \   0000003A   0xE021             B        ??xIntEnable_1
    782              }
    783              else if((ulInterrupt >= 16) && (ulInterrupt <= 47))
   \                     ??xIntEnable_3:
   \   0000003C   0x2C10             CMP      R4,#+16
   \   0000003E   0xD311             BCC      ??xIntEnable_4
   \   00000040   0x2C30             CMP      R4,#+48
   \   00000042   0xD20F             BCS      ??xIntEnable_4
    784              {
    785                  //
    786                  // Enable the general interrupt.
    787                  //
    788                  xHWREG(NVIC_EN0 + (((ulInterrupt & 0xFF)-16)/32)*4) 
    789                  = 1 << (((ulInterrupt & 0xFF)-16)%32);
   \   00000044   0xB2E0             UXTB     R0,R4
   \   00000046   0x3810             SUBS     R0,R0,#+16
   \   00000048   0x0005             MOVS     R5,R0
   \   0000004A   0x096D             LSRS     R5,R5,#+5
   \   0000004C   0x2004             MOVS     R0,#+4
   \   0000004E   0x4345             MULS     R5,R0,R5
   \   00000050   0x....             LDR      R6,??DataTable16_1  ;; 0xe000e100
   \   00000052   0x2701             MOVS     R7,#+1
   \   00000054   0xB2E0             UXTB     R0,R4
   \   00000056   0x3810             SUBS     R0,R0,#+16
   \   00000058   0x2120             MOVS     R1,#+32
   \   0000005A   0x.... 0x....      BL       __aeabi_uidivmod
   \   0000005E   0x408F             LSLS     R7,R7,R1
   \   00000060   0x51AF             STR      R7,[R5, R6]
   \   00000062   0xE00D             B        ??xIntEnable_1
    790              }
    791              else if(ulInterrupt == xINT_SYSCTL)
   \                     ??xIntEnable_4:
   \   00000064   0x....             LDR      R0,??DataTable4_1  ;; 0x1716
   \   00000066   0x4284             CMP      R4,R0
   \   00000068   0xD103             BNE      ??xIntEnable_5
    792              {
    793                  xHWREG(NVIC_EN0) = (1 << 6) | (1 << 7);
   \   0000006A   0x....             LDR      R0,??DataTable16_1  ;; 0xe000e100
   \   0000006C   0x21C0             MOVS     R1,#+192
   \   0000006E   0x6001             STR      R1,[R0, #+0]
   \   00000070   0xE006             B        ??xIntEnable_1
    794              }
    795              else if(ulInterrupt == xINT_RTC)
   \                     ??xIntEnable_5:
   \   00000072   0x....             LDR      R0,??DataTable5  ;; 0x2524
   \   00000074   0x4284             CMP      R4,R0
   \   00000076   0xD103             BNE      ??xIntEnable_1
    796              {
    797                  xHWREG(NVIC_EN0) = (1 << 20) | (1 << 21);
   \   00000078   0x....             LDR      R0,??DataTable16_1  ;; 0xe000e100
   \   0000007A   0x21C0             MOVS     R1,#+192
   \   0000007C   0x0389             LSLS     R1,R1,#+14       ;; #+3145728
   \   0000007E   0x6001             STR      R1,[R0, #+0]
    798              }
    799          }
   \                     ??xIntEnable_1:
   \   00000080   0xBDF0             POP      {R4-R7,PC}       ;; return
    800          
    801          //*****************************************************************************
    802          //
    803          //! \brief Disables an interrupt.
    804          //!
    805          //! \param ulInterrupt specifies the interrupt to be disabled.
    806          //!
    807          //! The specified interrupt is disabled in the interrupt controller.  Other
    808          //! enables for the interrupt (such as at the peripheral level) are unaffected
    809          //! by this function.
    810          //!
    811          //! \return None.
    812          //
    813          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
    814          void
    815          xIntDisable(unsigned long ulInterrupt)
    816          {
   \                     xIntDisable:
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    817              //
    818              // Check the arguments.
    819              //
    820              xASSERT(((ulInterrupt >= 4) && (ulInterrupt <= NUM_INTERRUPTS)) || 
    821          	    (ulInterrupt == xINT_SYSCTL) || (ulInterrupt == xINT_RTC));
    822          
    823              //
    824              // Determine the interrupt to disable.
    825              //
    826              if(ulInterrupt == FAULT_SVCALL)
   \   00000004   0x2C0B             CMP      R4,#+11
   \   00000006   0xD106             BNE      ??xIntDisable_0
    827              {
    828                  //
    829                  //   SVC Call Active
    830                  //
    831                  xHWREG(NVIC_SYS_HND_CTRL) &= ~NVIC_SYS_HND_CTRL_SVCA;
   \   00000008   0x....             LDR      R0,??DataTable14  ;; 0xe000ed24
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x2180             MOVS     R1,#+128
   \   0000000E   0x4388             BICS     R0,R0,R1
   \   00000010   0x....             LDR      R1,??DataTable14  ;; 0xe000ed24
   \   00000012   0x6008             STR      R0,[R1, #+0]
   \   00000014   0xE034             B        ??xIntDisable_1
    832              }
    833              else if(ulInterrupt == FAULT_PENDSV)
   \                     ??xIntDisable_0:
   \   00000016   0x2C0E             CMP      R4,#+14
   \   00000018   0xD106             BNE      ??xIntDisable_2
    834              {
    835                  //
    836                  //  SVC Call Pending
    837                  //
    838                  xHWREG(NVIC_SYS_HND_CTRL) &= ~NVIC_SYS_HND_CTRL_SVC;
   \   0000001A   0x....             LDR      R0,??DataTable14  ;; 0xe000ed24
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x....             LDR      R1,??DataTable16_2  ;; 0xffff7fff
   \   00000020   0x4001             ANDS     R1,R1,R0
   \   00000022   0x....             LDR      R0,??DataTable14  ;; 0xe000ed24
   \   00000024   0x6001             STR      R1,[R0, #+0]
   \   00000026   0xE02B             B        ??xIntDisable_1
    839              }
    840              else if(ulInterrupt == FAULT_SYSTICK)
   \                     ??xIntDisable_2:
   \   00000028   0x2C0F             CMP      R4,#+15
   \   0000002A   0xD106             BNE      ??xIntDisable_3
    841              {
    842                  //
    843                  // Disable the System Tick interrupt.
    844                  //
    845                  xHWREG(NVIC_ST_CTRL) &= ~(NVIC_ST_CTRL_INTEN);
   \   0000002C   0x....             LDR      R0,??DataTable16  ;; 0xe000e010
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x2102             MOVS     R1,#+2
   \   00000032   0x4388             BICS     R0,R0,R1
   \   00000034   0x....             LDR      R1,??DataTable16  ;; 0xe000e010
   \   00000036   0x6008             STR      R0,[R1, #+0]
   \   00000038   0xE022             B        ??xIntDisable_1
    846              }
    847              else if((ulInterrupt >= 16) && (ulInterrupt <= 47))
   \                     ??xIntDisable_3:
   \   0000003A   0x2C10             CMP      R4,#+16
   \   0000003C   0xD312             BCC      ??xIntDisable_4
   \   0000003E   0x2C30             CMP      R4,#+48
   \   00000040   0xD210             BCS      ??xIntDisable_4
    848              {
    849                  //
    850                  // Enable the general interrupt.
    851                  //
    852                  xHWREG(NVIC_DIS0 + (((ulInterrupt & 0xFF)-16)/32)*4) 
    853                  = 1 << (((ulInterrupt - 16) & 0xFF)%32);
   \   00000042   0xB2E0             UXTB     R0,R4
   \   00000044   0x3810             SUBS     R0,R0,#+16
   \   00000046   0x0005             MOVS     R5,R0
   \   00000048   0x096D             LSRS     R5,R5,#+5
   \   0000004A   0x2004             MOVS     R0,#+4
   \   0000004C   0x4345             MULS     R5,R0,R5
   \   0000004E   0x....             LDR      R6,??DataTable16_3  ;; 0xe000e180
   \   00000050   0x2701             MOVS     R7,#+1
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x3810             SUBS     R0,R0,#+16
   \   00000056   0xB2C0             UXTB     R0,R0
   \   00000058   0x2120             MOVS     R1,#+32
   \   0000005A   0x.... 0x....      BL       __aeabi_uidivmod
   \   0000005E   0x408F             LSLS     R7,R7,R1
   \   00000060   0x51AF             STR      R7,[R5, R6]
   \   00000062   0xE00D             B        ??xIntDisable_1
    854              }
    855              else if(ulInterrupt == xINT_SYSCTL)
   \                     ??xIntDisable_4:
   \   00000064   0x....             LDR      R0,??DataTable4_1  ;; 0x1716
   \   00000066   0x4284             CMP      R4,R0
   \   00000068   0xD103             BNE      ??xIntDisable_5
    856              {
    857                  xHWREG(NVIC_DIS0) = (1 << 6) | (1 << 7);
   \   0000006A   0x....             LDR      R0,??DataTable16_3  ;; 0xe000e180
   \   0000006C   0x21C0             MOVS     R1,#+192
   \   0000006E   0x6001             STR      R1,[R0, #+0]
   \   00000070   0xE006             B        ??xIntDisable_1
    858              }
    859              else if(ulInterrupt == xINT_RTC)
   \                     ??xIntDisable_5:
   \   00000072   0x....             LDR      R0,??DataTable5  ;; 0x2524
   \   00000074   0x4284             CMP      R4,R0
   \   00000076   0xD103             BNE      ??xIntDisable_1
    860              {
    861                  xHWREG(NVIC_DIS0) = (1 << 20) | (1 << 21);
   \   00000078   0x....             LDR      R0,??DataTable16_3  ;; 0xe000e180
   \   0000007A   0x21C0             MOVS     R1,#+192
   \   0000007C   0x0389             LSLS     R1,R1,#+14       ;; #+3145728
   \   0000007E   0x6001             STR      R1,[R0, #+0]
    862              }
    863          
    864          }
   \                     ??xIntDisable_1:
   \   00000080   0xBDF0             POP      {R4-R7,PC}       ;; return
    865          
    866          //*****************************************************************************
    867          //
    868          //! \brief Pends an interrupt.
    869          //!
    870          //! \param ulInterrupt specifies the interrupt to be pended.
    871          //!
    872          //! The specified interrupt is pended in the interrupt controller.  This will
    873          //! cause the interrupt controller to execute the corresponding interrupt
    874          //! handler at the next available time, based on the current interrupt state
    875          //! priorities.  For example, if called by a higher priority interrupt handler,
    876          //! the specified interrupt handler will not be called until after the current
    877          //! interrupt handler has completed execution.  The interrupt must have been
    878          //! enabled for it to be called.
    879          //!
    880          //! \return None.
    881          //
    882          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
    883          void
    884          xIntPendSet(unsigned long ulInterrupt)
    885          {
   \                     xIntPendSet:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    886              //
    887              // Check the arguments.
    888              //
    889              xASSERT(((ulInterrupt >= 4) && (ulInterrupt <= NUM_INTERRUPTS)) || 
    890          	         (ulInterrupt == xINT_SYSCTL) || (ulInterrupt == xINT_RTC));
    891          
    892              //
    893              // Determine the interrupt to pend.
    894              //
    895              if(ulInterrupt == FAULT_PENDSV)
   \   00000004   0x2C0E             CMP      R4,#+14
   \   00000006   0xD107             BNE      ??xIntPendSet_0
    896              {
    897                  //
    898                  //  PendSV Set Pending
    899                  //
    900                  xHWREG(NVIC_INT_CTRL) |= NVIC_INT_CTRL_PEND_SV;
   \   00000008   0x....             LDR      R0,??DataTable16_4  ;; 0xe000ed04
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x2180             MOVS     R1,#+128
   \   0000000E   0x0549             LSLS     R1,R1,#+21       ;; #+268435456
   \   00000010   0x4301             ORRS     R1,R1,R0
   \   00000012   0x....             LDR      R0,??DataTable16_4  ;; 0xe000ed04
   \   00000014   0x6001             STR      R1,[R0, #+0]
   \   00000016   0xE02B             B        ??xIntPendSet_1
    901              }
    902              else if(ulInterrupt == FAULT_SYSTICK)
   \                     ??xIntPendSet_0:
   \   00000018   0x2C0F             CMP      R4,#+15
   \   0000001A   0xD107             BNE      ??xIntPendSet_2
    903              {
    904                  //
    905                  // Pend the SysTick interrupt.
    906                  //
    907                  xHWREG(NVIC_INT_CTRL) |= NVIC_INT_CTRL_PENDSTSET;
   \   0000001C   0x....             LDR      R0,??DataTable16_4  ;; 0xe000ed04
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x2180             MOVS     R1,#+128
   \   00000022   0x04C9             LSLS     R1,R1,#+19       ;; #+67108864
   \   00000024   0x4301             ORRS     R1,R1,R0
   \   00000026   0x....             LDR      R0,??DataTable16_4  ;; 0xe000ed04
   \   00000028   0x6001             STR      R1,[R0, #+0]
   \   0000002A   0xE021             B        ??xIntPendSet_1
    908              }
    909              else if((ulInterrupt >= 16) && (ulInterrupt <= 47))
   \                     ??xIntPendSet_2:
   \   0000002C   0x2C10             CMP      R4,#+16
   \   0000002E   0xD311             BCC      ??xIntPendSet_3
   \   00000030   0x2C30             CMP      R4,#+48
   \   00000032   0xD20F             BCS      ??xIntPendSet_3
    910              {
    911                  //
    912                  // pend the general interrupt.
    913                  //
    914                  xHWREG(NVIC_PEND0 + ((ulInterrupt & 0xFF)/32)*4) = 1 << (((ulInterrupt & 0xFF) - 16)%32);
   \   00000034   0x2501             MOVS     R5,#+1
   \   00000036   0xB2E0             UXTB     R0,R4
   \   00000038   0x3810             SUBS     R0,R0,#+16
   \   0000003A   0x2120             MOVS     R1,#+32
   \   0000003C   0x.... 0x....      BL       __aeabi_uidivmod
   \   00000040   0x408D             LSLS     R5,R5,R1
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0x0940             LSRS     R0,R0,#+5
   \   00000046   0x0740             LSLS     R0,R0,#+29       ;; ZeroExtS R0,R0,#+29,#+29
   \   00000048   0x0F40             LSRS     R0,R0,#+29
   \   0000004A   0x2104             MOVS     R1,#+4
   \   0000004C   0x4348             MULS     R0,R1,R0
   \   0000004E   0x....             LDR      R1,??DataTable16_5  ;; 0xe000e200
   \   00000050   0x5045             STR      R5,[R0, R1]
   \   00000052   0xE00D             B        ??xIntPendSet_1
    915                  
    916                //  xHWREG(NVIC_PEND0) = 1 << (((ulInterrupt & 0xFF) - 16)%32);
    917              }
    918          	else if(ulInterrupt == xINT_SYSCTL)
   \                     ??xIntPendSet_3:
   \   00000054   0x....             LDR      R0,??DataTable4_1  ;; 0x1716
   \   00000056   0x4284             CMP      R4,R0
   \   00000058   0xD103             BNE      ??xIntPendSet_4
    919          	{
    920          	    xHWREG(NVIC_PEND0) = (1 << 6) | (1 << 7);
   \   0000005A   0x....             LDR      R0,??DataTable16_5  ;; 0xe000e200
   \   0000005C   0x21C0             MOVS     R1,#+192
   \   0000005E   0x6001             STR      R1,[R0, #+0]
   \   00000060   0xE006             B        ??xIntPendSet_1
    921          	}
    922          	else if(ulInterrupt == xINT_RTC)
   \                     ??xIntPendSet_4:
   \   00000062   0x....             LDR      R0,??DataTable5  ;; 0x2524
   \   00000064   0x4284             CMP      R4,R0
   \   00000066   0xD103             BNE      ??xIntPendSet_1
    923          	{
    924          	    xHWREG(NVIC_PEND0) = (1 << 20) | (1 << 21);
   \   00000068   0x....             LDR      R0,??DataTable16_5  ;; 0xe000e200
   \   0000006A   0x21C0             MOVS     R1,#+192
   \   0000006C   0x0389             LSLS     R1,R1,#+14       ;; #+3145728
   \   0000006E   0x6001             STR      R1,[R0, #+0]
    925          	}
    926          
    927          }
   \                     ??xIntPendSet_1:
   \   00000070   0xBD30             POP      {R4,R5,PC}       ;; return
    928          
    929          //*****************************************************************************
    930          //
    931          //! \brief Unpends an interrupt.
    932          //!
    933          //! \param ulInterrupt specifies the interrupt to be unpended.
    934          //!
    935          //! The specified interrupt is unpended in the interrupt controller.  This will
    936          //! cause any previously generated interrupts that have not been handled yet
    937          //! (due to higher priority interrupts or the interrupt no having been enabled
    938          //! yet) to be discarded.
    939          //!
    940          //! \return None.
    941          //
    942          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
    943          void
    944          xIntPendClear(unsigned long ulInterrupt)
    945          {
   \                     xIntPendClear:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    946              //
    947              // Check the arguments.
    948              //
    949              xASSERT(((ulInterrupt >= 4) && (ulInterrupt <= NUM_INTERRUPTS)) || 
    950          	         (ulInterrupt == xINT_SYSCTL) || (ulInterrupt == xINT_RTC));
    951          
    952              //
    953              // Determine the interrupt to unpend.
    954              //
    955              if(ulInterrupt == FAULT_PENDSV)
   \   00000004   0x2C0E             CMP      R4,#+14
   \   00000006   0xD107             BNE      ??xIntPendClear_0
    956              {
    957                  //
    958                  //  PendSV  Unpend
    959                  //
    960                  xHWREG(NVIC_INT_CTRL) |= NVIC_INT_CTRL_UNPEND_SV;
   \   00000008   0x....             LDR      R0,??DataTable16_4  ;; 0xe000ed04
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x2180             MOVS     R1,#+128
   \   0000000E   0x0509             LSLS     R1,R1,#+20       ;; #+134217728
   \   00000010   0x4301             ORRS     R1,R1,R0
   \   00000012   0x....             LDR      R0,??DataTable16_4  ;; 0xe000ed04
   \   00000014   0x6001             STR      R1,[R0, #+0]
   \   00000016   0xE02B             B        ??xIntPendClear_1
    961              }
    962              else if(ulInterrupt == FAULT_SYSTICK)
   \                     ??xIntPendClear_0:
   \   00000018   0x2C0F             CMP      R4,#+15
   \   0000001A   0xD107             BNE      ??xIntPendClear_2
    963              {
    964                  //
    965                  // Unpend the SysTick interrupt.
    966                  //
    967                  xHWREG(NVIC_INT_CTRL) |= NVIC_INT_CTRL_PENDSTCLR;
   \   0000001C   0x....             LDR      R0,??DataTable16_4  ;; 0xe000ed04
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x2180             MOVS     R1,#+128
   \   00000022   0x0489             LSLS     R1,R1,#+18       ;; #+33554432
   \   00000024   0x4301             ORRS     R1,R1,R0
   \   00000026   0x....             LDR      R0,??DataTable16_4  ;; 0xe000ed04
   \   00000028   0x6001             STR      R1,[R0, #+0]
   \   0000002A   0xE021             B        ??xIntPendClear_1
    968              }
    969              else if((ulInterrupt >= 16) && (ulInterrupt <= 47))
   \                     ??xIntPendClear_2:
   \   0000002C   0x2C10             CMP      R4,#+16
   \   0000002E   0xD311             BCC      ??xIntPendClear_3
   \   00000030   0x2C30             CMP      R4,#+48
   \   00000032   0xD20F             BCS      ??xIntPendClear_3
    970              {
    971                  //
    972                  // Unpend the general interrupt.
    973                  //
    974          		xHWREG(NVIC_UNPEND0 + ((ulInterrupt & 0xFF)/32)*4) 
    975                           = 1 << (((ulInterrupt & 0xFF) - 16)%32);
   \   00000034   0x2501             MOVS     R5,#+1
   \   00000036   0xB2E0             UXTB     R0,R4
   \   00000038   0x3810             SUBS     R0,R0,#+16
   \   0000003A   0x2120             MOVS     R1,#+32
   \   0000003C   0x.... 0x....      BL       __aeabi_uidivmod
   \   00000040   0x408D             LSLS     R5,R5,R1
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0x0940             LSRS     R0,R0,#+5
   \   00000046   0x0740             LSLS     R0,R0,#+29       ;; ZeroExtS R0,R0,#+29,#+29
   \   00000048   0x0F40             LSRS     R0,R0,#+29
   \   0000004A   0x2104             MOVS     R1,#+4
   \   0000004C   0x4348             MULS     R0,R1,R0
   \   0000004E   0x....             LDR      R1,??DataTable16_6  ;; 0xe000e280
   \   00000050   0x5045             STR      R5,[R0, R1]
   \   00000052   0xE00D             B        ??xIntPendClear_1
    976              }
    977          	else if(ulInterrupt == xINT_SYSCTL)
   \                     ??xIntPendClear_3:
   \   00000054   0x....             LDR      R0,??DataTable16_7  ;; 0x1716
   \   00000056   0x4284             CMP      R4,R0
   \   00000058   0xD103             BNE      ??xIntPendClear_4
    978          	{
    979          	    xHWREG(NVIC_UNPEND0) = (1 << 6) | (1 << 7);
   \   0000005A   0x....             LDR      R0,??DataTable16_6  ;; 0xe000e280
   \   0000005C   0x21C0             MOVS     R1,#+192
   \   0000005E   0x6001             STR      R1,[R0, #+0]
   \   00000060   0xE006             B        ??xIntPendClear_1
    980          	}
    981          	else if(ulInterrupt == xINT_RTC)
   \                     ??xIntPendClear_4:
   \   00000062   0x....             LDR      R0,??DataTable5  ;; 0x2524
   \   00000064   0x4284             CMP      R4,R0
   \   00000066   0xD103             BNE      ??xIntPendClear_1
    982          	{
    983          	    xHWREG(NVIC_UNPEND0) = (1 << 20) | (1 << 21);
   \   00000068   0x....             LDR      R0,??DataTable16_6  ;; 0xe000e280
   \   0000006A   0x21C0             MOVS     R1,#+192
   \   0000006C   0x0389             LSLS     R1,R1,#+14       ;; #+3145728
   \   0000006E   0x6001             STR      R1,[R0, #+0]
    984          	}
    985          }
   \                     ??xIntPendClear_1:
   \   00000070   0xBD30             POP      {R4,R5,PC}       ;; return
    986          
    987          //*****************************************************************************
    988          //
    989          //! \brief Sets the priority masking level
    990          //!
    991          //! \param ulPriorityMask is the priority level that will be masked.
    992          //!
    993          //! This function sets the interrupt priority masking level so that all
    994          //! interrupts at the specified or lesser priority level is masked.  This
    995          //! can be used to globally disable a set of interrupts with priority below
    996          //! a predetermined threshold.  A value of 0 disables priority
    997          //! masking.
    998          //!
    999          //! Smaller numbers correspond to higher interrupt priorities.  So for example
   1000          //! a priority level mask of 4 will allow interrupts of priority level 0-3,
   1001          //! and interrupts with a numerical priority of 4 and greater will be blocked.
   1002          //!
   1003          //! The hardware priority mechanism will only look at the upper N bits of the
   1004          //! priority level (where N is 2 for the NUC1xx family), so any
   1005          //! prioritization must be performed in those bits.
   1006          //!
   1007          //! \return None.
   1008          //
   1009          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   1010          void
   1011          xIntPriorityMaskSet(unsigned long ulPriorityMask)
   1012          {
   \                     xIntPriorityMaskSet:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1013              xCPUbasepriSet(ulPriorityMask);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       xCPUbasepriSet
   1014          }
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return
   1015          
   1016          //*****************************************************************************
   1017          //
   1018          //! \brief Gets the priority masking level
   1019          //!
   1020          //! This function gets the current setting of the interrupt priority masking
   1021          //! level.  The value returned is the priority level such that all interrupts
   1022          //! of that and lesser priority are masked.  A value of 0 means that priority
   1023          //! masking is disabled.
   1024          //!
   1025          //! Smaller numbers correspond to higher interrupt priorities.  So for example
   1026          //! a priority level mask of 4 will allow interrupts of priority level 0-3,
   1027          //! and interrupts with a numerical priority of 4 and greater will be blocked.
   1028          //!
   1029          //! The hardware priority mechanism will only look at the upper N bits of the
   1030          //! priority level (where N is 2 for the NUC1xx family), so any
   1031          //! prioritization must be performed in those bits.
   1032          //!
   1033          //! \return Returns the value of the interrupt priority level mask.
   1034          //
   1035          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   1036          unsigned long
   1037          xIntPriorityMaskGet(void)
   1038          {
   \                     xIntPriorityMaskGet:
   \   00000000   0xB580             PUSH     {R7,LR}
   1039              return(xCPUbasepriGet());
   \   00000002   0x.... 0x....      BL       xCPUbasepriGet
   \   00000006   0xBD02             POP      {R1,PC}          ;; return
   1040          }
   1041          
   1042          //*****************************************************************************
   1043          //
   1044          //! \brief Enables the SysTick counter.
   1045          //!
   1046          //! This will start the SysTick counter.  If an interrupt handler has been
   1047          //! registered, it will be called when the SysTick counter rolls over.
   1048          //!
   1049          //! \note Calling this function will cause the SysTick counter to (re)commence
   1050          //! counting from its current value.  The counter is not automatically reloaded
   1051          //! with the period as specified in a previous call to xSysTickPeriodSet().  If
   1052          //! an immediate reload is required, the \b NVIC_ST_CURRENT register must be
   1053          //! written to force this.  Any write to this register clears the SysTick
   1054          //! counter to 0 and will cause a reload with the supplied period on the next
   1055          //! clock.
   1056          //!
   1057          //! \return None.
   1058          //
   1059          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   1060          void
   1061          xSysTickEnable(void)
   1062          {
   1063              //
   1064              // Enable SysTick.
   1065              //
   1066              xHWREG(NVIC_ST_CTRL) |= NVIC_ST_CTRL_CLK_SRC | NVIC_ST_CTRL_ENABLE;
   \                     xSysTickEnable:
   \   00000000   0x....             LDR      R0,??DataTable16  ;; 0xe000e010
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2105             MOVS     R1,#+5
   \   00000006   0x4301             ORRS     R1,R1,R0
   \   00000008   0x....             LDR      R0,??DataTable16  ;; 0xe000e010
   \   0000000A   0x6001             STR      R1,[R0, #+0]
   1067          }
   \   0000000C   0x4770             BX       LR               ;; return
   1068          
   1069          //*****************************************************************************
   1070          //
   1071          //! \brief Disables the SysTick counter.
   1072          //!
   1073          //! This will stop the SysTick counter.  If an interrupt handler has been
   1074          //! registered, it will no longer be called until SysTick is restarted.
   1075          //!
   1076          //! \return None.
   1077          //
   1078          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   1079          void
   1080          xSysTickDisable(void)
   1081          {
   1082              //
   1083              // Disable SysTick.
   1084              //
   1085              xHWREG(NVIC_ST_CTRL) &= ~(NVIC_ST_CTRL_ENABLE);
   \                     xSysTickDisable:
   \   00000000   0x....             LDR      R0,??DataTable16  ;; 0xe000e010
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x4388             BICS     R0,R0,R1
   \   00000008   0x....             LDR      R1,??DataTable16  ;; 0xe000e010
   \   0000000A   0x6008             STR      R0,[R1, #+0]
   1086          }
   \   0000000C   0x4770             BX       LR               ;; return
   1087          
   1088          //*****************************************************************************
   1089          //
   1090          //! \brief Enables the SysTick interrupt.
   1091          //!
   1092          //! This function will enable the SysTick interrupt, allowing it to be
   1093          //! reflected to the processor.
   1094          //!
   1095          //! \note The SysTick interrupt handler does not need to clear the SysTick
   1096          //! interrupt source as this is done automatically by NVIC when the interrupt
   1097          //! handler is called.
   1098          //!
   1099          //! \return None.
   1100          //
   1101          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   1102          void
   1103          xSysTickIntEnable(void)
   1104          {
   1105              //
   1106              // Enable the SysTick interrupt.
   1107              //
   1108              xHWREG(NVIC_ST_CTRL) |= NVIC_ST_CTRL_INTEN;
   \                     xSysTickIntEnable:
   \   00000000   0x....             LDR      R0,??DataTable16  ;; 0xe000e010
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2102             MOVS     R1,#+2
   \   00000006   0x4301             ORRS     R1,R1,R0
   \   00000008   0x....             LDR      R0,??DataTable16  ;; 0xe000e010
   \   0000000A   0x6001             STR      R1,[R0, #+0]
   1109          }
   \   0000000C   0x4770             BX       LR               ;; return
   1110          
   1111          //*****************************************************************************
   1112          //
   1113          //! \brief Disables the SysTick interrupt.
   1114          //!
   1115          //! This function will disable the SysTick interrupt, preventing it from being
   1116          //! reflected to the processor.
   1117          //!
   1118          //! \return None.
   1119          //
   1120          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   1121          void
   1122          xSysTickIntDisable(void)
   1123          {
   1124              //
   1125              // Disable the SysTick interrupt.
   1126              //
   1127              xHWREG(NVIC_ST_CTRL) &= ~(NVIC_ST_CTRL_INTEN);
   \                     xSysTickIntDisable:
   \   00000000   0x....             LDR      R0,??DataTable16  ;; 0xe000e010
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2102             MOVS     R1,#+2
   \   00000006   0x4388             BICS     R0,R0,R1
   \   00000008   0x....             LDR      R1,??DataTable16  ;; 0xe000e010
   \   0000000A   0x6008             STR      R0,[R1, #+0]
   1128          }
   \   0000000C   0x4770             BX       LR               ;; return
   1129          
   1130          //*****************************************************************************
   1131          //
   1132          //! \brief Sets the period of the SysTick counter.
   1133          //!
   1134          //! \param ulPeriod is the number of clock ticks in each period of the SysTick
   1135          //! counter; must be between 1 and 16,777,216, inclusive.
   1136          //!
   1137          //! This function sets the rate at which the SysTick counter wraps; this
   1138          //! equates to the number of processor clocks between interrupts.
   1139          //!
   1140          //! \note Calling this function does not cause the SysTick counter to reload
   1141          //! immediately.  If an immediate reload is required, the \b NVIC_ST_CURRENT
   1142          //! register must be written.  Any write to this register clears the SysTick
   1143          //! counter to 0 and will cause a reload with the \e ulPeriod supplied here on
   1144          //! the next clock after the SysTick is enabled.
   1145          //!
   1146          //! \return None.
   1147          //
   1148          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   1149          void
   1150          xSysTickPeriodSet(unsigned long ulPeriod)
   1151          {
   1152              //
   1153              // Check the arguments.
   1154              //
   1155              xASSERT((ulPeriod > 0) && (ulPeriod <= 16777216));
   1156          
   1157              //
   1158              // Set the period of the SysTick counter.
   1159              //
   1160              xHWREG(NVIC_ST_RELOAD) = ulPeriod - 1;
   \                     xSysTickPeriodSet:
   \   00000000   0x1E41             SUBS     R1,R0,#+1
   \   00000002   0x....             LDR      R2,??DataTable16_8  ;; 0xe000e014
   \   00000004   0x6011             STR      R1,[R2, #+0]
   1161          }
   \   00000006   0x4770             BX       LR               ;; return
   1162          
   1163          //*****************************************************************************
   1164          //
   1165          //! \brief Gets the period of the SysTick counter.
   1166          //!
   1167          //! This function returns the rate at which the SysTick counter wraps; this
   1168          //! equates to the number of processor clocks between interrupts.
   1169          //!
   1170          //! \return Returns the period of the SysTick counter.
   1171          //
   1172          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   1173          unsigned long
   1174          xSysTickPeriodGet(void)
   1175          {
   1176              //
   1177              // Return the period of the SysTick counter.
   1178              //
   1179              return(xHWREG(NVIC_ST_RELOAD) + 1);
   \                     xSysTickPeriodGet:
   \   00000000   0x....             LDR      R0,??DataTable16_8  ;; 0xe000e014
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x1C40             ADDS     R0,R0,#+1
   \   00000006   0x4770             BX       LR               ;; return
   1180          }
   1181          
   1182          //*****************************************************************************
   1183          //
   1184          //! \brief Gets the current value of the SysTick counter.
   1185          //!
   1186          //! This function returns the current value of the SysTick counter; this will
   1187          //! be a value between the period - 1 and zero, inclusive.
   1188          //!
   1189          //! \return Returns the current value of the SysTick counter.
   1190          //
   1191          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   1192          unsigned long
   1193          xSysTickValueGet(void)
   1194          {
   1195              //
   1196              // Return the current value of the SysTick counter.
   1197              //
   1198              return(xHWREG(NVIC_ST_CURRENT));
   \                     xSysTickValueGet:
   \   00000000   0x....             LDR      R0,??DataTable16_9  ;; 0xe000e018
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   1199          }
   1200          
   1201          //*****************************************************************************
   1202          //
   1203          //! \brief Set the SysTick pending.
   1204          //!
   1205          //! This function will Set the SysTick pending.
   1206          //!
   1207          //! \return None.
   1208          //
   1209          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   1210          void
   1211          xSysTickPendSet(void)
   1212          {
   1213              //
   1214              // Set the SysTick pending.
   1215              //
   1216              xHWREG(NVIC_INT_CTRL) |= NVIC_INT_CTRL_PENDSTSET;
   \                     xSysTickPendSet:
   \   00000000   0x....             LDR      R0,??DataTable16_4  ;; 0xe000ed04
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2180             MOVS     R1,#+128
   \   00000006   0x04C9             LSLS     R1,R1,#+19       ;; #+67108864
   \   00000008   0x4301             ORRS     R1,R1,R0
   \   0000000A   0x....             LDR      R0,??DataTable16_4  ;; 0xe000ed04
   \   0000000C   0x6001             STR      R1,[R0, #+0]
   1217          }
   \   0000000E   0x4770             BX       LR               ;; return
   1218          
   1219          //*****************************************************************************
   1220          //
   1221          //! \brief Clear the SysTick pending.
   1222          //!
   1223          //! This function will Clear the SysTick pending.
   1224          //!
   1225          //! \return None.
   1226          //
   1227          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   1228          void
   1229          xSysTickPendClr(void)
   1230          {
   1231              //
   1232              // Clear the SysTick pending.
   1233              //
   1234              xHWREG(NVIC_INT_CTRL) |= NVIC_INT_CTRL_PENDSTCLR;
   \                     xSysTickPendClr:
   \   00000000   0x....             LDR      R0,??DataTable16_4  ;; 0xe000ed04
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2180             MOVS     R1,#+128
   \   00000006   0x0489             LSLS     R1,R1,#+18       ;; #+33554432
   \   00000008   0x4301             ORRS     R1,R1,R0
   \   0000000A   0x....             LDR      R0,??DataTable16_4  ;; 0xe000ed04
   \   0000000C   0x6001             STR      R1,[R0, #+0]
   1235          }
   \   0000000E   0x4770             BX       LR               ;; return
   1236          
   1237          //*****************************************************************************
   1238          //
   1239          //! \brief Set the PendSV pending.
   1240          //!
   1241          //! This function will Set the PendSV pending.
   1242          //!
   1243          //! \return None.
   1244          //
   1245          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   1246          void
   1247          xPendSVPendSet(void)
   1248          {
   1249              //
   1250              // Set the PendSV pending.
   1251              //
   1252              xHWREG(NVIC_INT_CTRL) |= NVIC_INT_CTRL_PEND_SV;
   \                     xPendSVPendSet:
   \   00000000   0x....             LDR      R0,??DataTable16_4  ;; 0xe000ed04
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2180             MOVS     R1,#+128
   \   00000006   0x0549             LSLS     R1,R1,#+21       ;; #+268435456
   \   00000008   0x4301             ORRS     R1,R1,R0
   \   0000000A   0x....             LDR      R0,??DataTable16_4  ;; 0xe000ed04
   \   0000000C   0x6001             STR      R1,[R0, #+0]
   1253          }
   \   0000000E   0x4770             BX       LR               ;; return
   1254          
   1255          //*****************************************************************************
   1256          //
   1257          //! \brief Clear the PendSV pending.
   1258          //!
   1259          //! This function will Clear the PendSV pending.
   1260          //!
   1261          //! \return None.
   1262          //
   1263          //*****************************************************************************

   \                                 In section .text, align 2, keep-with-next
   1264          void
   1265          xPendSVPendClr(void)
   1266          {
   1267              //
   1268              // Clear the PendSV pending.
   1269              //
   1270              xHWREG(NVIC_INT_CTRL) |= NVIC_INT_CTRL_UNPEND_SV;
   \                     xPendSVPendClr:
   \   00000000   0x....             LDR      R0,??DataTable16_4  ;; 0xe000ed04
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2180             MOVS     R1,#+128
   \   00000006   0x0509             LSLS     R1,R1,#+20       ;; #+134217728
   \   00000008   0x4301             ORRS     R1,R1,R0
   \   0000000A   0x....             LDR      R0,??DataTable16_4  ;; 0xe000ed04
   \   0000000C   0x6001             STR      R1,[R0, #+0]
   1271          }
   \   0000000E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     g_pulRegs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x00001716         DC32     0x1716

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0xE000E404         DC32     0xe000e404

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x00002524         DC32     0x2524

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0xE000E414         DC32     0xe000e414

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0xE000ED24         DC32     0xe000ed24

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0xE000E010         DC32     0xe000e010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0xFFFF7FFF         DC32     0xffff7fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   0xE000ED04         DC32     0xe000ed04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   0xE000E200         DC32     0xe000e200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \   00000000   0x00001716         DC32     0x1716

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \   00000000   0xE000E014         DC32     0xe000e014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \   00000000   0xE000E018         DC32     0xe000e018
   1272          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  IntDefaultHandler
        0  xCPUbasepriGet
        0  xCPUbasepriSet
        0  xCPUcpsid
        0  xCPUcpsie
        0  xCPUmspGet
        0  xCPUmspSet
        0  xCPUprimask
        0  xCPUpspGet
        0  xCPUpspSet
        0  xCPUwfi
       20  xIntDisable
             20 -> __aeabi_uidivmod
       20  xIntEnable
             20 -> __aeabi_uidivmod
        8  xIntMasterDisable
              8 -> xCPUcpsid
        8  xIntMasterEnable
              8 -> xCPUcpsie
       12  xIntPendClear
             12 -> __aeabi_uidivmod
       12  xIntPendSet
             12 -> __aeabi_uidivmod
        4  xIntPriorityGet
        8  xIntPriorityMaskGet
              8 -> xCPUbasepriGet
        8  xIntPriorityMaskSet
              8 -> xCPUbasepriSet
       12  xIntPrioritySet
        0  xPendSVPendClr
        0  xPendSVPendSet
        0  xSysTickDisable
        0  xSysTickEnable
        0  xSysTickIntDisable
        0  xSysTickIntEnable
        0  xSysTickPendClr
        0  xSysTickPendSet
        0  xSysTickPeriodGet
        0  xSysTickPeriodSet
        0  xSysTickValueGet


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable14
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable5
       2  IntDefaultHandler
      64  g_pulRegs
       2  xCPUbasepriGet
       2  xCPUbasepriSet
       8  xCPUcpsid
       8  xCPUcpsie
       6  xCPUmspGet
       6  xCPUmspSet
       6  xCPUprimask
       6  xCPUpspGet
       6  xCPUpspSet
       4  xCPUwfi
     130  xIntDisable
     130  xIntEnable
      10  xIntMasterDisable
      10  xIntMasterEnable
     114  xIntPendClear
     114  xIntPendSet
      78  xIntPriorityGet
       8  xIntPriorityMaskGet
      12  xIntPriorityMaskSet
     148  xIntPrioritySet
      16  xPendSVPendClr
      16  xPendSVPendSet
      14  xSysTickDisable
      14  xSysTickEnable
      14  xSysTickIntDisable
      14  xSysTickIntEnable
      16  xSysTickPendClr
      16  xSysTickPendSet
       8  xSysTickPeriodGet
       8  xSysTickPeriodSet
       6  xSysTickValueGet

 
    64 bytes in section .rodata
 1 016 bytes in section .text
 
 1 016 bytes of CODE  memory
    64 bytes of CONST memory

Errors: none
Warnings: none
